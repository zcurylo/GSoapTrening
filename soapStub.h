/* soapStub.h
   Generated by gSOAP 2.8.23 from media.h

Copyright(C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_ns1	"http://www.onvif.org/ver10/media/wsdl"
#define SOAP_NAMESPACE_OF_ns2	"http://www.onvif.org/ver10/schema"
#define SOAP_NAMESPACE_OF_ns3	"http://docs.oasis-open.org/wsn/b-2"
#define SOAP_NAMESPACE_OF_ns4	"http://www.w3.org/2004/08/xop/include"
#define SOAP_NAMESPACE_OF_ns5	"http://docs.oasis-open.org/wsrf/bf-2"
#define SOAP_NAMESPACE_OF_ns6	"http://docs.oasis-open.org/wsn/t-1"
#define SOAP_NAMESPACE_OF_ns7	"http://www.w3.org/2005/08/addressing"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20823
# error "GSOAP VERSION 20823 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns2__RotateMode
#define SOAP_TYPE_ns2__RotateMode (766)
/* ns2:RotateMode */
enum ns2__RotateMode { ns2__RotateMode__OFF = 0, ns2__RotateMode__ON = 1, ns2__RotateMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_ns2__VideoEncoding
#define SOAP_TYPE_ns2__VideoEncoding (768)
/* ns2:VideoEncoding */
enum ns2__VideoEncoding { ns2__VideoEncoding__JPEG = 0, ns2__VideoEncoding__MPEG4 = 1, ns2__VideoEncoding__H264 = 2 };
#endif

#ifndef SOAP_TYPE_ns2__Mpeg4Profile
#define SOAP_TYPE_ns2__Mpeg4Profile (770)
/* ns2:Mpeg4Profile */
enum ns2__Mpeg4Profile { ns2__Mpeg4Profile__SP = 0, ns2__Mpeg4Profile__ASP = 1 };
#endif

#ifndef SOAP_TYPE_ns2__H264Profile
#define SOAP_TYPE_ns2__H264Profile (772)
/* ns2:H264Profile */
enum ns2__H264Profile { ns2__H264Profile__Baseline = 0, ns2__H264Profile__Main = 1, ns2__H264Profile__Extended = 2, ns2__H264Profile__High = 3 };
#endif

#ifndef SOAP_TYPE_ns2__AudioEncoding
#define SOAP_TYPE_ns2__AudioEncoding (774)
/* ns2:AudioEncoding */
enum ns2__AudioEncoding { ns2__AudioEncoding__G711 = 0, ns2__AudioEncoding__G726 = 1, ns2__AudioEncoding__AAC = 2 };
#endif

#ifndef SOAP_TYPE_ns2__MetadataCompressionType
#define SOAP_TYPE_ns2__MetadataCompressionType (776)
/* ns2:MetadataCompressionType */
enum ns2__MetadataCompressionType { ns2__MetadataCompressionType__None = 0, ns2__MetadataCompressionType__GZIP = 1, ns2__MetadataCompressionType__EXI = 2 };
#endif

#ifndef SOAP_TYPE_ns2__StreamType
#define SOAP_TYPE_ns2__StreamType (778)
/* ns2:StreamType */
enum ns2__StreamType { ns2__StreamType__RTP_Unicast = 0, ns2__StreamType__RTP_Multicast = 1 };
#endif

#ifndef SOAP_TYPE_ns2__TransportProtocol
#define SOAP_TYPE_ns2__TransportProtocol (780)
/* ns2:TransportProtocol */
enum ns2__TransportProtocol { ns2__TransportProtocol__UDP = 0, ns2__TransportProtocol__TCP = 1, ns2__TransportProtocol__RTSP = 2, ns2__TransportProtocol__HTTP = 3 };
#endif

#ifndef SOAP_TYPE_ns2__ScopeDefinition
#define SOAP_TYPE_ns2__ScopeDefinition (782)
/* ns2:ScopeDefinition */
enum ns2__ScopeDefinition { ns2__ScopeDefinition__Fixed = 0, ns2__ScopeDefinition__Configurable = 1 };
#endif

#ifndef SOAP_TYPE_ns2__DiscoveryMode
#define SOAP_TYPE_ns2__DiscoveryMode (784)
/* ns2:DiscoveryMode */
enum ns2__DiscoveryMode { ns2__DiscoveryMode__Discoverable = 0, ns2__DiscoveryMode__NonDiscoverable = 1 };
#endif

#ifndef SOAP_TYPE_ns2__Duplex
#define SOAP_TYPE_ns2__Duplex (788)
/* ns2:Duplex */
enum ns2__Duplex { ns2__Duplex__Full = 0, ns2__Duplex__Half = 1 };
#endif

#ifndef SOAP_TYPE_ns2__IPv6DHCPConfiguration
#define SOAP_TYPE_ns2__IPv6DHCPConfiguration (792)
/* ns2:IPv6DHCPConfiguration */
enum ns2__IPv6DHCPConfiguration { ns2__IPv6DHCPConfiguration__Auto = 0, ns2__IPv6DHCPConfiguration__Stateful = 1, ns2__IPv6DHCPConfiguration__Stateless = 2, ns2__IPv6DHCPConfiguration__Off = 3 };
#endif

#ifndef SOAP_TYPE_ns2__NetworkProtocolType
#define SOAP_TYPE_ns2__NetworkProtocolType (794)
/* ns2:NetworkProtocolType */
enum ns2__NetworkProtocolType { ns2__NetworkProtocolType__HTTP = 0, ns2__NetworkProtocolType__HTTPS = 1, ns2__NetworkProtocolType__RTSP = 2 };
#endif

#ifndef SOAP_TYPE_ns2__NetworkHostType
#define SOAP_TYPE_ns2__NetworkHostType (796)
/* ns2:NetworkHostType */
enum ns2__NetworkHostType { ns2__NetworkHostType__IPv4 = 0, ns2__NetworkHostType__IPv6 = 1, ns2__NetworkHostType__DNS = 2 };
#endif

#ifndef SOAP_TYPE_ns2__IPType
#define SOAP_TYPE_ns2__IPType (804)
/* ns2:IPType */
enum ns2__IPType { ns2__IPType__IPv4 = 0, ns2__IPType__IPv6 = 1 };
#endif

#ifndef SOAP_TYPE_ns2__IPAddressFilterType
#define SOAP_TYPE_ns2__IPAddressFilterType (810)
/* ns2:IPAddressFilterType */
enum ns2__IPAddressFilterType { ns2__IPAddressFilterType__Allow = 0, ns2__IPAddressFilterType__Deny = 1 };
#endif

#ifndef SOAP_TYPE_ns2__DynamicDNSType
#define SOAP_TYPE_ns2__DynamicDNSType (812)
/* ns2:DynamicDNSType */
enum ns2__DynamicDNSType { ns2__DynamicDNSType__NoUpdate = 0, ns2__DynamicDNSType__ClientUpdates = 1, ns2__DynamicDNSType__ServerUpdates = 2 };
#endif

#ifndef SOAP_TYPE_ns2__Dot11StationMode
#define SOAP_TYPE_ns2__Dot11StationMode (816)
/* ns2:Dot11StationMode */
enum ns2__Dot11StationMode { ns2__Dot11StationMode__Ad_hoc = 0, ns2__Dot11StationMode__Infrastructure = 1, ns2__Dot11StationMode__Extended = 2 };
#endif

#ifndef SOAP_TYPE_ns2__Dot11SecurityMode
#define SOAP_TYPE_ns2__Dot11SecurityMode (818)
/* ns2:Dot11SecurityMode */
enum ns2__Dot11SecurityMode { ns2__Dot11SecurityMode__None = 0, ns2__Dot11SecurityMode__WEP = 1, ns2__Dot11SecurityMode__PSK = 2, ns2__Dot11SecurityMode__Dot1X = 3, ns2__Dot11SecurityMode__Extended = 4 };
#endif

#ifndef SOAP_TYPE_ns2__Dot11Cipher
#define SOAP_TYPE_ns2__Dot11Cipher (820)
/* ns2:Dot11Cipher */
enum ns2__Dot11Cipher { ns2__Dot11Cipher__CCMP = 0, ns2__Dot11Cipher__TKIP = 1, ns2__Dot11Cipher__Any = 2, ns2__Dot11Cipher__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__Dot11SignalStrength
#define SOAP_TYPE_ns2__Dot11SignalStrength (826)
/* ns2:Dot11SignalStrength */
enum ns2__Dot11SignalStrength { ns2__Dot11SignalStrength__None = 0, ns2__Dot11SignalStrength__Very_x0020Bad = 1, ns2__Dot11SignalStrength__Bad = 2, ns2__Dot11SignalStrength__Good = 3, ns2__Dot11SignalStrength__Very_x0020Good = 4, ns2__Dot11SignalStrength__Extended = 5 };
#endif

#ifndef SOAP_TYPE_ns2__Dot11AuthAndMangementSuite
#define SOAP_TYPE_ns2__Dot11AuthAndMangementSuite (828)
/* ns2:Dot11AuthAndMangementSuite */
enum ns2__Dot11AuthAndMangementSuite { ns2__Dot11AuthAndMangementSuite__None = 0, ns2__Dot11AuthAndMangementSuite__Dot1X = 1, ns2__Dot11AuthAndMangementSuite__PSK = 2, ns2__Dot11AuthAndMangementSuite__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__CapabilityCategory
#define SOAP_TYPE_ns2__CapabilityCategory (830)
/* ns2:CapabilityCategory */
enum ns2__CapabilityCategory { ns2__CapabilityCategory__All = 0, ns2__CapabilityCategory__Analytics = 1, ns2__CapabilityCategory__Device = 2, ns2__CapabilityCategory__Events = 3, ns2__CapabilityCategory__Imaging = 4, ns2__CapabilityCategory__Media = 5, ns2__CapabilityCategory__PTZ = 6 };
#endif

#ifndef SOAP_TYPE_ns2__SystemLogType
#define SOAP_TYPE_ns2__SystemLogType (832)
/* ns2:SystemLogType */
enum ns2__SystemLogType { ns2__SystemLogType__System = 0, ns2__SystemLogType__Access = 1 };
#endif

#ifndef SOAP_TYPE_ns2__FactoryDefaultType
#define SOAP_TYPE_ns2__FactoryDefaultType (834)
/* ns2:FactoryDefaultType */
enum ns2__FactoryDefaultType { ns2__FactoryDefaultType__Hard = 0, ns2__FactoryDefaultType__Soft = 1 };
#endif

#ifndef SOAP_TYPE_ns2__SetDateTimeType
#define SOAP_TYPE_ns2__SetDateTimeType (836)
/* ns2:SetDateTimeType */
enum ns2__SetDateTimeType { ns2__SetDateTimeType__Manual = 0, ns2__SetDateTimeType__NTP = 1 };
#endif

#ifndef SOAP_TYPE_ns2__UserLevel
#define SOAP_TYPE_ns2__UserLevel (838)
/* ns2:UserLevel */
enum ns2__UserLevel { ns2__UserLevel__Administrator = 0, ns2__UserLevel__Operator = 1, ns2__UserLevel__User = 2, ns2__UserLevel__Anonymous = 3, ns2__UserLevel__Extended = 4 };
#endif

#ifndef SOAP_TYPE_ns2__RelayLogicalState
#define SOAP_TYPE_ns2__RelayLogicalState (840)
/* ns2:RelayLogicalState */
enum ns2__RelayLogicalState { ns2__RelayLogicalState__active = 0, ns2__RelayLogicalState__inactive = 1 };
#endif

#ifndef SOAP_TYPE_ns2__RelayIdleState
#define SOAP_TYPE_ns2__RelayIdleState (842)
/* ns2:RelayIdleState */
enum ns2__RelayIdleState { ns2__RelayIdleState__closed = 0, ns2__RelayIdleState__open = 1 };
#endif

#ifndef SOAP_TYPE_ns2__RelayMode
#define SOAP_TYPE_ns2__RelayMode (844)
/* ns2:RelayMode */
enum ns2__RelayMode { ns2__RelayMode__Monostable = 0, ns2__RelayMode__Bistable = 1 };
#endif

#ifndef SOAP_TYPE_ns2__EFlipMode
#define SOAP_TYPE_ns2__EFlipMode (846)
/* ns2:EFlipMode */
enum ns2__EFlipMode { ns2__EFlipMode__OFF = 0, ns2__EFlipMode__ON = 1, ns2__EFlipMode__Extended = 2 };
#endif

#ifndef SOAP_TYPE_ns2__ReverseMode
#define SOAP_TYPE_ns2__ReverseMode (848)
/* ns2:ReverseMode */
enum ns2__ReverseMode { ns2__ReverseMode__OFF = 0, ns2__ReverseMode__ON = 1, ns2__ReverseMode__AUTO = 2, ns2__ReverseMode__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__MoveStatus
#define SOAP_TYPE_ns2__MoveStatus (852)
/* ns2:MoveStatus */
enum ns2__MoveStatus { ns2__MoveStatus__IDLE = 0, ns2__MoveStatus__MOVING = 1, ns2__MoveStatus__UNKNOWN = 2 };
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourState
#define SOAP_TYPE_ns2__PTZPresetTourState (854)
/* ns2:PTZPresetTourState */
enum ns2__PTZPresetTourState { ns2__PTZPresetTourState__Idle = 0, ns2__PTZPresetTourState__Touring = 1, ns2__PTZPresetTourState__Paused = 2, ns2__PTZPresetTourState__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourDirection
#define SOAP_TYPE_ns2__PTZPresetTourDirection (856)
/* ns2:PTZPresetTourDirection */
enum ns2__PTZPresetTourDirection { ns2__PTZPresetTourDirection__Forward = 0, ns2__PTZPresetTourDirection__Backward = 1, ns2__PTZPresetTourDirection__Extended = 2 };
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourOperation
#define SOAP_TYPE_ns2__PTZPresetTourOperation (858)
/* ns2:PTZPresetTourOperation */
enum ns2__PTZPresetTourOperation { ns2__PTZPresetTourOperation__Start = 0, ns2__PTZPresetTourOperation__Stop = 1, ns2__PTZPresetTourOperation__Pause = 2, ns2__PTZPresetTourOperation__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__AutoFocusMode
#define SOAP_TYPE_ns2__AutoFocusMode (860)
/* ns2:AutoFocusMode */
enum ns2__AutoFocusMode { ns2__AutoFocusMode__AUTO = 0, ns2__AutoFocusMode__MANUAL = 1 };
#endif

#ifndef SOAP_TYPE_ns2__WideDynamicMode
#define SOAP_TYPE_ns2__WideDynamicMode (862)
/* ns2:WideDynamicMode */
enum ns2__WideDynamicMode { ns2__WideDynamicMode__OFF = 0, ns2__WideDynamicMode__ON = 1 };
#endif

#ifndef SOAP_TYPE_ns2__BacklightCompensationMode
#define SOAP_TYPE_ns2__BacklightCompensationMode (864)
/* ns2:BacklightCompensationMode */
enum ns2__BacklightCompensationMode { ns2__BacklightCompensationMode__OFF = 0, ns2__BacklightCompensationMode__ON = 1 };
#endif

#ifndef SOAP_TYPE_ns2__ExposurePriority
#define SOAP_TYPE_ns2__ExposurePriority (866)
/* ns2:ExposurePriority */
enum ns2__ExposurePriority { ns2__ExposurePriority__LowNoise = 0, ns2__ExposurePriority__FrameRate = 1 };
#endif

#ifndef SOAP_TYPE_ns2__ExposureMode
#define SOAP_TYPE_ns2__ExposureMode (868)
/* ns2:ExposureMode */
enum ns2__ExposureMode { ns2__ExposureMode__AUTO = 0, ns2__ExposureMode__MANUAL = 1 };
#endif

#ifndef SOAP_TYPE_ns2__Enabled
#define SOAP_TYPE_ns2__Enabled (870)
/* ns2:Enabled */
enum ns2__Enabled { ns2__Enabled__ENABLED = 0, ns2__Enabled__DISABLED = 1 };
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalanceMode
#define SOAP_TYPE_ns2__WhiteBalanceMode (872)
/* ns2:WhiteBalanceMode */
enum ns2__WhiteBalanceMode { ns2__WhiteBalanceMode__AUTO = 0, ns2__WhiteBalanceMode__MANUAL = 1 };
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterMode
#define SOAP_TYPE_ns2__IrCutFilterMode (874)
/* ns2:IrCutFilterMode */
enum ns2__IrCutFilterMode { ns2__IrCutFilterMode__ON = 0, ns2__IrCutFilterMode__OFF = 1, ns2__IrCutFilterMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_ns2__ImageStabilizationMode
#define SOAP_TYPE_ns2__ImageStabilizationMode (876)
/* ns2:ImageStabilizationMode */
enum ns2__ImageStabilizationMode { ns2__ImageStabilizationMode__OFF = 0, ns2__ImageStabilizationMode__ON = 1, ns2__ImageStabilizationMode__AUTO = 2, ns2__ImageStabilizationMode__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType
#define SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType (878)
/* ns2:IrCutFilterAutoBoundaryType */
enum ns2__IrCutFilterAutoBoundaryType { ns2__IrCutFilterAutoBoundaryType__Common = 0, ns2__IrCutFilterAutoBoundaryType__ToOn = 1, ns2__IrCutFilterAutoBoundaryType__ToOff = 2, ns2__IrCutFilterAutoBoundaryType__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__ToneCompensationMode
#define SOAP_TYPE_ns2__ToneCompensationMode (880)
/* ns2:ToneCompensationMode */
enum ns2__ToneCompensationMode { ns2__ToneCompensationMode__OFF = 0, ns2__ToneCompensationMode__ON = 1, ns2__ToneCompensationMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_ns2__DefoggingMode
#define SOAP_TYPE_ns2__DefoggingMode (882)
/* ns2:DefoggingMode */
enum ns2__DefoggingMode { ns2__DefoggingMode__OFF = 0, ns2__DefoggingMode__ON = 1, ns2__DefoggingMode__AUTO = 2 };
#endif

#ifndef SOAP_TYPE_ns2__PropertyOperation
#define SOAP_TYPE_ns2__PropertyOperation (886)
/* ns2:PropertyOperation */
enum ns2__PropertyOperation { ns2__PropertyOperation__Initialized = 0, ns2__PropertyOperation__Deleted = 1, ns2__PropertyOperation__Changed = 2 };
#endif

#ifndef SOAP_TYPE_ns2__Direction
#define SOAP_TYPE_ns2__Direction (888)
/* ns2:Direction */
enum ns2__Direction { ns2__Direction__Left = 0, ns2__Direction__Right = 1, ns2__Direction__Any = 2 };
#endif

#ifndef SOAP_TYPE_ns2__ClassType
#define SOAP_TYPE_ns2__ClassType (890)
/* ns2:ClassType */
enum ns2__ClassType { ns2__ClassType__Animal = 0, ns2__ClassType__Face = 1, ns2__ClassType__Human = 2, ns2__ClassType__Vehical = 3, ns2__ClassType__Other = 4 };
#endif

#ifndef SOAP_TYPE_ns2__ReceiverMode
#define SOAP_TYPE_ns2__ReceiverMode (892)
/* ns2:ReceiverMode */
enum ns2__ReceiverMode { ns2__ReceiverMode__AutoConnect = 0, ns2__ReceiverMode__AlwaysConnect = 1, ns2__ReceiverMode__NeverConnect = 2, ns2__ReceiverMode__Unknown = 3 };
#endif

#ifndef SOAP_TYPE_ns2__ReceiverState
#define SOAP_TYPE_ns2__ReceiverState (894)
/* ns2:ReceiverState */
enum ns2__ReceiverState { ns2__ReceiverState__NotConnected = 0, ns2__ReceiverState__Connecting = 1, ns2__ReceiverState__Connected = 2, ns2__ReceiverState__Unknown = 3 };
#endif

#ifndef SOAP_TYPE_ns2__SearchState
#define SOAP_TYPE_ns2__SearchState (900)
/* ns2:SearchState */
enum ns2__SearchState { ns2__SearchState__Queued = 0, ns2__SearchState__Searching = 1, ns2__SearchState__Completed = 2, ns2__SearchState__Unknown = 3 };
#endif

#ifndef SOAP_TYPE_ns2__RecordingStatus
#define SOAP_TYPE_ns2__RecordingStatus (902)
/* ns2:RecordingStatus */
enum ns2__RecordingStatus { ns2__RecordingStatus__Initiated = 0, ns2__RecordingStatus__Recording = 1, ns2__RecordingStatus__Stopped = 2, ns2__RecordingStatus__Removing = 3, ns2__RecordingStatus__Removed = 4, ns2__RecordingStatus__Unknown = 5 };
#endif

#ifndef SOAP_TYPE_ns2__TrackType
#define SOAP_TYPE_ns2__TrackType (904)
/* ns2:TrackType */
enum ns2__TrackType { ns2__TrackType__Video = 0, ns2__TrackType__Audio = 1, ns2__TrackType__Metadata = 2, ns2__TrackType__Extended = 3 };
#endif

#ifndef SOAP_TYPE_ns2__ModeOfOperation
#define SOAP_TYPE_ns2__ModeOfOperation (910)
/* ns2:ModeOfOperation */
enum ns2__ModeOfOperation { ns2__ModeOfOperation__Idle = 0, ns2__ModeOfOperation__Active = 1, ns2__ModeOfOperation__Unknown = 2 };
#endif

#ifndef SOAP_TYPE_ns2__OSDType
#define SOAP_TYPE_ns2__OSDType (914)
/* ns2:OSDType */
enum ns2__OSDType { ns2__OSDType__Text = 0, ns2__OSDType__Image = 1, ns2__OSDType__Extended = 2 };
#endif

#ifndef SOAP_TYPE_ns7__RelationshipType
#define SOAP_TYPE_ns7__RelationshipType (922)
/* ns7:RelationshipType */
enum ns7__RelationshipType { ns7__RelationshipType__http_x003a_x002f_x002fwww_x002ew3_x002eorg_x002f2005_x002f08_x002faddressing_x002freply = 0 };
#endif

#ifndef SOAP_TYPE_ns7__FaultCodesType
#define SOAP_TYPE_ns7__FaultCodesType (924)
/* ns7:FaultCodesType */
enum ns7__FaultCodesType { ns7__FaultCodesType__ns7__InvalidAddressingHeader = 0, ns7__FaultCodesType__ns7__InvalidAddress = 1, ns7__FaultCodesType__ns7__InvalidEPR = 2, ns7__FaultCodesType__ns7__InvalidCardinality = 3, ns7__FaultCodesType__ns7__MissingAddressInEPR = 4, ns7__FaultCodesType__ns7__DuplicateMessageID = 5, ns7__FaultCodesType__ns7__ActionMismatch = 6, ns7__FaultCodesType__ns7__MessageAddressingHeaderRequired = 7, ns7__FaultCodesType__ns7__DestinationUnreachable = 8, ns7__FaultCodesType__ns7__ActionNotSupported = 9, ns7__FaultCodesType__ns7__EndpointUnavailable = 10 };
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE_xsd__QName
#define SOAP_TYPE_xsd__QName (11)
typedef std::string xsd__QName;
#endif


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__anyType
#define SOAP_TYPE_xsd__anyType (8)
/* Primitive xsd:anyType schema type: */
class SOAP_CMAC xsd__anyType
{
public:
	char *__item;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 8; } /* = unique type id SOAP_TYPE_xsd__anyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyType() { xsd__anyType::soap_default(NULL); }
	virtual ~xsd__anyType() { }
};
#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_xsd__base64Binary
#define SOAP_TYPE_xsd__base64Binary (12)
/* Base64 schema type: */
class SOAP_CMAC xsd__base64Binary
{
public:
	unsigned char *__ptr;
	int __size;
	char *id;	/* optional element of type xsd:string */
	char *type;	/* optional element of type xsd:string */
	char *options;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique type id SOAP_TYPE_xsd__base64Binary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary() { xsd__base64Binary::soap_default(NULL); }
	virtual ~xsd__base64Binary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary
#define SOAP_TYPE_xsd__hexBinary (16)
/* hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary
{
public:
	unsigned char *__ptr;
	int __size;
public:
	virtual int soap_type() const { return 16; } /* = unique type id SOAP_TYPE_xsd__hexBinary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary() { xsd__hexBinary::soap_default(NULL); }
	virtual ~xsd__hexBinary() { }
};
#endif

#ifndef SOAP_TYPE_xsd__NCName_
#define SOAP_TYPE_xsd__NCName_ (19)
/* Primitive xsd:NCName schema type: */
class SOAP_CMAC xsd__NCName_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 19; } /* = unique type id SOAP_TYPE_xsd__NCName_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__NCName_() { xsd__NCName_::soap_default(NULL); }
	virtual ~xsd__NCName_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__QName_
#define SOAP_TYPE_xsd__QName_ (20)
/* Primitive xsd:QName schema type: */
class SOAP_CMAC xsd__QName_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 20; } /* = unique type id SOAP_TYPE_xsd__QName_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__QName_() { xsd__QName_::soap_default(NULL); }
	virtual ~xsd__QName_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType_
#define SOAP_TYPE_xsd__anySimpleType_ (22)
/* Primitive xsd:anySimpleType schema type: */
class SOAP_CMAC xsd__anySimpleType_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 22; } /* = unique type id SOAP_TYPE_xsd__anySimpleType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anySimpleType_() { xsd__anySimpleType_::soap_default(NULL); }
	virtual ~xsd__anySimpleType_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__anyURI_
#define SOAP_TYPE_xsd__anyURI_ (24)
/* Primitive xsd:anyURI schema type: */
class SOAP_CMAC xsd__anyURI_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 24; } /* = unique type id SOAP_TYPE_xsd__anyURI_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__anyURI_() { xsd__anyURI_::soap_default(NULL); }
	virtual ~xsd__anyURI_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__base64Binary_
#define SOAP_TYPE_xsd__base64Binary_ (25)
/* Primitive xsd:base64Binary schema type: */
class SOAP_CMAC xsd__base64Binary_ : public xsd__anyType
{
public:
	xsd__base64Binary __item;
public:
	virtual int soap_type() const { return 25; } /* = unique type id SOAP_TYPE_xsd__base64Binary_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__base64Binary_() { xsd__base64Binary_::soap_default(NULL); }
	virtual ~xsd__base64Binary_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__boolean
#define SOAP_TYPE_xsd__boolean (26)
/* Primitive xsd:boolean schema type: */
class SOAP_CMAC xsd__boolean : public xsd__anyType
{
public:
	bool __item;
public:
	virtual int soap_type() const { return 26; } /* = unique type id SOAP_TYPE_xsd__boolean */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__boolean() { xsd__boolean::soap_default(NULL); }
	virtual ~xsd__boolean() { }
};
#endif

#ifndef SOAP_TYPE_xsd__dateTime
#define SOAP_TYPE_xsd__dateTime (28)
/* Primitive xsd:dateTime schema type: */
class SOAP_CMAC xsd__dateTime : public xsd__anyType
{
public:
	time_t __item;
public:
	virtual int soap_type() const { return 28; } /* = unique type id SOAP_TYPE_xsd__dateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__dateTime() { xsd__dateTime::soap_default(NULL); }
	virtual ~xsd__dateTime() { }
};
#endif

#ifndef SOAP_TYPE_xsd__duration_
#define SOAP_TYPE_xsd__duration_ (31)
/* Primitive xsd:duration schema type: */
class SOAP_CMAC xsd__duration_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_xsd__duration_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__duration_() { xsd__duration_::soap_default(NULL); }
	virtual ~xsd__duration_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__float
#define SOAP_TYPE_xsd__float (32)
/* Primitive xsd:float schema type: */
class SOAP_CMAC xsd__float : public xsd__anyType
{
public:
	float __item;
public:
	virtual int soap_type() const { return 32; } /* = unique type id SOAP_TYPE_xsd__float */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__float() { xsd__float::soap_default(NULL); }
	virtual ~xsd__float() { }
};
#endif

#ifndef SOAP_TYPE_xsd__hexBinary_
#define SOAP_TYPE_xsd__hexBinary_ (34)
/* Primitive xsd:hexBinary schema type: */
class SOAP_CMAC xsd__hexBinary_ : public xsd__anyType
{
public:
	xsd__hexBinary __item;
public:
	virtual int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_xsd__hexBinary_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__hexBinary_() { xsd__hexBinary_::soap_default(NULL); }
	virtual ~xsd__hexBinary_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (35)
/* Primitive xsd:int schema type: */
class SOAP_CMAC xsd__int : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 35; } /* = unique type id SOAP_TYPE_xsd__int */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__int() { xsd__int::soap_default(NULL); }
	virtual ~xsd__int() { }
};
#endif

#ifndef SOAP_TYPE_xsd__integer_
#define SOAP_TYPE_xsd__integer_ (37)
/* Primitive xsd:integer schema type: */
class SOAP_CMAC xsd__integer_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_xsd__integer_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__integer_() { xsd__integer_::soap_default(NULL); }
	virtual ~xsd__integer_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger_
#define SOAP_TYPE_xsd__nonNegativeInteger_ (39)
/* Primitive xsd:nonNegativeInteger schema type: */
class SOAP_CMAC xsd__nonNegativeInteger_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_xsd__nonNegativeInteger_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__nonNegativeInteger_() { xsd__nonNegativeInteger_::soap_default(NULL); }
	virtual ~xsd__nonNegativeInteger_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (40)
/* Primitive xsd:string schema type: */
class SOAP_CMAC xsd__string : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 40; } /* = unique type id SOAP_TYPE_xsd__string */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__string() { xsd__string::soap_default(NULL); }
	virtual ~xsd__string() { }
};
#endif

#ifndef SOAP_TYPE_xsd__token_
#define SOAP_TYPE_xsd__token_ (42)
/* Primitive xsd:token schema type: */
class SOAP_CMAC xsd__token_ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 42; } /* = unique type id SOAP_TYPE_xsd__token_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__token_() { xsd__token_::soap_default(NULL); }
	virtual ~xsd__token_() { }
};
#endif

#ifndef SOAP_TYPE_xsd__unsignedLong
#define SOAP_TYPE_xsd__unsignedLong (43)
/* Primitive xsd:unsignedLong schema type: */
class SOAP_CMAC xsd__unsignedLong : public xsd__anyType
{
public:
	ULONG64 __item;
public:
	virtual int soap_type() const { return 43; } /* = unique type id SOAP_TYPE_xsd__unsignedLong */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         xsd__unsignedLong() { xsd__unsignedLong::soap_default(NULL); }
	virtual ~xsd__unsignedLong() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReferenceToken__
#define SOAP_TYPE_ns2__ReferenceToken__ (763)
/* Primitive ns2:ReferenceToken schema type: */
class SOAP_CMAC ns2__ReferenceToken__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 763; } /* = unique type id SOAP_TYPE_ns2__ReferenceToken__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReferenceToken__() { ns2__ReferenceToken__::soap_default(NULL); }
	virtual ~ns2__ReferenceToken__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Name__
#define SOAP_TYPE_ns2__Name__ (765)
/* Primitive ns2:Name schema type: */
class SOAP_CMAC ns2__Name__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 765; } /* = unique type id SOAP_TYPE_ns2__Name__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Name__() { ns2__Name__::soap_default(NULL); }
	virtual ~ns2__Name__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RotateMode_
#define SOAP_TYPE_ns2__RotateMode_ (767)
/* Primitive ns2:RotateMode schema type: */
class SOAP_CMAC ns2__RotateMode_ : public xsd__anyType
{
public:
	enum ns2__RotateMode __item;
public:
	virtual int soap_type() const { return 767; } /* = unique type id SOAP_TYPE_ns2__RotateMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RotateMode_() { ns2__RotateMode_::soap_default(NULL); }
	virtual ~ns2__RotateMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoEncoding_
#define SOAP_TYPE_ns2__VideoEncoding_ (769)
/* Primitive ns2:VideoEncoding schema type: */
class SOAP_CMAC ns2__VideoEncoding_ : public xsd__anyType
{
public:
	enum ns2__VideoEncoding __item;
public:
	virtual int soap_type() const { return 769; } /* = unique type id SOAP_TYPE_ns2__VideoEncoding_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoEncoding_() { ns2__VideoEncoding_::soap_default(NULL); }
	virtual ~ns2__VideoEncoding_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Mpeg4Profile_
#define SOAP_TYPE_ns2__Mpeg4Profile_ (771)
/* Primitive ns2:Mpeg4Profile schema type: */
class SOAP_CMAC ns2__Mpeg4Profile_ : public xsd__anyType
{
public:
	enum ns2__Mpeg4Profile __item;
public:
	virtual int soap_type() const { return 771; } /* = unique type id SOAP_TYPE_ns2__Mpeg4Profile_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Mpeg4Profile_() { ns2__Mpeg4Profile_::soap_default(NULL); }
	virtual ~ns2__Mpeg4Profile_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__H264Profile_
#define SOAP_TYPE_ns2__H264Profile_ (773)
/* Primitive ns2:H264Profile schema type: */
class SOAP_CMAC ns2__H264Profile_ : public xsd__anyType
{
public:
	enum ns2__H264Profile __item;
public:
	virtual int soap_type() const { return 773; } /* = unique type id SOAP_TYPE_ns2__H264Profile_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__H264Profile_() { ns2__H264Profile_::soap_default(NULL); }
	virtual ~ns2__H264Profile_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioEncoding_
#define SOAP_TYPE_ns2__AudioEncoding_ (775)
/* Primitive ns2:AudioEncoding schema type: */
class SOAP_CMAC ns2__AudioEncoding_ : public xsd__anyType
{
public:
	enum ns2__AudioEncoding __item;
public:
	virtual int soap_type() const { return 775; } /* = unique type id SOAP_TYPE_ns2__AudioEncoding_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioEncoding_() { ns2__AudioEncoding_::soap_default(NULL); }
	virtual ~ns2__AudioEncoding_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataCompressionType_
#define SOAP_TYPE_ns2__MetadataCompressionType_ (777)
/* Primitive ns2:MetadataCompressionType schema type: */
class SOAP_CMAC ns2__MetadataCompressionType_ : public xsd__anyType
{
public:
	enum ns2__MetadataCompressionType __item;
public:
	virtual int soap_type() const { return 777; } /* = unique type id SOAP_TYPE_ns2__MetadataCompressionType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataCompressionType_() { ns2__MetadataCompressionType_::soap_default(NULL); }
	virtual ~ns2__MetadataCompressionType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__StreamType_
#define SOAP_TYPE_ns2__StreamType_ (779)
/* Primitive ns2:StreamType schema type: */
class SOAP_CMAC ns2__StreamType_ : public xsd__anyType
{
public:
	enum ns2__StreamType __item;
public:
	virtual int soap_type() const { return 779; } /* = unique type id SOAP_TYPE_ns2__StreamType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__StreamType_() { ns2__StreamType_::soap_default(NULL); }
	virtual ~ns2__StreamType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TransportProtocol_
#define SOAP_TYPE_ns2__TransportProtocol_ (781)
/* Primitive ns2:TransportProtocol schema type: */
class SOAP_CMAC ns2__TransportProtocol_ : public xsd__anyType
{
public:
	enum ns2__TransportProtocol __item;
public:
	virtual int soap_type() const { return 781; } /* = unique type id SOAP_TYPE_ns2__TransportProtocol_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TransportProtocol_() { ns2__TransportProtocol_::soap_default(NULL); }
	virtual ~ns2__TransportProtocol_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ScopeDefinition_
#define SOAP_TYPE_ns2__ScopeDefinition_ (783)
/* Primitive ns2:ScopeDefinition schema type: */
class SOAP_CMAC ns2__ScopeDefinition_ : public xsd__anyType
{
public:
	enum ns2__ScopeDefinition __item;
public:
	virtual int soap_type() const { return 783; } /* = unique type id SOAP_TYPE_ns2__ScopeDefinition_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ScopeDefinition_() { ns2__ScopeDefinition_::soap_default(NULL); }
	virtual ~ns2__ScopeDefinition_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DiscoveryMode_
#define SOAP_TYPE_ns2__DiscoveryMode_ (785)
/* Primitive ns2:DiscoveryMode schema type: */
class SOAP_CMAC ns2__DiscoveryMode_ : public xsd__anyType
{
public:
	enum ns2__DiscoveryMode __item;
public:
	virtual int soap_type() const { return 785; } /* = unique type id SOAP_TYPE_ns2__DiscoveryMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DiscoveryMode_() { ns2__DiscoveryMode_::soap_default(NULL); }
	virtual ~ns2__DiscoveryMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceConfigPriority__
#define SOAP_TYPE_ns2__NetworkInterfaceConfigPriority__ (787)
/* Primitive ns2:NetworkInterfaceConfigPriority schema type: */
class SOAP_CMAC ns2__NetworkInterfaceConfigPriority__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 787; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceConfigPriority__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceConfigPriority__() { ns2__NetworkInterfaceConfigPriority__::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceConfigPriority__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Duplex_
#define SOAP_TYPE_ns2__Duplex_ (789)
/* Primitive ns2:Duplex schema type: */
class SOAP_CMAC ns2__Duplex_ : public xsd__anyType
{
public:
	enum ns2__Duplex __item;
public:
	virtual int soap_type() const { return 789; } /* = unique type id SOAP_TYPE_ns2__Duplex_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Duplex_() { ns2__Duplex_::soap_default(NULL); }
	virtual ~ns2__Duplex_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IANA_IfTypes__
#define SOAP_TYPE_ns2__IANA_IfTypes__ (791)
/* Primitive ns2:IANA-IfTypes schema type: */
class SOAP_CMAC ns2__IANA_IfTypes__ : public xsd__anyType
{
public:
	int __item;
public:
	virtual int soap_type() const { return 791; } /* = unique type id SOAP_TYPE_ns2__IANA_IfTypes__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IANA_IfTypes__() { ns2__IANA_IfTypes__::soap_default(NULL); }
	virtual ~ns2__IANA_IfTypes__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv6DHCPConfiguration_
#define SOAP_TYPE_ns2__IPv6DHCPConfiguration_ (793)
/* Primitive ns2:IPv6DHCPConfiguration schema type: */
class SOAP_CMAC ns2__IPv6DHCPConfiguration_ : public xsd__anyType
{
public:
	enum ns2__IPv6DHCPConfiguration __item;
public:
	virtual int soap_type() const { return 793; } /* = unique type id SOAP_TYPE_ns2__IPv6DHCPConfiguration_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv6DHCPConfiguration_() { ns2__IPv6DHCPConfiguration_::soap_default(NULL); }
	virtual ~ns2__IPv6DHCPConfiguration_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkProtocolType_
#define SOAP_TYPE_ns2__NetworkProtocolType_ (795)
/* Primitive ns2:NetworkProtocolType schema type: */
class SOAP_CMAC ns2__NetworkProtocolType_ : public xsd__anyType
{
public:
	enum ns2__NetworkProtocolType __item;
public:
	virtual int soap_type() const { return 795; } /* = unique type id SOAP_TYPE_ns2__NetworkProtocolType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkProtocolType_() { ns2__NetworkProtocolType_::soap_default(NULL); }
	virtual ~ns2__NetworkProtocolType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkHostType_
#define SOAP_TYPE_ns2__NetworkHostType_ (797)
/* Primitive ns2:NetworkHostType schema type: */
class SOAP_CMAC ns2__NetworkHostType_ : public xsd__anyType
{
public:
	enum ns2__NetworkHostType __item;
public:
	virtual int soap_type() const { return 797; } /* = unique type id SOAP_TYPE_ns2__NetworkHostType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkHostType_() { ns2__NetworkHostType_::soap_default(NULL); }
	virtual ~ns2__NetworkHostType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv4Address__
#define SOAP_TYPE_ns2__IPv4Address__ (799)
/* Primitive ns2:IPv4Address schema type: */
class SOAP_CMAC ns2__IPv4Address__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 799; } /* = unique type id SOAP_TYPE_ns2__IPv4Address__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv4Address__() { ns2__IPv4Address__::soap_default(NULL); }
	virtual ~ns2__IPv4Address__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv6Address__
#define SOAP_TYPE_ns2__IPv6Address__ (801)
/* Primitive ns2:IPv6Address schema type: */
class SOAP_CMAC ns2__IPv6Address__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 801; } /* = unique type id SOAP_TYPE_ns2__IPv6Address__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv6Address__() { ns2__IPv6Address__::soap_default(NULL); }
	virtual ~ns2__IPv6Address__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HwAddress__
#define SOAP_TYPE_ns2__HwAddress__ (803)
/* Primitive ns2:HwAddress schema type: */
class SOAP_CMAC ns2__HwAddress__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 803; } /* = unique type id SOAP_TYPE_ns2__HwAddress__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HwAddress__() { ns2__HwAddress__::soap_default(NULL); }
	virtual ~ns2__HwAddress__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPType_
#define SOAP_TYPE_ns2__IPType_ (805)
/* Primitive ns2:IPType schema type: */
class SOAP_CMAC ns2__IPType_ : public xsd__anyType
{
public:
	enum ns2__IPType __item;
public:
	virtual int soap_type() const { return 805; } /* = unique type id SOAP_TYPE_ns2__IPType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPType_() { ns2__IPType_::soap_default(NULL); }
	virtual ~ns2__IPType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DNSName__
#define SOAP_TYPE_ns2__DNSName__ (807)
/* Primitive ns2:DNSName schema type: */
class SOAP_CMAC ns2__DNSName__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 807; } /* = unique type id SOAP_TYPE_ns2__DNSName__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DNSName__() { ns2__DNSName__::soap_default(NULL); }
	virtual ~ns2__DNSName__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Domain__
#define SOAP_TYPE_ns2__Domain__ (809)
/* Primitive ns2:Domain schema type: */
class SOAP_CMAC ns2__Domain__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 809; } /* = unique type id SOAP_TYPE_ns2__Domain__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Domain__() { ns2__Domain__::soap_default(NULL); }
	virtual ~ns2__Domain__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPAddressFilterType_
#define SOAP_TYPE_ns2__IPAddressFilterType_ (811)
/* Primitive ns2:IPAddressFilterType schema type: */
class SOAP_CMAC ns2__IPAddressFilterType_ : public xsd__anyType
{
public:
	enum ns2__IPAddressFilterType __item;
public:
	virtual int soap_type() const { return 811; } /* = unique type id SOAP_TYPE_ns2__IPAddressFilterType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPAddressFilterType_() { ns2__IPAddressFilterType_::soap_default(NULL); }
	virtual ~ns2__IPAddressFilterType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DynamicDNSType_
#define SOAP_TYPE_ns2__DynamicDNSType_ (813)
/* Primitive ns2:DynamicDNSType schema type: */
class SOAP_CMAC ns2__DynamicDNSType_ : public xsd__anyType
{
public:
	enum ns2__DynamicDNSType __item;
public:
	virtual int soap_type() const { return 813; } /* = unique type id SOAP_TYPE_ns2__DynamicDNSType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DynamicDNSType_() { ns2__DynamicDNSType_::soap_default(NULL); }
	virtual ~ns2__DynamicDNSType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11SSIDType__
#define SOAP_TYPE_ns2__Dot11SSIDType__ (815)
/* Primitive ns2:Dot11SSIDType schema type: */
class SOAP_CMAC ns2__Dot11SSIDType__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;
public:
	virtual int soap_type() const { return 815; } /* = unique type id SOAP_TYPE_ns2__Dot11SSIDType__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11SSIDType__() { ns2__Dot11SSIDType__::soap_default(NULL); }
	virtual ~ns2__Dot11SSIDType__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11StationMode_
#define SOAP_TYPE_ns2__Dot11StationMode_ (817)
/* Primitive ns2:Dot11StationMode schema type: */
class SOAP_CMAC ns2__Dot11StationMode_ : public xsd__anyType
{
public:
	enum ns2__Dot11StationMode __item;
public:
	virtual int soap_type() const { return 817; } /* = unique type id SOAP_TYPE_ns2__Dot11StationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11StationMode_() { ns2__Dot11StationMode_::soap_default(NULL); }
	virtual ~ns2__Dot11StationMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11SecurityMode_
#define SOAP_TYPE_ns2__Dot11SecurityMode_ (819)
/* Primitive ns2:Dot11SecurityMode schema type: */
class SOAP_CMAC ns2__Dot11SecurityMode_ : public xsd__anyType
{
public:
	enum ns2__Dot11SecurityMode __item;
public:
	virtual int soap_type() const { return 819; } /* = unique type id SOAP_TYPE_ns2__Dot11SecurityMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11SecurityMode_() { ns2__Dot11SecurityMode_::soap_default(NULL); }
	virtual ~ns2__Dot11SecurityMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11Cipher_
#define SOAP_TYPE_ns2__Dot11Cipher_ (821)
/* Primitive ns2:Dot11Cipher schema type: */
class SOAP_CMAC ns2__Dot11Cipher_ : public xsd__anyType
{
public:
	enum ns2__Dot11Cipher __item;
public:
	virtual int soap_type() const { return 821; } /* = unique type id SOAP_TYPE_ns2__Dot11Cipher_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11Cipher_() { ns2__Dot11Cipher_::soap_default(NULL); }
	virtual ~ns2__Dot11Cipher_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11PSK__
#define SOAP_TYPE_ns2__Dot11PSK__ (823)
/* Primitive ns2:Dot11PSK schema type: */
class SOAP_CMAC ns2__Dot11PSK__ : public xsd__anyType
{
public:
	xsd__hexBinary __item;
public:
	virtual int soap_type() const { return 823; } /* = unique type id SOAP_TYPE_ns2__Dot11PSK__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11PSK__() { ns2__Dot11PSK__::soap_default(NULL); }
	virtual ~ns2__Dot11PSK__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11PSKPassphrase__
#define SOAP_TYPE_ns2__Dot11PSKPassphrase__ (825)
/* Primitive ns2:Dot11PSKPassphrase schema type: */
class SOAP_CMAC ns2__Dot11PSKPassphrase__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 825; } /* = unique type id SOAP_TYPE_ns2__Dot11PSKPassphrase__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11PSKPassphrase__() { ns2__Dot11PSKPassphrase__::soap_default(NULL); }
	virtual ~ns2__Dot11PSKPassphrase__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11SignalStrength_
#define SOAP_TYPE_ns2__Dot11SignalStrength_ (827)
/* Primitive ns2:Dot11SignalStrength schema type: */
class SOAP_CMAC ns2__Dot11SignalStrength_ : public xsd__anyType
{
public:
	enum ns2__Dot11SignalStrength __item;
public:
	virtual int soap_type() const { return 827; } /* = unique type id SOAP_TYPE_ns2__Dot11SignalStrength_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11SignalStrength_() { ns2__Dot11SignalStrength_::soap_default(NULL); }
	virtual ~ns2__Dot11SignalStrength_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11AuthAndMangementSuite_
#define SOAP_TYPE_ns2__Dot11AuthAndMangementSuite_ (829)
/* Primitive ns2:Dot11AuthAndMangementSuite schema type: */
class SOAP_CMAC ns2__Dot11AuthAndMangementSuite_ : public xsd__anyType
{
public:
	enum ns2__Dot11AuthAndMangementSuite __item;
public:
	virtual int soap_type() const { return 829; } /* = unique type id SOAP_TYPE_ns2__Dot11AuthAndMangementSuite_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11AuthAndMangementSuite_() { ns2__Dot11AuthAndMangementSuite_::soap_default(NULL); }
	virtual ~ns2__Dot11AuthAndMangementSuite_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CapabilityCategory_
#define SOAP_TYPE_ns2__CapabilityCategory_ (831)
/* Primitive ns2:CapabilityCategory schema type: */
class SOAP_CMAC ns2__CapabilityCategory_ : public xsd__anyType
{
public:
	enum ns2__CapabilityCategory __item;
public:
	virtual int soap_type() const { return 831; } /* = unique type id SOAP_TYPE_ns2__CapabilityCategory_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CapabilityCategory_() { ns2__CapabilityCategory_::soap_default(NULL); }
	virtual ~ns2__CapabilityCategory_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemLogType_
#define SOAP_TYPE_ns2__SystemLogType_ (833)
/* Primitive ns2:SystemLogType schema type: */
class SOAP_CMAC ns2__SystemLogType_ : public xsd__anyType
{
public:
	enum ns2__SystemLogType __item;
public:
	virtual int soap_type() const { return 833; } /* = unique type id SOAP_TYPE_ns2__SystemLogType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemLogType_() { ns2__SystemLogType_::soap_default(NULL); }
	virtual ~ns2__SystemLogType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FactoryDefaultType_
#define SOAP_TYPE_ns2__FactoryDefaultType_ (835)
/* Primitive ns2:FactoryDefaultType schema type: */
class SOAP_CMAC ns2__FactoryDefaultType_ : public xsd__anyType
{
public:
	enum ns2__FactoryDefaultType __item;
public:
	virtual int soap_type() const { return 835; } /* = unique type id SOAP_TYPE_ns2__FactoryDefaultType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FactoryDefaultType_() { ns2__FactoryDefaultType_::soap_default(NULL); }
	virtual ~ns2__FactoryDefaultType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SetDateTimeType_
#define SOAP_TYPE_ns2__SetDateTimeType_ (837)
/* Primitive ns2:SetDateTimeType schema type: */
class SOAP_CMAC ns2__SetDateTimeType_ : public xsd__anyType
{
public:
	enum ns2__SetDateTimeType __item;
public:
	virtual int soap_type() const { return 837; } /* = unique type id SOAP_TYPE_ns2__SetDateTimeType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SetDateTimeType_() { ns2__SetDateTimeType_::soap_default(NULL); }
	virtual ~ns2__SetDateTimeType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__UserLevel_
#define SOAP_TYPE_ns2__UserLevel_ (839)
/* Primitive ns2:UserLevel schema type: */
class SOAP_CMAC ns2__UserLevel_ : public xsd__anyType
{
public:
	enum ns2__UserLevel __item;
public:
	virtual int soap_type() const { return 839; } /* = unique type id SOAP_TYPE_ns2__UserLevel_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__UserLevel_() { ns2__UserLevel_::soap_default(NULL); }
	virtual ~ns2__UserLevel_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelayLogicalState_
#define SOAP_TYPE_ns2__RelayLogicalState_ (841)
/* Primitive ns2:RelayLogicalState schema type: */
class SOAP_CMAC ns2__RelayLogicalState_ : public xsd__anyType
{
public:
	enum ns2__RelayLogicalState __item;
public:
	virtual int soap_type() const { return 841; } /* = unique type id SOAP_TYPE_ns2__RelayLogicalState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelayLogicalState_() { ns2__RelayLogicalState_::soap_default(NULL); }
	virtual ~ns2__RelayLogicalState_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelayIdleState_
#define SOAP_TYPE_ns2__RelayIdleState_ (843)
/* Primitive ns2:RelayIdleState schema type: */
class SOAP_CMAC ns2__RelayIdleState_ : public xsd__anyType
{
public:
	enum ns2__RelayIdleState __item;
public:
	virtual int soap_type() const { return 843; } /* = unique type id SOAP_TYPE_ns2__RelayIdleState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelayIdleState_() { ns2__RelayIdleState_::soap_default(NULL); }
	virtual ~ns2__RelayIdleState_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelayMode_
#define SOAP_TYPE_ns2__RelayMode_ (845)
/* Primitive ns2:RelayMode schema type: */
class SOAP_CMAC ns2__RelayMode_ : public xsd__anyType
{
public:
	enum ns2__RelayMode __item;
public:
	virtual int soap_type() const { return 845; } /* = unique type id SOAP_TYPE_ns2__RelayMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelayMode_() { ns2__RelayMode_::soap_default(NULL); }
	virtual ~ns2__RelayMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EFlipMode_
#define SOAP_TYPE_ns2__EFlipMode_ (847)
/* Primitive ns2:EFlipMode schema type: */
class SOAP_CMAC ns2__EFlipMode_ : public xsd__anyType
{
public:
	enum ns2__EFlipMode __item;
public:
	virtual int soap_type() const { return 847; } /* = unique type id SOAP_TYPE_ns2__EFlipMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EFlipMode_() { ns2__EFlipMode_::soap_default(NULL); }
	virtual ~ns2__EFlipMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReverseMode_
#define SOAP_TYPE_ns2__ReverseMode_ (849)
/* Primitive ns2:ReverseMode schema type: */
class SOAP_CMAC ns2__ReverseMode_ : public xsd__anyType
{
public:
	enum ns2__ReverseMode __item;
public:
	virtual int soap_type() const { return 849; } /* = unique type id SOAP_TYPE_ns2__ReverseMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReverseMode_() { ns2__ReverseMode_::soap_default(NULL); }
	virtual ~ns2__ReverseMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AuxiliaryData__
#define SOAP_TYPE_ns2__AuxiliaryData__ (851)
/* Primitive ns2:AuxiliaryData schema type: */
class SOAP_CMAC ns2__AuxiliaryData__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 851; } /* = unique type id SOAP_TYPE_ns2__AuxiliaryData__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AuxiliaryData__() { ns2__AuxiliaryData__::soap_default(NULL); }
	virtual ~ns2__AuxiliaryData__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MoveStatus_
#define SOAP_TYPE_ns2__MoveStatus_ (853)
/* Primitive ns2:MoveStatus schema type: */
class SOAP_CMAC ns2__MoveStatus_ : public xsd__anyType
{
public:
	enum ns2__MoveStatus __item;
public:
	virtual int soap_type() const { return 853; } /* = unique type id SOAP_TYPE_ns2__MoveStatus_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MoveStatus_() { ns2__MoveStatus_::soap_default(NULL); }
	virtual ~ns2__MoveStatus_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourState_
#define SOAP_TYPE_ns2__PTZPresetTourState_ (855)
/* Primitive ns2:PTZPresetTourState schema type: */
class SOAP_CMAC ns2__PTZPresetTourState_ : public xsd__anyType
{
public:
	enum ns2__PTZPresetTourState __item;
public:
	virtual int soap_type() const { return 855; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourState_() { ns2__PTZPresetTourState_::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourState_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourDirection_
#define SOAP_TYPE_ns2__PTZPresetTourDirection_ (857)
/* Primitive ns2:PTZPresetTourDirection schema type: */
class SOAP_CMAC ns2__PTZPresetTourDirection_ : public xsd__anyType
{
public:
	enum ns2__PTZPresetTourDirection __item;
public:
	virtual int soap_type() const { return 857; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourDirection_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourDirection_() { ns2__PTZPresetTourDirection_::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourDirection_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourOperation_
#define SOAP_TYPE_ns2__PTZPresetTourOperation_ (859)
/* Primitive ns2:PTZPresetTourOperation schema type: */
class SOAP_CMAC ns2__PTZPresetTourOperation_ : public xsd__anyType
{
public:
	enum ns2__PTZPresetTourOperation __item;
public:
	virtual int soap_type() const { return 859; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourOperation_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourOperation_() { ns2__PTZPresetTourOperation_::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourOperation_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AutoFocusMode_
#define SOAP_TYPE_ns2__AutoFocusMode_ (861)
/* Primitive ns2:AutoFocusMode schema type: */
class SOAP_CMAC ns2__AutoFocusMode_ : public xsd__anyType
{
public:
	enum ns2__AutoFocusMode __item;
public:
	virtual int soap_type() const { return 861; } /* = unique type id SOAP_TYPE_ns2__AutoFocusMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AutoFocusMode_() { ns2__AutoFocusMode_::soap_default(NULL); }
	virtual ~ns2__AutoFocusMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WideDynamicMode_
#define SOAP_TYPE_ns2__WideDynamicMode_ (863)
/* Primitive ns2:WideDynamicMode schema type: */
class SOAP_CMAC ns2__WideDynamicMode_ : public xsd__anyType
{
public:
	enum ns2__WideDynamicMode __item;
public:
	virtual int soap_type() const { return 863; } /* = unique type id SOAP_TYPE_ns2__WideDynamicMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WideDynamicMode_() { ns2__WideDynamicMode_::soap_default(NULL); }
	virtual ~ns2__WideDynamicMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BacklightCompensationMode_
#define SOAP_TYPE_ns2__BacklightCompensationMode_ (865)
/* Primitive ns2:BacklightCompensationMode schema type: */
class SOAP_CMAC ns2__BacklightCompensationMode_ : public xsd__anyType
{
public:
	enum ns2__BacklightCompensationMode __item;
public:
	virtual int soap_type() const { return 865; } /* = unique type id SOAP_TYPE_ns2__BacklightCompensationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BacklightCompensationMode_() { ns2__BacklightCompensationMode_::soap_default(NULL); }
	virtual ~ns2__BacklightCompensationMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ExposurePriority_
#define SOAP_TYPE_ns2__ExposurePriority_ (867)
/* Primitive ns2:ExposurePriority schema type: */
class SOAP_CMAC ns2__ExposurePriority_ : public xsd__anyType
{
public:
	enum ns2__ExposurePriority __item;
public:
	virtual int soap_type() const { return 867; } /* = unique type id SOAP_TYPE_ns2__ExposurePriority_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ExposurePriority_() { ns2__ExposurePriority_::soap_default(NULL); }
	virtual ~ns2__ExposurePriority_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ExposureMode_
#define SOAP_TYPE_ns2__ExposureMode_ (869)
/* Primitive ns2:ExposureMode schema type: */
class SOAP_CMAC ns2__ExposureMode_ : public xsd__anyType
{
public:
	enum ns2__ExposureMode __item;
public:
	virtual int soap_type() const { return 869; } /* = unique type id SOAP_TYPE_ns2__ExposureMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ExposureMode_() { ns2__ExposureMode_::soap_default(NULL); }
	virtual ~ns2__ExposureMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Enabled_
#define SOAP_TYPE_ns2__Enabled_ (871)
/* Primitive ns2:Enabled schema type: */
class SOAP_CMAC ns2__Enabled_ : public xsd__anyType
{
public:
	enum ns2__Enabled __item;
public:
	virtual int soap_type() const { return 871; } /* = unique type id SOAP_TYPE_ns2__Enabled_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Enabled_() { ns2__Enabled_::soap_default(NULL); }
	virtual ~ns2__Enabled_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalanceMode_
#define SOAP_TYPE_ns2__WhiteBalanceMode_ (873)
/* Primitive ns2:WhiteBalanceMode schema type: */
class SOAP_CMAC ns2__WhiteBalanceMode_ : public xsd__anyType
{
public:
	enum ns2__WhiteBalanceMode __item;
public:
	virtual int soap_type() const { return 873; } /* = unique type id SOAP_TYPE_ns2__WhiteBalanceMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WhiteBalanceMode_() { ns2__WhiteBalanceMode_::soap_default(NULL); }
	virtual ~ns2__WhiteBalanceMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterMode_
#define SOAP_TYPE_ns2__IrCutFilterMode_ (875)
/* Primitive ns2:IrCutFilterMode schema type: */
class SOAP_CMAC ns2__IrCutFilterMode_ : public xsd__anyType
{
public:
	enum ns2__IrCutFilterMode __item;
public:
	virtual int soap_type() const { return 875; } /* = unique type id SOAP_TYPE_ns2__IrCutFilterMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IrCutFilterMode_() { ns2__IrCutFilterMode_::soap_default(NULL); }
	virtual ~ns2__IrCutFilterMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImageStabilizationMode_
#define SOAP_TYPE_ns2__ImageStabilizationMode_ (877)
/* Primitive ns2:ImageStabilizationMode schema type: */
class SOAP_CMAC ns2__ImageStabilizationMode_ : public xsd__anyType
{
public:
	enum ns2__ImageStabilizationMode __item;
public:
	virtual int soap_type() const { return 877; } /* = unique type id SOAP_TYPE_ns2__ImageStabilizationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImageStabilizationMode_() { ns2__ImageStabilizationMode_::soap_default(NULL); }
	virtual ~ns2__ImageStabilizationMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType_
#define SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType_ (879)
/* Primitive ns2:IrCutFilterAutoBoundaryType schema type: */
class SOAP_CMAC ns2__IrCutFilterAutoBoundaryType_ : public xsd__anyType
{
public:
	enum ns2__IrCutFilterAutoBoundaryType __item;
public:
	virtual int soap_type() const { return 879; } /* = unique type id SOAP_TYPE_ns2__IrCutFilterAutoBoundaryType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IrCutFilterAutoBoundaryType_() { ns2__IrCutFilterAutoBoundaryType_::soap_default(NULL); }
	virtual ~ns2__IrCutFilterAutoBoundaryType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ToneCompensationMode_
#define SOAP_TYPE_ns2__ToneCompensationMode_ (881)
/* Primitive ns2:ToneCompensationMode schema type: */
class SOAP_CMAC ns2__ToneCompensationMode_ : public xsd__anyType
{
public:
	enum ns2__ToneCompensationMode __item;
public:
	virtual int soap_type() const { return 881; } /* = unique type id SOAP_TYPE_ns2__ToneCompensationMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ToneCompensationMode_() { ns2__ToneCompensationMode_::soap_default(NULL); }
	virtual ~ns2__ToneCompensationMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DefoggingMode_
#define SOAP_TYPE_ns2__DefoggingMode_ (883)
/* Primitive ns2:DefoggingMode schema type: */
class SOAP_CMAC ns2__DefoggingMode_ : public xsd__anyType
{
public:
	enum ns2__DefoggingMode __item;
public:
	virtual int soap_type() const { return 883; } /* = unique type id SOAP_TYPE_ns2__DefoggingMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DefoggingMode_() { ns2__DefoggingMode_::soap_default(NULL); }
	virtual ~ns2__DefoggingMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TopicNamespaceLocation__
#define SOAP_TYPE_ns2__TopicNamespaceLocation__ (885)
/* Primitive ns2:TopicNamespaceLocation schema type: */
class SOAP_CMAC ns2__TopicNamespaceLocation__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 885; } /* = unique type id SOAP_TYPE_ns2__TopicNamespaceLocation__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TopicNamespaceLocation__() { ns2__TopicNamespaceLocation__::soap_default(NULL); }
	virtual ~ns2__TopicNamespaceLocation__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PropertyOperation_
#define SOAP_TYPE_ns2__PropertyOperation_ (887)
/* Primitive ns2:PropertyOperation schema type: */
class SOAP_CMAC ns2__PropertyOperation_ : public xsd__anyType
{
public:
	enum ns2__PropertyOperation __item;
public:
	virtual int soap_type() const { return 887; } /* = unique type id SOAP_TYPE_ns2__PropertyOperation_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PropertyOperation_() { ns2__PropertyOperation_::soap_default(NULL); }
	virtual ~ns2__PropertyOperation_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Direction_
#define SOAP_TYPE_ns2__Direction_ (889)
/* Primitive ns2:Direction schema type: */
class SOAP_CMAC ns2__Direction_ : public xsd__anyType
{
public:
	enum ns2__Direction __item;
public:
	virtual int soap_type() const { return 889; } /* = unique type id SOAP_TYPE_ns2__Direction_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Direction_() { ns2__Direction_::soap_default(NULL); }
	virtual ~ns2__Direction_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ClassType_
#define SOAP_TYPE_ns2__ClassType_ (891)
/* Primitive ns2:ClassType schema type: */
class SOAP_CMAC ns2__ClassType_ : public xsd__anyType
{
public:
	enum ns2__ClassType __item;
public:
	virtual int soap_type() const { return 891; } /* = unique type id SOAP_TYPE_ns2__ClassType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ClassType_() { ns2__ClassType_::soap_default(NULL); }
	virtual ~ns2__ClassType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReceiverMode_
#define SOAP_TYPE_ns2__ReceiverMode_ (893)
/* Primitive ns2:ReceiverMode schema type: */
class SOAP_CMAC ns2__ReceiverMode_ : public xsd__anyType
{
public:
	enum ns2__ReceiverMode __item;
public:
	virtual int soap_type() const { return 893; } /* = unique type id SOAP_TYPE_ns2__ReceiverMode_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReceiverMode_() { ns2__ReceiverMode_::soap_default(NULL); }
	virtual ~ns2__ReceiverMode_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReceiverState_
#define SOAP_TYPE_ns2__ReceiverState_ (895)
/* Primitive ns2:ReceiverState schema type: */
class SOAP_CMAC ns2__ReceiverState_ : public xsd__anyType
{
public:
	enum ns2__ReceiverState __item;
public:
	virtual int soap_type() const { return 895; } /* = unique type id SOAP_TYPE_ns2__ReceiverState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReceiverState_() { ns2__ReceiverState_::soap_default(NULL); }
	virtual ~ns2__ReceiverState_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Description__
#define SOAP_TYPE_ns2__Description__ (897)
/* Primitive ns2:Description schema type: */
class SOAP_CMAC ns2__Description__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 897; } /* = unique type id SOAP_TYPE_ns2__Description__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Description__() { ns2__Description__::soap_default(NULL); }
	virtual ~ns2__Description__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__XPathExpression__
#define SOAP_TYPE_ns2__XPathExpression__ (899)
/* Primitive ns2:XPathExpression schema type: */
class SOAP_CMAC ns2__XPathExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 899; } /* = unique type id SOAP_TYPE_ns2__XPathExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__XPathExpression__() { ns2__XPathExpression__::soap_default(NULL); }
	virtual ~ns2__XPathExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SearchState_
#define SOAP_TYPE_ns2__SearchState_ (901)
/* Primitive ns2:SearchState schema type: */
class SOAP_CMAC ns2__SearchState_ : public xsd__anyType
{
public:
	enum ns2__SearchState __item;
public:
	virtual int soap_type() const { return 901; } /* = unique type id SOAP_TYPE_ns2__SearchState_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SearchState_() { ns2__SearchState_::soap_default(NULL); }
	virtual ~ns2__SearchState_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingStatus_
#define SOAP_TYPE_ns2__RecordingStatus_ (903)
/* Primitive ns2:RecordingStatus schema type: */
class SOAP_CMAC ns2__RecordingStatus_ : public xsd__anyType
{
public:
	enum ns2__RecordingStatus __item;
public:
	virtual int soap_type() const { return 903; } /* = unique type id SOAP_TYPE_ns2__RecordingStatus_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingStatus_() { ns2__RecordingStatus_::soap_default(NULL); }
	virtual ~ns2__RecordingStatus_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TrackType_
#define SOAP_TYPE_ns2__TrackType_ (905)
/* Primitive ns2:TrackType schema type: */
class SOAP_CMAC ns2__TrackType_ : public xsd__anyType
{
public:
	enum ns2__TrackType __item;
public:
	virtual int soap_type() const { return 905; } /* = unique type id SOAP_TYPE_ns2__TrackType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TrackType_() { ns2__TrackType_::soap_default(NULL); }
	virtual ~ns2__TrackType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobMode__
#define SOAP_TYPE_ns2__RecordingJobMode__ (907)
/* Primitive ns2:RecordingJobMode schema type: */
class SOAP_CMAC ns2__RecordingJobMode__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 907; } /* = unique type id SOAP_TYPE_ns2__RecordingJobMode__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobMode__() { ns2__RecordingJobMode__::soap_default(NULL); }
	virtual ~ns2__RecordingJobMode__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobState__
#define SOAP_TYPE_ns2__RecordingJobState__ (909)
/* Primitive ns2:RecordingJobState schema type: */
class SOAP_CMAC ns2__RecordingJobState__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 909; } /* = unique type id SOAP_TYPE_ns2__RecordingJobState__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobState__() { ns2__RecordingJobState__::soap_default(NULL); }
	virtual ~ns2__RecordingJobState__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ModeOfOperation_
#define SOAP_TYPE_ns2__ModeOfOperation_ (911)
/* Primitive ns2:ModeOfOperation schema type: */
class SOAP_CMAC ns2__ModeOfOperation_ : public xsd__anyType
{
public:
	enum ns2__ModeOfOperation __item;
public:
	virtual int soap_type() const { return 911; } /* = unique type id SOAP_TYPE_ns2__ModeOfOperation_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ModeOfOperation_() { ns2__ModeOfOperation_::soap_default(NULL); }
	virtual ~ns2__ModeOfOperation_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioClassType__
#define SOAP_TYPE_ns2__AudioClassType__ (913)
/* Primitive ns2:AudioClassType schema type: */
class SOAP_CMAC ns2__AudioClassType__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 913; } /* = unique type id SOAP_TYPE_ns2__AudioClassType__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioClassType__() { ns2__AudioClassType__::soap_default(NULL); }
	virtual ~ns2__AudioClassType__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDType_
#define SOAP_TYPE_ns2__OSDType_ (915)
/* Primitive ns2:OSDType schema type: */
class SOAP_CMAC ns2__OSDType_ : public xsd__anyType
{
public:
	enum ns2__OSDType __item;
public:
	virtual int soap_type() const { return 915; } /* = unique type id SOAP_TYPE_ns2__OSDType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDType_() { ns2__OSDType_::soap_default(NULL); }
	virtual ~ns2__OSDType_() { }
};
#endif

#ifndef SOAP_TYPE_ns6__FullTopicExpression__
#define SOAP_TYPE_ns6__FullTopicExpression__ (917)
/* Primitive ns6:FullTopicExpression schema type: */
class SOAP_CMAC ns6__FullTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 917; } /* = unique type id SOAP_TYPE_ns6__FullTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__FullTopicExpression__() { ns6__FullTopicExpression__::soap_default(NULL); }
	virtual ~ns6__FullTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ConcreteTopicExpression__
#define SOAP_TYPE_ns6__ConcreteTopicExpression__ (919)
/* Primitive ns6:ConcreteTopicExpression schema type: */
class SOAP_CMAC ns6__ConcreteTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 919; } /* = unique type id SOAP_TYPE_ns6__ConcreteTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ConcreteTopicExpression__() { ns6__ConcreteTopicExpression__::soap_default(NULL); }
	virtual ~ns6__ConcreteTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns6__SimpleTopicExpression__
#define SOAP_TYPE_ns6__SimpleTopicExpression__ (921)
/* Primitive ns6:SimpleTopicExpression schema type: */
class SOAP_CMAC ns6__SimpleTopicExpression__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 921; } /* = unique type id SOAP_TYPE_ns6__SimpleTopicExpression__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__SimpleTopicExpression__() { ns6__SimpleTopicExpression__::soap_default(NULL); }
	virtual ~ns6__SimpleTopicExpression__() { }
};
#endif

#ifndef SOAP_TYPE_ns7__RelationshipType_
#define SOAP_TYPE_ns7__RelationshipType_ (923)
/* Primitive ns7:RelationshipType schema type: */
class SOAP_CMAC ns7__RelationshipType_ : public xsd__anyType
{
public:
	enum ns7__RelationshipType __item;
public:
	virtual int soap_type() const { return 923; } /* = unique type id SOAP_TYPE_ns7__RelationshipType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__RelationshipType_() { ns7__RelationshipType_::soap_default(NULL); }
	virtual ~ns7__RelationshipType_() { }
};
#endif

#ifndef SOAP_TYPE_ns7__FaultCodesType_
#define SOAP_TYPE_ns7__FaultCodesType_ (925)
/* Primitive ns7:FaultCodesType schema type: */
class SOAP_CMAC ns7__FaultCodesType_ : public xsd__anyType
{
public:
	enum ns7__FaultCodesType __item;
public:
	virtual int soap_type() const { return 925; } /* = unique type id SOAP_TYPE_ns7__FaultCodesType_ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__FaultCodesType_() { ns7__FaultCodesType_::soap_default(NULL); }
	virtual ~ns7__FaultCodesType_() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReceiverReference__
#define SOAP_TYPE_ns2__ReceiverReference__ (927)
/* Primitive ns2:ReceiverReference schema type: */
class SOAP_CMAC ns2__ReceiverReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 927; } /* = unique type id SOAP_TYPE_ns2__ReceiverReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReceiverReference__() { ns2__ReceiverReference__::soap_default(NULL); }
	virtual ~ns2__ReceiverReference__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingReference__
#define SOAP_TYPE_ns2__RecordingReference__ (929)
/* Primitive ns2:RecordingReference schema type: */
class SOAP_CMAC ns2__RecordingReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 929; } /* = unique type id SOAP_TYPE_ns2__RecordingReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingReference__() { ns2__RecordingReference__::soap_default(NULL); }
	virtual ~ns2__RecordingReference__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TrackReference__
#define SOAP_TYPE_ns2__TrackReference__ (931)
/* Primitive ns2:TrackReference schema type: */
class SOAP_CMAC ns2__TrackReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 931; } /* = unique type id SOAP_TYPE_ns2__TrackReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TrackReference__() { ns2__TrackReference__::soap_default(NULL); }
	virtual ~ns2__TrackReference__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__JobToken__
#define SOAP_TYPE_ns2__JobToken__ (933)
/* Primitive ns2:JobToken schema type: */
class SOAP_CMAC ns2__JobToken__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 933; } /* = unique type id SOAP_TYPE_ns2__JobToken__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__JobToken__() { ns2__JobToken__::soap_default(NULL); }
	virtual ~ns2__JobToken__() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobReference__
#define SOAP_TYPE_ns2__RecordingJobReference__ (935)
/* Primitive ns2:RecordingJobReference schema type: */
class SOAP_CMAC ns2__RecordingJobReference__ : public xsd__anyType
{
public:
	std::string __item;
public:
	virtual int soap_type() const { return 935; } /* = unique type id SOAP_TYPE_ns2__RecordingJobReference__ */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobReference__() { ns2__RecordingJobReference__::soap_default(NULL); }
	virtual ~ns2__RecordingJobReference__() { }
};
#endif

#ifndef SOAP_TYPE_ns1__Capabilities
#define SOAP_TYPE_ns1__Capabilities (47)
/* ns1:Capabilities */
class SOAP_CMAC ns1__Capabilities : public xsd__anyType
{
public:
	class ns1__ProfileCapabilities *ProfileCapabilities;	/* required element of type ns1:ProfileCapabilities */
	class ns1__StreamingCapabilities *StreamingCapabilities;	/* required element of type ns1:StreamingCapabilities */
	std::vector<char * >__any;
	bool *SnapshotUri;	/* optional attribute */
	bool *Rotation;	/* optional attribute */
	bool *VideoSourceMode;	/* optional attribute */
	bool *OSD;	/* optional attribute */
	bool *EXICompression;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 47; } /* = unique type id SOAP_TYPE_ns1__Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__Capabilities() { ns1__Capabilities::soap_default(NULL); }
	virtual ~ns1__Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ProfileCapabilities
#define SOAP_TYPE_ns1__ProfileCapabilities (48)
/* ns1:ProfileCapabilities */
class SOAP_CMAC ns1__ProfileCapabilities : public xsd__anyType
{
public:
	std::vector<char * >__any;
	int *MaximumNumberOfProfiles;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 48; } /* = unique type id SOAP_TYPE_ns1__ProfileCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ProfileCapabilities() { ns1__ProfileCapabilities::soap_default(NULL); }
	virtual ~ns1__ProfileCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StreamingCapabilities
#define SOAP_TYPE_ns1__StreamingCapabilities (49)
/* ns1:StreamingCapabilities */
class SOAP_CMAC ns1__StreamingCapabilities : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *RTPMulticast;	/* optional attribute */
	bool *RTP_USCORETCP;	/* optional attribute */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional attribute */
	bool *NonAggregateControl;	/* optional attribute */
	bool *NoRTSPStreaming;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 49; } /* = unique type id SOAP_TYPE_ns1__StreamingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StreamingCapabilities() { ns1__StreamingCapabilities::soap_default(NULL); }
	virtual ~ns1__StreamingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns1__VideoSourceMode
#define SOAP_TYPE_ns1__VideoSourceMode (50)
/* ns1:VideoSourceMode */
class SOAP_CMAC ns1__VideoSourceMode : public xsd__anyType
{
public:
	float MaxFramerate;	/* required element of type xsd:float */
	class ns2__VideoResolution *MaxResolution;	/* required element of type ns2:VideoResolution */
	std::string Encodings;	/* required element of type ns1:EncodingTypes */
	bool Reboot;	/* required element of type xsd:boolean */
	std::string *Description;	/* optional element of type ns2:Description */
	class ns1__VideoSourceModeExtension *Extension;	/* optional element of type ns1:VideoSourceModeExtension */
	std::string token;	/* required attribute */
	bool *Enabled;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 50; } /* = unique type id SOAP_TYPE_ns1__VideoSourceMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__VideoSourceMode() { ns1__VideoSourceMode::soap_default(NULL); }
	virtual ~ns1__VideoSourceMode() { }
};
#endif

#ifndef SOAP_TYPE_ns1__VideoSourceModeExtension
#define SOAP_TYPE_ns1__VideoSourceModeExtension (51)
/* ns1:VideoSourceModeExtension */
class SOAP_CMAC ns1__VideoSourceModeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 51; } /* = unique type id SOAP_TYPE_ns1__VideoSourceModeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__VideoSourceModeExtension() { ns1__VideoSourceModeExtension::soap_default(NULL); }
	virtual ~ns1__VideoSourceModeExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetServiceCapabilities
#define SOAP_TYPE__ns1__GetServiceCapabilities (52)
/* ns1:GetServiceCapabilities */
class SOAP_CMAC _ns1__GetServiceCapabilities
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique type id SOAP_TYPE__ns1__GetServiceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetServiceCapabilities() { _ns1__GetServiceCapabilities::soap_default(NULL); }
	virtual ~_ns1__GetServiceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetServiceCapabilitiesResponse
#define SOAP_TYPE__ns1__GetServiceCapabilitiesResponse (53)
/* ns1:GetServiceCapabilitiesResponse */
class SOAP_CMAC _ns1__GetServiceCapabilitiesResponse
{
public:
	ns1__Capabilities *Capabilities;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:Capabilities */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique type id SOAP_TYPE__ns1__GetServiceCapabilitiesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetServiceCapabilitiesResponse() { _ns1__GetServiceCapabilitiesResponse::soap_default(NULL); }
	virtual ~_ns1__GetServiceCapabilitiesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSources
#define SOAP_TYPE__ns1__GetVideoSources (54)
/* ns1:GetVideoSources */
class SOAP_CMAC _ns1__GetVideoSources
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique type id SOAP_TYPE__ns1__GetVideoSources */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSources() { _ns1__GetVideoSources::soap_default(NULL); }
	virtual ~_ns1__GetVideoSources() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourcesResponse
#define SOAP_TYPE__ns1__GetVideoSourcesResponse (55)
/* ns1:GetVideoSourcesResponse */
class SOAP_CMAC _ns1__GetVideoSourcesResponse
{
public:
	std::vector<class ns2__VideoSource * >VideoSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:VideoSource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourcesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourcesResponse() { _ns1__GetVideoSourcesResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourcesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSources
#define SOAP_TYPE__ns1__GetAudioSources (56)
/* ns1:GetAudioSources */
class SOAP_CMAC _ns1__GetAudioSources
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique type id SOAP_TYPE__ns1__GetAudioSources */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSources() { _ns1__GetAudioSources::soap_default(NULL); }
	virtual ~_ns1__GetAudioSources() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourcesResponse
#define SOAP_TYPE__ns1__GetAudioSourcesResponse (57)
/* ns1:GetAudioSourcesResponse */
class SOAP_CMAC _ns1__GetAudioSourcesResponse
{
public:
	std::vector<class ns2__AudioSource * >AudioSources;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioSource */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourcesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourcesResponse() { _ns1__GetAudioSourcesResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourcesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputs
#define SOAP_TYPE__ns1__GetAudioOutputs (58)
/* ns1:GetAudioOutputs */
class SOAP_CMAC _ns1__GetAudioOutputs
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputs() { _ns1__GetAudioOutputs::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputs() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputsResponse
#define SOAP_TYPE__ns1__GetAudioOutputsResponse (59)
/* ns1:GetAudioOutputsResponse */
class SOAP_CMAC _ns1__GetAudioOutputsResponse
{
public:
	std::vector<class ns2__AudioOutput * >AudioOutputs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioOutput */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputsResponse() { _ns1__GetAudioOutputsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateProfile
#define SOAP_TYPE__ns1__CreateProfile (60)
/* ns1:CreateProfile */
class SOAP_CMAC _ns1__CreateProfile
{
public:
	std::string Name;	/* required element of type ns2:Name */
	std::string *Token;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique type id SOAP_TYPE__ns1__CreateProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateProfile() { _ns1__CreateProfile::soap_default(NULL); }
	virtual ~_ns1__CreateProfile() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateProfileResponse
#define SOAP_TYPE__ns1__CreateProfileResponse (61)
/* ns1:CreateProfileResponse */
class SOAP_CMAC _ns1__CreateProfileResponse
{
public:
	class ns2__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique type id SOAP_TYPE__ns1__CreateProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateProfileResponse() { _ns1__CreateProfileResponse::soap_default(NULL); }
	virtual ~_ns1__CreateProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetProfile
#define SOAP_TYPE__ns1__GetProfile (62)
/* ns1:GetProfile */
class SOAP_CMAC _ns1__GetProfile
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique type id SOAP_TYPE__ns1__GetProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetProfile() { _ns1__GetProfile::soap_default(NULL); }
	virtual ~_ns1__GetProfile() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetProfileResponse
#define SOAP_TYPE__ns1__GetProfileResponse (63)
/* ns1:GetProfileResponse */
class SOAP_CMAC _ns1__GetProfileResponse
{
public:
	ns2__Profile *Profile;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique type id SOAP_TYPE__ns1__GetProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetProfileResponse() { _ns1__GetProfileResponse::soap_default(NULL); }
	virtual ~_ns1__GetProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetProfiles
#define SOAP_TYPE__ns1__GetProfiles (64)
/* ns1:GetProfiles */
class SOAP_CMAC _ns1__GetProfiles
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique type id SOAP_TYPE__ns1__GetProfiles */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetProfiles() { _ns1__GetProfiles::soap_default(NULL); }
	virtual ~_ns1__GetProfiles() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetProfilesResponse
#define SOAP_TYPE__ns1__GetProfilesResponse (65)
/* ns1:GetProfilesResponse */
class SOAP_CMAC _ns1__GetProfilesResponse
{
public:
	std::vector<ns2__Profile * >Profiles;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:Profile */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique type id SOAP_TYPE__ns1__GetProfilesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetProfilesResponse() { _ns1__GetProfilesResponse::soap_default(NULL); }
	virtual ~_ns1__GetProfilesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddVideoEncoderConfiguration
#define SOAP_TYPE__ns1__AddVideoEncoderConfiguration (66)
/* ns1:AddVideoEncoderConfiguration */
class SOAP_CMAC _ns1__AddVideoEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique type id SOAP_TYPE__ns1__AddVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddVideoEncoderConfiguration() { _ns1__AddVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns1__AddVideoEncoderConfigurationResponse (67)
/* ns1:AddVideoEncoderConfigurationResponse */
class SOAP_CMAC _ns1__AddVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique type id SOAP_TYPE__ns1__AddVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddVideoEncoderConfigurationResponse() { _ns1__AddVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveVideoEncoderConfiguration
#define SOAP_TYPE__ns1__RemoveVideoEncoderConfiguration (68)
/* ns1:RemoveVideoEncoderConfiguration */
class SOAP_CMAC _ns1__RemoveVideoEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique type id SOAP_TYPE__ns1__RemoveVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveVideoEncoderConfiguration() { _ns1__RemoveVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns1__RemoveVideoEncoderConfigurationResponse (69)
/* ns1:RemoveVideoEncoderConfigurationResponse */
class SOAP_CMAC _ns1__RemoveVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique type id SOAP_TYPE__ns1__RemoveVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveVideoEncoderConfigurationResponse() { _ns1__RemoveVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddVideoSourceConfiguration
#define SOAP_TYPE__ns1__AddVideoSourceConfiguration (70)
/* ns1:AddVideoSourceConfiguration */
class SOAP_CMAC _ns1__AddVideoSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique type id SOAP_TYPE__ns1__AddVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddVideoSourceConfiguration() { _ns1__AddVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddVideoSourceConfigurationResponse
#define SOAP_TYPE__ns1__AddVideoSourceConfigurationResponse (71)
/* ns1:AddVideoSourceConfigurationResponse */
class SOAP_CMAC _ns1__AddVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique type id SOAP_TYPE__ns1__AddVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddVideoSourceConfigurationResponse() { _ns1__AddVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveVideoSourceConfiguration
#define SOAP_TYPE__ns1__RemoveVideoSourceConfiguration (72)
/* ns1:RemoveVideoSourceConfiguration */
class SOAP_CMAC _ns1__RemoveVideoSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique type id SOAP_TYPE__ns1__RemoveVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveVideoSourceConfiguration() { _ns1__RemoveVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveVideoSourceConfigurationResponse
#define SOAP_TYPE__ns1__RemoveVideoSourceConfigurationResponse (73)
/* ns1:RemoveVideoSourceConfigurationResponse */
class SOAP_CMAC _ns1__RemoveVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique type id SOAP_TYPE__ns1__RemoveVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveVideoSourceConfigurationResponse() { _ns1__RemoveVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioEncoderConfiguration
#define SOAP_TYPE__ns1__AddAudioEncoderConfiguration (74)
/* ns1:AddAudioEncoderConfiguration */
class SOAP_CMAC _ns1__AddAudioEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique type id SOAP_TYPE__ns1__AddAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioEncoderConfiguration() { _ns1__AddAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns1__AddAudioEncoderConfigurationResponse (75)
/* ns1:AddAudioEncoderConfigurationResponse */
class SOAP_CMAC _ns1__AddAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique type id SOAP_TYPE__ns1__AddAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioEncoderConfigurationResponse() { _ns1__AddAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioEncoderConfiguration
#define SOAP_TYPE__ns1__RemoveAudioEncoderConfiguration (76)
/* ns1:RemoveAudioEncoderConfiguration */
class SOAP_CMAC _ns1__RemoveAudioEncoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioEncoderConfiguration() { _ns1__RemoveAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns1__RemoveAudioEncoderConfigurationResponse (77)
/* ns1:RemoveAudioEncoderConfigurationResponse */
class SOAP_CMAC _ns1__RemoveAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioEncoderConfigurationResponse() { _ns1__RemoveAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioSourceConfiguration
#define SOAP_TYPE__ns1__AddAudioSourceConfiguration (78)
/* ns1:AddAudioSourceConfiguration */
class SOAP_CMAC _ns1__AddAudioSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique type id SOAP_TYPE__ns1__AddAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioSourceConfiguration() { _ns1__AddAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioSourceConfigurationResponse
#define SOAP_TYPE__ns1__AddAudioSourceConfigurationResponse (79)
/* ns1:AddAudioSourceConfigurationResponse */
class SOAP_CMAC _ns1__AddAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique type id SOAP_TYPE__ns1__AddAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioSourceConfigurationResponse() { _ns1__AddAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioSourceConfiguration
#define SOAP_TYPE__ns1__RemoveAudioSourceConfiguration (80)
/* ns1:RemoveAudioSourceConfiguration */
class SOAP_CMAC _ns1__RemoveAudioSourceConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioSourceConfiguration() { _ns1__RemoveAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioSourceConfigurationResponse
#define SOAP_TYPE__ns1__RemoveAudioSourceConfigurationResponse (81)
/* ns1:RemoveAudioSourceConfigurationResponse */
class SOAP_CMAC _ns1__RemoveAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioSourceConfigurationResponse() { _ns1__RemoveAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddPTZConfiguration
#define SOAP_TYPE__ns1__AddPTZConfiguration (82)
/* ns1:AddPTZConfiguration */
class SOAP_CMAC _ns1__AddPTZConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique type id SOAP_TYPE__ns1__AddPTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddPTZConfiguration() { _ns1__AddPTZConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddPTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddPTZConfigurationResponse
#define SOAP_TYPE__ns1__AddPTZConfigurationResponse (83)
/* ns1:AddPTZConfigurationResponse */
class SOAP_CMAC _ns1__AddPTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique type id SOAP_TYPE__ns1__AddPTZConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddPTZConfigurationResponse() { _ns1__AddPTZConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddPTZConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemovePTZConfiguration
#define SOAP_TYPE__ns1__RemovePTZConfiguration (84)
/* ns1:RemovePTZConfiguration */
class SOAP_CMAC _ns1__RemovePTZConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique type id SOAP_TYPE__ns1__RemovePTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemovePTZConfiguration() { _ns1__RemovePTZConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemovePTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemovePTZConfigurationResponse
#define SOAP_TYPE__ns1__RemovePTZConfigurationResponse (85)
/* ns1:RemovePTZConfigurationResponse */
class SOAP_CMAC _ns1__RemovePTZConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique type id SOAP_TYPE__ns1__RemovePTZConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemovePTZConfigurationResponse() { _ns1__RemovePTZConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemovePTZConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddVideoAnalyticsConfiguration
#define SOAP_TYPE__ns1__AddVideoAnalyticsConfiguration (86)
/* ns1:AddVideoAnalyticsConfiguration */
class SOAP_CMAC _ns1__AddVideoAnalyticsConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique type id SOAP_TYPE__ns1__AddVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddVideoAnalyticsConfiguration() { _ns1__AddVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns1__AddVideoAnalyticsConfigurationResponse (87)
/* ns1:AddVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _ns1__AddVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique type id SOAP_TYPE__ns1__AddVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddVideoAnalyticsConfigurationResponse() { _ns1__AddVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE__ns1__RemoveVideoAnalyticsConfiguration (88)
/* ns1:RemoveVideoAnalyticsConfiguration */
class SOAP_CMAC _ns1__RemoveVideoAnalyticsConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique type id SOAP_TYPE__ns1__RemoveVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveVideoAnalyticsConfiguration() { _ns1__RemoveVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns1__RemoveVideoAnalyticsConfigurationResponse (89)
/* ns1:RemoveVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _ns1__RemoveVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique type id SOAP_TYPE__ns1__RemoveVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveVideoAnalyticsConfigurationResponse() { _ns1__RemoveVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddMetadataConfiguration
#define SOAP_TYPE__ns1__AddMetadataConfiguration (90)
/* ns1:AddMetadataConfiguration */
class SOAP_CMAC _ns1__AddMetadataConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique type id SOAP_TYPE__ns1__AddMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddMetadataConfiguration() { _ns1__AddMetadataConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddMetadataConfigurationResponse
#define SOAP_TYPE__ns1__AddMetadataConfigurationResponse (91)
/* ns1:AddMetadataConfigurationResponse */
class SOAP_CMAC _ns1__AddMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique type id SOAP_TYPE__ns1__AddMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddMetadataConfigurationResponse() { _ns1__AddMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveMetadataConfiguration
#define SOAP_TYPE__ns1__RemoveMetadataConfiguration (92)
/* ns1:RemoveMetadataConfiguration */
class SOAP_CMAC _ns1__RemoveMetadataConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique type id SOAP_TYPE__ns1__RemoveMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveMetadataConfiguration() { _ns1__RemoveMetadataConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveMetadataConfigurationResponse
#define SOAP_TYPE__ns1__RemoveMetadataConfigurationResponse (93)
/* ns1:RemoveMetadataConfigurationResponse */
class SOAP_CMAC _ns1__RemoveMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique type id SOAP_TYPE__ns1__RemoveMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveMetadataConfigurationResponse() { _ns1__RemoveMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioOutputConfiguration
#define SOAP_TYPE__ns1__AddAudioOutputConfiguration (94)
/* ns1:AddAudioOutputConfiguration */
class SOAP_CMAC _ns1__AddAudioOutputConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique type id SOAP_TYPE__ns1__AddAudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioOutputConfiguration() { _ns1__AddAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddAudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioOutputConfigurationResponse
#define SOAP_TYPE__ns1__AddAudioOutputConfigurationResponse (95)
/* ns1:AddAudioOutputConfigurationResponse */
class SOAP_CMAC _ns1__AddAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique type id SOAP_TYPE__ns1__AddAudioOutputConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioOutputConfigurationResponse() { _ns1__AddAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddAudioOutputConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioOutputConfiguration
#define SOAP_TYPE__ns1__RemoveAudioOutputConfiguration (96)
/* ns1:RemoveAudioOutputConfiguration */
class SOAP_CMAC _ns1__RemoveAudioOutputConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioOutputConfiguration() { _ns1__RemoveAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioOutputConfigurationResponse
#define SOAP_TYPE__ns1__RemoveAudioOutputConfigurationResponse (97)
/* ns1:RemoveAudioOutputConfigurationResponse */
class SOAP_CMAC _ns1__RemoveAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioOutputConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioOutputConfigurationResponse() { _ns1__RemoveAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioOutputConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioDecoderConfiguration
#define SOAP_TYPE__ns1__AddAudioDecoderConfiguration (98)
/* ns1:AddAudioDecoderConfiguration */
class SOAP_CMAC _ns1__AddAudioDecoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique type id SOAP_TYPE__ns1__AddAudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioDecoderConfiguration() { _ns1__AddAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__AddAudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__AddAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns1__AddAudioDecoderConfigurationResponse (99)
/* ns1:AddAudioDecoderConfigurationResponse */
class SOAP_CMAC _ns1__AddAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique type id SOAP_TYPE__ns1__AddAudioDecoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__AddAudioDecoderConfigurationResponse() { _ns1__AddAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__AddAudioDecoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioDecoderConfiguration
#define SOAP_TYPE__ns1__RemoveAudioDecoderConfiguration (100)
/* ns1:RemoveAudioDecoderConfiguration */
class SOAP_CMAC _ns1__RemoveAudioDecoderConfiguration
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioDecoderConfiguration() { _ns1__RemoveAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__RemoveAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns1__RemoveAudioDecoderConfigurationResponse (101)
/* ns1:RemoveAudioDecoderConfigurationResponse */
class SOAP_CMAC _ns1__RemoveAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique type id SOAP_TYPE__ns1__RemoveAudioDecoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__RemoveAudioDecoderConfigurationResponse() { _ns1__RemoveAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__RemoveAudioDecoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteProfile
#define SOAP_TYPE__ns1__DeleteProfile (102)
/* ns1:DeleteProfile */
class SOAP_CMAC _ns1__DeleteProfile
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique type id SOAP_TYPE__ns1__DeleteProfile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteProfile() { _ns1__DeleteProfile::soap_default(NULL); }
	virtual ~_ns1__DeleteProfile() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteProfileResponse
#define SOAP_TYPE__ns1__DeleteProfileResponse (103)
/* ns1:DeleteProfileResponse */
class SOAP_CMAC _ns1__DeleteProfileResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique type id SOAP_TYPE__ns1__DeleteProfileResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteProfileResponse() { _ns1__DeleteProfileResponse::soap_default(NULL); }
	virtual ~_ns1__DeleteProfileResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfigurations
#define SOAP_TYPE__ns1__GetVideoEncoderConfigurations (104)
/* ns1:GetVideoEncoderConfigurations */
class SOAP_CMAC _ns1__GetVideoEncoderConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfigurations() { _ns1__GetVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetVideoEncoderConfigurationsResponse (105)
/* ns1:GetVideoEncoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetVideoEncoderConfigurationsResponse
{
public:
	std::vector<class ns2__VideoEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:VideoEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfigurationsResponse() { _ns1__GetVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfigurations
#define SOAP_TYPE__ns1__GetVideoSourceConfigurations (106)
/* ns1:GetVideoSourceConfigurations */
class SOAP_CMAC _ns1__GetVideoSourceConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfigurations() { _ns1__GetVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns1__GetVideoSourceConfigurationsResponse (107)
/* ns1:GetVideoSourceConfigurationsResponse */
class SOAP_CMAC _ns1__GetVideoSourceConfigurationsResponse
{
public:
	std::vector<class ns2__VideoSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfigurationsResponse() { _ns1__GetVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfigurations
#define SOAP_TYPE__ns1__GetAudioEncoderConfigurations (108)
/* ns1:GetAudioEncoderConfigurations */
class SOAP_CMAC _ns1__GetAudioEncoderConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfigurations() { _ns1__GetAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioEncoderConfigurationsResponse (109)
/* ns1:GetAudioEncoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioEncoderConfigurationsResponse
{
public:
	std::vector<class ns2__AudioEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfigurationsResponse() { _ns1__GetAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfigurations
#define SOAP_TYPE__ns1__GetAudioSourceConfigurations (110)
/* ns1:GetAudioSourceConfigurations */
class SOAP_CMAC _ns1__GetAudioSourceConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfigurations() { _ns1__GetAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioSourceConfigurationsResponse (111)
/* ns1:GetAudioSourceConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioSourceConfigurationsResponse
{
public:
	std::vector<class ns2__AudioSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfigurationsResponse() { _ns1__GetAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoAnalyticsConfigurations
#define SOAP_TYPE__ns1__GetVideoAnalyticsConfigurations (112)
/* ns1:GetVideoAnalyticsConfigurations */
class SOAP_CMAC _ns1__GetVideoAnalyticsConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique type id SOAP_TYPE__ns1__GetVideoAnalyticsConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoAnalyticsConfigurations() { _ns1__GetVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetVideoAnalyticsConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns1__GetVideoAnalyticsConfigurationsResponse (113)
/* ns1:GetVideoAnalyticsConfigurationsResponse */
class SOAP_CMAC _ns1__GetVideoAnalyticsConfigurationsResponse
{
public:
	std::vector<class ns2__VideoAnalyticsConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique type id SOAP_TYPE__ns1__GetVideoAnalyticsConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoAnalyticsConfigurationsResponse() { _ns1__GetVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoAnalyticsConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfigurations
#define SOAP_TYPE__ns1__GetMetadataConfigurations (114)
/* ns1:GetMetadataConfigurations */
class SOAP_CMAC _ns1__GetMetadataConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfigurations() { _ns1__GetMetadataConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfigurationsResponse
#define SOAP_TYPE__ns1__GetMetadataConfigurationsResponse (115)
/* ns1:GetMetadataConfigurationsResponse */
class SOAP_CMAC _ns1__GetMetadataConfigurationsResponse
{
public:
	std::vector<class ns2__MetadataConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfigurationsResponse() { _ns1__GetMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfigurations
#define SOAP_TYPE__ns1__GetAudioOutputConfigurations (116)
/* ns1:GetAudioOutputConfigurations */
class SOAP_CMAC _ns1__GetAudioOutputConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfigurations() { _ns1__GetAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioOutputConfigurationsResponse (117)
/* ns1:GetAudioOutputConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioOutputConfigurationsResponse
{
public:
	std::vector<class ns2__AudioOutputConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioOutputConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfigurationsResponse() { _ns1__GetAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfigurations
#define SOAP_TYPE__ns1__GetAudioDecoderConfigurations (118)
/* ns1:GetAudioDecoderConfigurations */
class SOAP_CMAC _ns1__GetAudioDecoderConfigurations
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfigurations() { _ns1__GetAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetAudioDecoderConfigurationsResponse (119)
/* ns1:GetAudioDecoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetAudioDecoderConfigurationsResponse
{
public:
	std::vector<class ns2__AudioDecoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioDecoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfigurationsResponse() { _ns1__GetAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfiguration
#define SOAP_TYPE__ns1__GetVideoSourceConfiguration (120)
/* ns1:GetVideoSourceConfiguration */
class SOAP_CMAC _ns1__GetVideoSourceConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfiguration() { _ns1__GetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfigurationResponse
#define SOAP_TYPE__ns1__GetVideoSourceConfigurationResponse (121)
/* ns1:GetVideoSourceConfigurationResponse */
class SOAP_CMAC _ns1__GetVideoSourceConfigurationResponse
{
public:
	ns2__VideoSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfigurationResponse() { _ns1__GetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfiguration
#define SOAP_TYPE__ns1__GetVideoEncoderConfiguration (122)
/* ns1:GetVideoEncoderConfiguration */
class SOAP_CMAC _ns1__GetVideoEncoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfiguration() { _ns1__GetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns1__GetVideoEncoderConfigurationResponse (123)
/* ns1:GetVideoEncoderConfigurationResponse */
class SOAP_CMAC _ns1__GetVideoEncoderConfigurationResponse
{
public:
	ns2__VideoEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:VideoEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfigurationResponse() { _ns1__GetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfiguration
#define SOAP_TYPE__ns1__GetAudioSourceConfiguration (124)
/* ns1:GetAudioSourceConfiguration */
class SOAP_CMAC _ns1__GetAudioSourceConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfiguration() { _ns1__GetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfigurationResponse
#define SOAP_TYPE__ns1__GetAudioSourceConfigurationResponse (125)
/* ns1:GetAudioSourceConfigurationResponse */
class SOAP_CMAC _ns1__GetAudioSourceConfigurationResponse
{
public:
	ns2__AudioSourceConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 125; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfigurationResponse() { _ns1__GetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfiguration
#define SOAP_TYPE__ns1__GetAudioEncoderConfiguration (126)
/* ns1:GetAudioEncoderConfiguration */
class SOAP_CMAC _ns1__GetAudioEncoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 126; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfiguration() { _ns1__GetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns1__GetAudioEncoderConfigurationResponse (127)
/* ns1:GetAudioEncoderConfigurationResponse */
class SOAP_CMAC _ns1__GetAudioEncoderConfigurationResponse
{
public:
	ns2__AudioEncoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 127; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfigurationResponse() { _ns1__GetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoAnalyticsConfiguration
#define SOAP_TYPE__ns1__GetVideoAnalyticsConfiguration (128)
/* ns1:GetVideoAnalyticsConfiguration */
class SOAP_CMAC _ns1__GetVideoAnalyticsConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 128; } /* = unique type id SOAP_TYPE__ns1__GetVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoAnalyticsConfiguration() { _ns1__GetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns1__GetVideoAnalyticsConfigurationResponse (129)
/* ns1:GetVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _ns1__GetVideoAnalyticsConfigurationResponse
{
public:
	ns2__VideoAnalyticsConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 129; } /* = unique type id SOAP_TYPE__ns1__GetVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoAnalyticsConfigurationResponse() { _ns1__GetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfiguration
#define SOAP_TYPE__ns1__GetMetadataConfiguration (130)
/* ns1:GetMetadataConfiguration */
class SOAP_CMAC _ns1__GetMetadataConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 130; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfiguration() { _ns1__GetMetadataConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfigurationResponse
#define SOAP_TYPE__ns1__GetMetadataConfigurationResponse (131)
/* ns1:GetMetadataConfigurationResponse */
class SOAP_CMAC _ns1__GetMetadataConfigurationResponse
{
public:
	ns2__MetadataConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 131; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfigurationResponse() { _ns1__GetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfiguration
#define SOAP_TYPE__ns1__GetAudioOutputConfiguration (132)
/* ns1:GetAudioOutputConfiguration */
class SOAP_CMAC _ns1__GetAudioOutputConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 132; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfiguration() { _ns1__GetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfigurationResponse
#define SOAP_TYPE__ns1__GetAudioOutputConfigurationResponse (133)
/* ns1:GetAudioOutputConfigurationResponse */
class SOAP_CMAC _ns1__GetAudioOutputConfigurationResponse
{
public:
	ns2__AudioOutputConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioOutputConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 133; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfigurationResponse() { _ns1__GetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfiguration
#define SOAP_TYPE__ns1__GetAudioDecoderConfiguration (134)
/* ns1:GetAudioDecoderConfiguration */
class SOAP_CMAC _ns1__GetAudioDecoderConfiguration
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 134; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfiguration() { _ns1__GetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns1__GetAudioDecoderConfigurationResponse (135)
/* ns1:GetAudioDecoderConfigurationResponse */
class SOAP_CMAC _ns1__GetAudioDecoderConfigurationResponse
{
public:
	ns2__AudioDecoderConfiguration *Configuration;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioDecoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 135; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfigurationResponse() { _ns1__GetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE__ns1__GetCompatibleVideoEncoderConfigurations (136)
/* ns1:GetCompatibleVideoEncoderConfigurations */
class SOAP_CMAC _ns1__GetCompatibleVideoEncoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 136; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleVideoEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleVideoEncoderConfigurations() { _ns1__GetCompatibleVideoEncoderConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleVideoEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleVideoEncoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleVideoEncoderConfigurationsResponse (137)
/* ns1:GetCompatibleVideoEncoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleVideoEncoderConfigurationsResponse
{
public:
	std::vector<ns2__VideoEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:VideoEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 137; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleVideoEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleVideoEncoderConfigurationsResponse() { _ns1__GetCompatibleVideoEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleVideoEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE__ns1__GetCompatibleVideoSourceConfigurations (138)
/* ns1:GetCompatibleVideoSourceConfigurations */
class SOAP_CMAC _ns1__GetCompatibleVideoSourceConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 138; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleVideoSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleVideoSourceConfigurations() { _ns1__GetCompatibleVideoSourceConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleVideoSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleVideoSourceConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleVideoSourceConfigurationsResponse (139)
/* ns1:GetCompatibleVideoSourceConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleVideoSourceConfigurationsResponse
{
public:
	std::vector<ns2__VideoSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:VideoSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 139; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleVideoSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleVideoSourceConfigurationsResponse() { _ns1__GetCompatibleVideoSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleVideoSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE__ns1__GetCompatibleAudioEncoderConfigurations (140)
/* ns1:GetCompatibleAudioEncoderConfigurations */
class SOAP_CMAC _ns1__GetCompatibleAudioEncoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 140; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioEncoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioEncoderConfigurations() { _ns1__GetCompatibleAudioEncoderConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioEncoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioEncoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleAudioEncoderConfigurationsResponse (141)
/* ns1:GetCompatibleAudioEncoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleAudioEncoderConfigurationsResponse
{
public:
	std::vector<ns2__AudioEncoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioEncoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 141; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioEncoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioEncoderConfigurationsResponse() { _ns1__GetCompatibleAudioEncoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioEncoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE__ns1__GetCompatibleAudioSourceConfigurations (142)
/* ns1:GetCompatibleAudioSourceConfigurations */
class SOAP_CMAC _ns1__GetCompatibleAudioSourceConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 142; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioSourceConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioSourceConfigurations() { _ns1__GetCompatibleAudioSourceConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioSourceConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioSourceConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleAudioSourceConfigurationsResponse (143)
/* ns1:GetCompatibleAudioSourceConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleAudioSourceConfigurationsResponse
{
public:
	std::vector<ns2__AudioSourceConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioSourceConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 143; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioSourceConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioSourceConfigurationsResponse() { _ns1__GetCompatibleAudioSourceConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioSourceConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE__ns1__GetCompatibleVideoAnalyticsConfigurations (144)
/* ns1:GetCompatibleVideoAnalyticsConfigurations */
class SOAP_CMAC _ns1__GetCompatibleVideoAnalyticsConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 144; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleVideoAnalyticsConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleVideoAnalyticsConfigurations() { _ns1__GetCompatibleVideoAnalyticsConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleVideoAnalyticsConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleVideoAnalyticsConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleVideoAnalyticsConfigurationsResponse (145)
/* ns1:GetCompatibleVideoAnalyticsConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleVideoAnalyticsConfigurationsResponse
{
public:
	std::vector<ns2__VideoAnalyticsConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:VideoAnalyticsConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 145; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleVideoAnalyticsConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleVideoAnalyticsConfigurationsResponse() { _ns1__GetCompatibleVideoAnalyticsConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleVideoAnalyticsConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleMetadataConfigurations
#define SOAP_TYPE__ns1__GetCompatibleMetadataConfigurations (146)
/* ns1:GetCompatibleMetadataConfigurations */
class SOAP_CMAC _ns1__GetCompatibleMetadataConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 146; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleMetadataConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleMetadataConfigurations() { _ns1__GetCompatibleMetadataConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleMetadataConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleMetadataConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleMetadataConfigurationsResponse (147)
/* ns1:GetCompatibleMetadataConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleMetadataConfigurationsResponse
{
public:
	std::vector<ns2__MetadataConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:MetadataConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 147; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleMetadataConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleMetadataConfigurationsResponse() { _ns1__GetCompatibleMetadataConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleMetadataConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE__ns1__GetCompatibleAudioOutputConfigurations (148)
/* ns1:GetCompatibleAudioOutputConfigurations */
class SOAP_CMAC _ns1__GetCompatibleAudioOutputConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 148; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioOutputConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioOutputConfigurations() { _ns1__GetCompatibleAudioOutputConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioOutputConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioOutputConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleAudioOutputConfigurationsResponse (149)
/* ns1:GetCompatibleAudioOutputConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleAudioOutputConfigurationsResponse
{
public:
	std::vector<ns2__AudioOutputConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioOutputConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 149; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioOutputConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioOutputConfigurationsResponse() { _ns1__GetCompatibleAudioOutputConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioOutputConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE__ns1__GetCompatibleAudioDecoderConfigurations (150)
/* ns1:GetCompatibleAudioDecoderConfigurations */
class SOAP_CMAC _ns1__GetCompatibleAudioDecoderConfigurations
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 150; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioDecoderConfigurations */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioDecoderConfigurations() { _ns1__GetCompatibleAudioDecoderConfigurations::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioDecoderConfigurations() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetCompatibleAudioDecoderConfigurationsResponse
#define SOAP_TYPE__ns1__GetCompatibleAudioDecoderConfigurationsResponse (151)
/* ns1:GetCompatibleAudioDecoderConfigurationsResponse */
class SOAP_CMAC _ns1__GetCompatibleAudioDecoderConfigurationsResponse
{
public:
	std::vector<ns2__AudioDecoderConfiguration * >Configurations;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:AudioDecoderConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 151; } /* = unique type id SOAP_TYPE__ns1__GetCompatibleAudioDecoderConfigurationsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetCompatibleAudioDecoderConfigurationsResponse() { _ns1__GetCompatibleAudioDecoderConfigurationsResponse::soap_default(NULL); }
	virtual ~_ns1__GetCompatibleAudioDecoderConfigurationsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoEncoderConfiguration
#define SOAP_TYPE__ns1__SetVideoEncoderConfiguration (152)
/* ns1:SetVideoEncoderConfiguration */
class SOAP_CMAC _ns1__SetVideoEncoderConfiguration
{
public:
	ns2__VideoEncoderConfiguration *Configuration;	/* required element of type ns2:VideoEncoderConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 152; } /* = unique type id SOAP_TYPE__ns1__SetVideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoEncoderConfiguration() { _ns1__SetVideoEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetVideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse
#define SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse (153)
/* ns1:SetVideoEncoderConfigurationResponse */
class SOAP_CMAC _ns1__SetVideoEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 153; } /* = unique type id SOAP_TYPE__ns1__SetVideoEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoEncoderConfigurationResponse() { _ns1__SetVideoEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetVideoEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoSourceConfiguration
#define SOAP_TYPE__ns1__SetVideoSourceConfiguration (154)
/* ns1:SetVideoSourceConfiguration */
class SOAP_CMAC _ns1__SetVideoSourceConfiguration
{
public:
	ns2__VideoSourceConfiguration *Configuration;	/* required element of type ns2:VideoSourceConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 154; } /* = unique type id SOAP_TYPE__ns1__SetVideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoSourceConfiguration() { _ns1__SetVideoSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetVideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoSourceConfigurationResponse
#define SOAP_TYPE__ns1__SetVideoSourceConfigurationResponse (155)
/* ns1:SetVideoSourceConfigurationResponse */
class SOAP_CMAC _ns1__SetVideoSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 155; } /* = unique type id SOAP_TYPE__ns1__SetVideoSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoSourceConfigurationResponse() { _ns1__SetVideoSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetVideoSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioEncoderConfiguration
#define SOAP_TYPE__ns1__SetAudioEncoderConfiguration (156)
/* ns1:SetAudioEncoderConfiguration */
class SOAP_CMAC _ns1__SetAudioEncoderConfiguration
{
public:
	ns2__AudioEncoderConfiguration *Configuration;	/* required element of type ns2:AudioEncoderConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 156; } /* = unique type id SOAP_TYPE__ns1__SetAudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioEncoderConfiguration() { _ns1__SetAudioEncoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioEncoderConfigurationResponse
#define SOAP_TYPE__ns1__SetAudioEncoderConfigurationResponse (157)
/* ns1:SetAudioEncoderConfigurationResponse */
class SOAP_CMAC _ns1__SetAudioEncoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 157; } /* = unique type id SOAP_TYPE__ns1__SetAudioEncoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioEncoderConfigurationResponse() { _ns1__SetAudioEncoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetAudioEncoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioSourceConfiguration
#define SOAP_TYPE__ns1__SetAudioSourceConfiguration (158)
/* ns1:SetAudioSourceConfiguration */
class SOAP_CMAC _ns1__SetAudioSourceConfiguration
{
public:
	ns2__AudioSourceConfiguration *Configuration;	/* required element of type ns2:AudioSourceConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 158; } /* = unique type id SOAP_TYPE__ns1__SetAudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioSourceConfiguration() { _ns1__SetAudioSourceConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioSourceConfigurationResponse
#define SOAP_TYPE__ns1__SetAudioSourceConfigurationResponse (159)
/* ns1:SetAudioSourceConfigurationResponse */
class SOAP_CMAC _ns1__SetAudioSourceConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 159; } /* = unique type id SOAP_TYPE__ns1__SetAudioSourceConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioSourceConfigurationResponse() { _ns1__SetAudioSourceConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetAudioSourceConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoAnalyticsConfiguration
#define SOAP_TYPE__ns1__SetVideoAnalyticsConfiguration (160)
/* ns1:SetVideoAnalyticsConfiguration */
class SOAP_CMAC _ns1__SetVideoAnalyticsConfiguration
{
public:
	ns2__VideoAnalyticsConfiguration *Configuration;	/* required element of type ns2:VideoAnalyticsConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 160; } /* = unique type id SOAP_TYPE__ns1__SetVideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoAnalyticsConfiguration() { _ns1__SetVideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetVideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoAnalyticsConfigurationResponse
#define SOAP_TYPE__ns1__SetVideoAnalyticsConfigurationResponse (161)
/* ns1:SetVideoAnalyticsConfigurationResponse */
class SOAP_CMAC _ns1__SetVideoAnalyticsConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 161; } /* = unique type id SOAP_TYPE__ns1__SetVideoAnalyticsConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoAnalyticsConfigurationResponse() { _ns1__SetVideoAnalyticsConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetVideoAnalyticsConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetMetadataConfiguration
#define SOAP_TYPE__ns1__SetMetadataConfiguration (162)
/* ns1:SetMetadataConfiguration */
class SOAP_CMAC _ns1__SetMetadataConfiguration
{
public:
	ns2__MetadataConfiguration *Configuration;	/* required element of type ns2:MetadataConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 162; } /* = unique type id SOAP_TYPE__ns1__SetMetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetMetadataConfiguration() { _ns1__SetMetadataConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetMetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetMetadataConfigurationResponse
#define SOAP_TYPE__ns1__SetMetadataConfigurationResponse (163)
/* ns1:SetMetadataConfigurationResponse */
class SOAP_CMAC _ns1__SetMetadataConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 163; } /* = unique type id SOAP_TYPE__ns1__SetMetadataConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetMetadataConfigurationResponse() { _ns1__SetMetadataConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetMetadataConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioOutputConfiguration
#define SOAP_TYPE__ns1__SetAudioOutputConfiguration (164)
/* ns1:SetAudioOutputConfiguration */
class SOAP_CMAC _ns1__SetAudioOutputConfiguration
{
public:
	ns2__AudioOutputConfiguration *Configuration;	/* required element of type ns2:AudioOutputConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 164; } /* = unique type id SOAP_TYPE__ns1__SetAudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioOutputConfiguration() { _ns1__SetAudioOutputConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioOutputConfigurationResponse
#define SOAP_TYPE__ns1__SetAudioOutputConfigurationResponse (165)
/* ns1:SetAudioOutputConfigurationResponse */
class SOAP_CMAC _ns1__SetAudioOutputConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 165; } /* = unique type id SOAP_TYPE__ns1__SetAudioOutputConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioOutputConfigurationResponse() { _ns1__SetAudioOutputConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetAudioOutputConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioDecoderConfiguration
#define SOAP_TYPE__ns1__SetAudioDecoderConfiguration (166)
/* ns1:SetAudioDecoderConfiguration */
class SOAP_CMAC _ns1__SetAudioDecoderConfiguration
{
public:
	ns2__AudioDecoderConfiguration *Configuration;	/* required element of type ns2:AudioDecoderConfiguration */
	bool ForcePersistence;	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 166; } /* = unique type id SOAP_TYPE__ns1__SetAudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioDecoderConfiguration() { _ns1__SetAudioDecoderConfiguration::soap_default(NULL); }
	virtual ~_ns1__SetAudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetAudioDecoderConfigurationResponse
#define SOAP_TYPE__ns1__SetAudioDecoderConfigurationResponse (167)
/* ns1:SetAudioDecoderConfigurationResponse */
class SOAP_CMAC _ns1__SetAudioDecoderConfigurationResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 167; } /* = unique type id SOAP_TYPE__ns1__SetAudioDecoderConfigurationResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetAudioDecoderConfigurationResponse() { _ns1__SetAudioDecoderConfigurationResponse::soap_default(NULL); }
	virtual ~_ns1__SetAudioDecoderConfigurationResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfigurationOptions
#define SOAP_TYPE__ns1__GetVideoSourceConfigurationOptions (168)
/* ns1:GetVideoSourceConfigurationOptions */
class SOAP_CMAC _ns1__GetVideoSourceConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 168; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfigurationOptions() { _ns1__GetVideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetVideoSourceConfigurationOptionsResponse (169)
/* ns1:GetVideoSourceConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetVideoSourceConfigurationOptionsResponse
{
public:
	class ns2__VideoSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:VideoSourceConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 169; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceConfigurationOptionsResponse() { _ns1__GetVideoSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions (170)
/* ns1:GetVideoEncoderConfigurationOptions */
class SOAP_CMAC _ns1__GetVideoEncoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 170; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfigurationOptions() { _ns1__GetVideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse (171)
/* ns1:GetVideoEncoderConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetVideoEncoderConfigurationOptionsResponse
{
public:
	class ns2__VideoEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:VideoEncoderConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 171; } /* = unique type id SOAP_TYPE__ns1__GetVideoEncoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoEncoderConfigurationOptionsResponse() { _ns1__GetVideoEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoEncoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfigurationOptions
#define SOAP_TYPE__ns1__GetAudioSourceConfigurationOptions (172)
/* ns1:GetAudioSourceConfigurationOptions */
class SOAP_CMAC _ns1__GetAudioSourceConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 172; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfigurationOptions() { _ns1__GetAudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioSourceConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioSourceConfigurationOptionsResponse (173)
/* ns1:GetAudioSourceConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioSourceConfigurationOptionsResponse
{
public:
	class ns2__AudioSourceConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioSourceConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 173; } /* = unique type id SOAP_TYPE__ns1__GetAudioSourceConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioSourceConfigurationOptionsResponse() { _ns1__GetAudioSourceConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioSourceConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptions (174)
/* ns1:GetAudioEncoderConfigurationOptions */
class SOAP_CMAC _ns1__GetAudioEncoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 174; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfigurationOptions() { _ns1__GetAudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptionsResponse (175)
/* ns1:GetAudioEncoderConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioEncoderConfigurationOptionsResponse
{
public:
	class ns2__AudioEncoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioEncoderConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 175; } /* = unique type id SOAP_TYPE__ns1__GetAudioEncoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioEncoderConfigurationOptionsResponse() { _ns1__GetAudioEncoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioEncoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfigurationOptions
#define SOAP_TYPE__ns1__GetMetadataConfigurationOptions (176)
/* ns1:GetMetadataConfigurationOptions */
class SOAP_CMAC _ns1__GetMetadataConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 176; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfigurationOptions() { _ns1__GetMetadataConfigurationOptions::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetMetadataConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetMetadataConfigurationOptionsResponse (177)
/* ns1:GetMetadataConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetMetadataConfigurationOptionsResponse
{
public:
	class ns2__MetadataConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:MetadataConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 177; } /* = unique type id SOAP_TYPE__ns1__GetMetadataConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetMetadataConfigurationOptionsResponse() { _ns1__GetMetadataConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetMetadataConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfigurationOptions
#define SOAP_TYPE__ns1__GetAudioOutputConfigurationOptions (178)
/* ns1:GetAudioOutputConfigurationOptions */
class SOAP_CMAC _ns1__GetAudioOutputConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 178; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfigurationOptions() { _ns1__GetAudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioOutputConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioOutputConfigurationOptionsResponse (179)
/* ns1:GetAudioOutputConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioOutputConfigurationOptionsResponse
{
public:
	class ns2__AudioOutputConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioOutputConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 179; } /* = unique type id SOAP_TYPE__ns1__GetAudioOutputConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioOutputConfigurationOptionsResponse() { _ns1__GetAudioOutputConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioOutputConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptions (180)
/* ns1:GetAudioDecoderConfigurationOptions */
class SOAP_CMAC _ns1__GetAudioDecoderConfigurationOptions
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	std::string *ProfileToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 180; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfigurationOptions() { _ns1__GetAudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptionsResponse
#define SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptionsResponse (181)
/* ns1:GetAudioDecoderConfigurationOptionsResponse */
class SOAP_CMAC _ns1__GetAudioDecoderConfigurationOptionsResponse
{
public:
	class ns2__AudioDecoderConfigurationOptions *Options;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:AudioDecoderConfigurationOptions */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 181; } /* = unique type id SOAP_TYPE__ns1__GetAudioDecoderConfigurationOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetAudioDecoderConfigurationOptionsResponse() { _ns1__GetAudioDecoderConfigurationOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetAudioDecoderConfigurationOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE__ns1__GetGuaranteedNumberOfVideoEncoderInstances (182)
/* ns1:GetGuaranteedNumberOfVideoEncoderInstances */
class SOAP_CMAC _ns1__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 182; } /* = unique type id SOAP_TYPE__ns1__GetGuaranteedNumberOfVideoEncoderInstances */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetGuaranteedNumberOfVideoEncoderInstances() { _ns1__GetGuaranteedNumberOfVideoEncoderInstances::soap_default(NULL); }
	virtual ~_ns1__GetGuaranteedNumberOfVideoEncoderInstances() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetGuaranteedNumberOfVideoEncoderInstancesResponse
#define SOAP_TYPE__ns1__GetGuaranteedNumberOfVideoEncoderInstancesResponse (183)
/* ns1:GetGuaranteedNumberOfVideoEncoderInstancesResponse */
class SOAP_CMAC _ns1__GetGuaranteedNumberOfVideoEncoderInstancesResponse
{
public:
	int TotalNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:int */
	int *JPEG;	/* optional element of type xsd:int */
	int *H264;	/* optional element of type xsd:int */
	int *MPEG4;	/* optional element of type xsd:int */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 183; } /* = unique type id SOAP_TYPE__ns1__GetGuaranteedNumberOfVideoEncoderInstancesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { _ns1__GetGuaranteedNumberOfVideoEncoderInstancesResponse::soap_default(NULL); }
	virtual ~_ns1__GetGuaranteedNumberOfVideoEncoderInstancesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStreamUri
#define SOAP_TYPE__ns1__GetStreamUri (184)
/* ns1:GetStreamUri */
class SOAP_CMAC _ns1__GetStreamUri
{
public:
	class ns2__StreamSetup *StreamSetup;	/* required element of type ns2:StreamSetup */
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 184; } /* = unique type id SOAP_TYPE__ns1__GetStreamUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStreamUri() { _ns1__GetStreamUri::soap_default(NULL); }
	virtual ~_ns1__GetStreamUri() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetStreamUriResponse
#define SOAP_TYPE__ns1__GetStreamUriResponse (185)
/* ns1:GetStreamUriResponse */
class SOAP_CMAC _ns1__GetStreamUriResponse
{
public:
	class ns2__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:MediaUri */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 185; } /* = unique type id SOAP_TYPE__ns1__GetStreamUriResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetStreamUriResponse() { _ns1__GetStreamUriResponse::soap_default(NULL); }
	virtual ~_ns1__GetStreamUriResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StartMulticastStreaming
#define SOAP_TYPE__ns1__StartMulticastStreaming (186)
/* ns1:StartMulticastStreaming */
class SOAP_CMAC _ns1__StartMulticastStreaming
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 186; } /* = unique type id SOAP_TYPE__ns1__StartMulticastStreaming */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StartMulticastStreaming() { _ns1__StartMulticastStreaming::soap_default(NULL); }
	virtual ~_ns1__StartMulticastStreaming() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StartMulticastStreamingResponse
#define SOAP_TYPE__ns1__StartMulticastStreamingResponse (187)
/* ns1:StartMulticastStreamingResponse */
class SOAP_CMAC _ns1__StartMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 187; } /* = unique type id SOAP_TYPE__ns1__StartMulticastStreamingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StartMulticastStreamingResponse() { _ns1__StartMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_ns1__StartMulticastStreamingResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopMulticastStreaming
#define SOAP_TYPE__ns1__StopMulticastStreaming (188)
/* ns1:StopMulticastStreaming */
class SOAP_CMAC _ns1__StopMulticastStreaming
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 188; } /* = unique type id SOAP_TYPE__ns1__StopMulticastStreaming */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopMulticastStreaming() { _ns1__StopMulticastStreaming::soap_default(NULL); }
	virtual ~_ns1__StopMulticastStreaming() { }
};
#endif

#ifndef SOAP_TYPE__ns1__StopMulticastStreamingResponse
#define SOAP_TYPE__ns1__StopMulticastStreamingResponse (189)
/* ns1:StopMulticastStreamingResponse */
class SOAP_CMAC _ns1__StopMulticastStreamingResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 189; } /* = unique type id SOAP_TYPE__ns1__StopMulticastStreamingResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__StopMulticastStreamingResponse() { _ns1__StopMulticastStreamingResponse::soap_default(NULL); }
	virtual ~_ns1__StopMulticastStreamingResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetSynchronizationPoint
#define SOAP_TYPE__ns1__SetSynchronizationPoint (190)
/* ns1:SetSynchronizationPoint */
class SOAP_CMAC _ns1__SetSynchronizationPoint
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 190; } /* = unique type id SOAP_TYPE__ns1__SetSynchronizationPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetSynchronizationPoint() { _ns1__SetSynchronizationPoint::soap_default(NULL); }
	virtual ~_ns1__SetSynchronizationPoint() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetSynchronizationPointResponse
#define SOAP_TYPE__ns1__SetSynchronizationPointResponse (191)
/* ns1:SetSynchronizationPointResponse */
class SOAP_CMAC _ns1__SetSynchronizationPointResponse
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 191; } /* = unique type id SOAP_TYPE__ns1__SetSynchronizationPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetSynchronizationPointResponse() { _ns1__SetSynchronizationPointResponse::soap_default(NULL); }
	virtual ~_ns1__SetSynchronizationPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetSnapshotUri
#define SOAP_TYPE__ns1__GetSnapshotUri (192)
/* ns1:GetSnapshotUri */
class SOAP_CMAC _ns1__GetSnapshotUri
{
public:
	std::string ProfileToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 192; } /* = unique type id SOAP_TYPE__ns1__GetSnapshotUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetSnapshotUri() { _ns1__GetSnapshotUri::soap_default(NULL); }
	virtual ~_ns1__GetSnapshotUri() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetSnapshotUriResponse
#define SOAP_TYPE__ns1__GetSnapshotUriResponse (193)
/* ns1:GetSnapshotUriResponse */
class SOAP_CMAC _ns1__GetSnapshotUriResponse
{
public:
	ns2__MediaUri *MediaUri;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:MediaUri */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 193; } /* = unique type id SOAP_TYPE__ns1__GetSnapshotUriResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetSnapshotUriResponse() { _ns1__GetSnapshotUriResponse::soap_default(NULL); }
	virtual ~_ns1__GetSnapshotUriResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceModes
#define SOAP_TYPE__ns1__GetVideoSourceModes (194)
/* ns1:GetVideoSourceModes */
class SOAP_CMAC _ns1__GetVideoSourceModes
{
public:
	std::string VideoSourceToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 194; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceModes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceModes() { _ns1__GetVideoSourceModes::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceModes() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetVideoSourceModesResponse
#define SOAP_TYPE__ns1__GetVideoSourceModesResponse (195)
/* ns1:GetVideoSourceModesResponse */
class SOAP_CMAC _ns1__GetVideoSourceModesResponse
{
public:
	std::vector<ns1__VideoSourceMode * >VideoSourceModes;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns1:VideoSourceMode */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 195; } /* = unique type id SOAP_TYPE__ns1__GetVideoSourceModesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetVideoSourceModesResponse() { _ns1__GetVideoSourceModesResponse::soap_default(NULL); }
	virtual ~_ns1__GetVideoSourceModesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoSourceMode
#define SOAP_TYPE__ns1__SetVideoSourceMode (196)
/* ns1:SetVideoSourceMode */
class SOAP_CMAC _ns1__SetVideoSourceMode
{
public:
	std::string VideoSourceToken;	/* required element of type ns2:ReferenceToken */
	std::string VideoSourceModeToken;	/* required element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 196; } /* = unique type id SOAP_TYPE__ns1__SetVideoSourceMode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoSourceMode() { _ns1__SetVideoSourceMode::soap_default(NULL); }
	virtual ~_ns1__SetVideoSourceMode() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetVideoSourceModeResponse
#define SOAP_TYPE__ns1__SetVideoSourceModeResponse (197)
/* ns1:SetVideoSourceModeResponse */
class SOAP_CMAC _ns1__SetVideoSourceModeResponse
{
public:
	bool Reboot;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:boolean */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 197; } /* = unique type id SOAP_TYPE__ns1__SetVideoSourceModeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetVideoSourceModeResponse() { _ns1__SetVideoSourceModeResponse::soap_default(NULL); }
	virtual ~_ns1__SetVideoSourceModeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDs
#define SOAP_TYPE__ns1__GetOSDs (198)
/* ns1:GetOSDs */
class SOAP_CMAC _ns1__GetOSDs
{
public:
	std::string *ConfigurationToken;	/* optional element of type ns2:ReferenceToken */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 198; } /* = unique type id SOAP_TYPE__ns1__GetOSDs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDs() { _ns1__GetOSDs::soap_default(NULL); }
	virtual ~_ns1__GetOSDs() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDsResponse
#define SOAP_TYPE__ns1__GetOSDsResponse (199)
/* ns1:GetOSDsResponse */
class SOAP_CMAC _ns1__GetOSDsResponse
{
public:
	std::vector<class ns2__OSDConfiguration * >OSDs;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* optional element of type ns2:OSDConfiguration */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 199; } /* = unique type id SOAP_TYPE__ns1__GetOSDsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDsResponse() { _ns1__GetOSDsResponse::soap_default(NULL); }
	virtual ~_ns1__GetOSDsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSD
#define SOAP_TYPE__ns1__GetOSD (200)
/* ns1:GetOSD */
class SOAP_CMAC _ns1__GetOSD
{
public:
	std::string OSDToken;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 200; } /* = unique type id SOAP_TYPE__ns1__GetOSD */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSD() { _ns1__GetOSD::soap_default(NULL); }
	virtual ~_ns1__GetOSD() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDResponse
#define SOAP_TYPE__ns1__GetOSDResponse (201)
/* ns1:GetOSDResponse */
class SOAP_CMAC _ns1__GetOSDResponse
{
public:
	ns2__OSDConfiguration *OSD;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:OSDConfiguration */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 201; } /* = unique type id SOAP_TYPE__ns1__GetOSDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDResponse() { _ns1__GetOSDResponse::soap_default(NULL); }
	virtual ~_ns1__GetOSDResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetOSD
#define SOAP_TYPE__ns1__SetOSD (202)
/* ns1:SetOSD */
class SOAP_CMAC _ns1__SetOSD
{
public:
	ns2__OSDConfiguration *OSD;	/* required element of type ns2:OSDConfiguration */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 202; } /* = unique type id SOAP_TYPE__ns1__SetOSD */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetOSD() { _ns1__SetOSD::soap_default(NULL); }
	virtual ~_ns1__SetOSD() { }
};
#endif

#ifndef SOAP_TYPE__ns1__SetOSDResponse
#define SOAP_TYPE__ns1__SetOSDResponse (203)
/* ns1:SetOSDResponse */
class SOAP_CMAC _ns1__SetOSDResponse
{
public:
	std::vector<char * >__any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 203; } /* = unique type id SOAP_TYPE__ns1__SetOSDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__SetOSDResponse() { _ns1__SetOSDResponse::soap_default(NULL); }
	virtual ~_ns1__SetOSDResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDOptions
#define SOAP_TYPE__ns1__GetOSDOptions (204)
/* ns1:GetOSDOptions */
class SOAP_CMAC _ns1__GetOSDOptions
{
public:
	std::string ConfigurationToken;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 204; } /* = unique type id SOAP_TYPE__ns1__GetOSDOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDOptions() { _ns1__GetOSDOptions::soap_default(NULL); }
	virtual ~_ns1__GetOSDOptions() { }
};
#endif

#ifndef SOAP_TYPE__ns1__GetOSDOptionsResponse
#define SOAP_TYPE__ns1__GetOSDOptionsResponse (205)
/* ns1:GetOSDOptionsResponse */
class SOAP_CMAC _ns1__GetOSDOptionsResponse
{
public:
	class ns2__OSDConfigurationOptions *OSDOptions;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:OSDConfigurationOptions */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 205; } /* = unique type id SOAP_TYPE__ns1__GetOSDOptionsResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__GetOSDOptionsResponse() { _ns1__GetOSDOptionsResponse::soap_default(NULL); }
	virtual ~_ns1__GetOSDOptionsResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateOSD
#define SOAP_TYPE__ns1__CreateOSD (206)
/* ns1:CreateOSD */
class SOAP_CMAC _ns1__CreateOSD
{
public:
	ns2__OSDConfiguration *OSD;	/* required element of type ns2:OSDConfiguration */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 206; } /* = unique type id SOAP_TYPE__ns1__CreateOSD */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateOSD() { _ns1__CreateOSD::soap_default(NULL); }
	virtual ~_ns1__CreateOSD() { }
};
#endif

#ifndef SOAP_TYPE__ns1__CreateOSDResponse
#define SOAP_TYPE__ns1__CreateOSDResponse (207)
/* ns1:CreateOSDResponse */
class SOAP_CMAC _ns1__CreateOSDResponse
{
public:
	std::string OSDToken;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 207; } /* = unique type id SOAP_TYPE__ns1__CreateOSDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__CreateOSDResponse() { _ns1__CreateOSDResponse::soap_default(NULL); }
	virtual ~_ns1__CreateOSDResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteOSD
#define SOAP_TYPE__ns1__DeleteOSD (208)
/* ns1:DeleteOSD */
class SOAP_CMAC _ns1__DeleteOSD
{
public:
	std::string OSDToken;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 208; } /* = unique type id SOAP_TYPE__ns1__DeleteOSD */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteOSD() { _ns1__DeleteOSD::soap_default(NULL); }
	virtual ~_ns1__DeleteOSD() { }
};
#endif

#ifndef SOAP_TYPE__ns1__DeleteOSDResponse
#define SOAP_TYPE__ns1__DeleteOSDResponse (209)
/* ns1:DeleteOSDResponse */
class SOAP_CMAC _ns1__DeleteOSDResponse
{
public:
	std::vector<char * >__any;	/* SOAP 1.2 RPC return element (when namespace qualified) */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 209; } /* = unique type id SOAP_TYPE__ns1__DeleteOSDResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns1__DeleteOSDResponse() { _ns1__DeleteOSDResponse::soap_default(NULL); }
	virtual ~_ns1__DeleteOSDResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DeviceEntity
#define SOAP_TYPE_ns2__DeviceEntity (210)
/* Primitive ns2:DeviceEntity schema type: */
class SOAP_CMAC ns2__DeviceEntity : public xsd__anyType
{
public:
	std::string token;	/* required attribute */
public:
	virtual int soap_type() const { return 210; } /* = unique type id SOAP_TYPE_ns2__DeviceEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DeviceEntity() { ns2__DeviceEntity::soap_default(NULL); }
	virtual ~ns2__DeviceEntity() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IntRectangle
#define SOAP_TYPE_ns2__IntRectangle (211)
/* Primitive ns2:IntRectangle schema type: */
class SOAP_CMAC ns2__IntRectangle : public xsd__anyType
{
public:
	int x;	/* required attribute */
	int y;	/* required attribute */
	int width;	/* required attribute */
	int height;	/* required attribute */
public:
	virtual int soap_type() const { return 211; } /* = unique type id SOAP_TYPE_ns2__IntRectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IntRectangle() { ns2__IntRectangle::soap_default(NULL); }
	virtual ~ns2__IntRectangle() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IntRectangleRange
#define SOAP_TYPE_ns2__IntRectangleRange (212)
/* ns2:IntRectangleRange */
class SOAP_CMAC ns2__IntRectangleRange : public xsd__anyType
{
public:
	class ns2__IntRange *XRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *YRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *WidthRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *HeightRange;	/* required element of type ns2:IntRange */
public:
	virtual int soap_type() const { return 212; } /* = unique type id SOAP_TYPE_ns2__IntRectangleRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IntRectangleRange() { ns2__IntRectangleRange::soap_default(NULL); }
	virtual ~ns2__IntRectangleRange() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IntRange
#define SOAP_TYPE_ns2__IntRange (213)
/* ns2:IntRange */
class SOAP_CMAC ns2__IntRange : public xsd__anyType
{
public:
	int Min;	/* required element of type xsd:int */
	int Max;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 213; } /* = unique type id SOAP_TYPE_ns2__IntRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IntRange() { ns2__IntRange::soap_default(NULL); }
	virtual ~ns2__IntRange() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FloatRange
#define SOAP_TYPE_ns2__FloatRange (214)
/* ns2:FloatRange */
class SOAP_CMAC ns2__FloatRange : public xsd__anyType
{
public:
	float Min;	/* required element of type xsd:float */
	float Max;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 214; } /* = unique type id SOAP_TYPE_ns2__FloatRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FloatRange() { ns2__FloatRange::soap_default(NULL); }
	virtual ~ns2__FloatRange() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DurationRange
#define SOAP_TYPE_ns2__DurationRange (215)
/* ns2:DurationRange */
class SOAP_CMAC ns2__DurationRange : public xsd__anyType
{
public:
	std::string Min;	/* required element of type xsd:duration */
	std::string Max;	/* required element of type xsd:duration */
public:
	virtual int soap_type() const { return 215; } /* = unique type id SOAP_TYPE_ns2__DurationRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DurationRange() { ns2__DurationRange::soap_default(NULL); }
	virtual ~ns2__DurationRange() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IntList
#define SOAP_TYPE_ns2__IntList (216)
/* ns2:IntList */
class SOAP_CMAC ns2__IntList : public xsd__anyType
{
public:
	std::vector<int >Items;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 216; } /* = unique type id SOAP_TYPE_ns2__IntList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IntList() { ns2__IntList::soap_default(NULL); }
	virtual ~ns2__IntList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FloatList
#define SOAP_TYPE_ns2__FloatList (217)
/* ns2:FloatList */
class SOAP_CMAC ns2__FloatList : public xsd__anyType
{
public:
	std::vector<float >Items;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 217; } /* = unique type id SOAP_TYPE_ns2__FloatList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FloatList() { ns2__FloatList::soap_default(NULL); }
	virtual ~ns2__FloatList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnyHolder
#define SOAP_TYPE_ns2__AnyHolder (218)
/* ns2:AnyHolder */
class SOAP_CMAC ns2__AnyHolder : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 218; } /* = unique type id SOAP_TYPE_ns2__AnyHolder */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnyHolder() { ns2__AnyHolder::soap_default(NULL); }
	virtual ~ns2__AnyHolder() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceExtension
#define SOAP_TYPE_ns2__VideoSourceExtension (220)
/* ns2:VideoSourceExtension */
class SOAP_CMAC ns2__VideoSourceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__ImagingSettings20 *Imaging;	/* optional element of type ns2:ImagingSettings20 */
	class ns2__VideoSourceExtension2 *Extension;	/* optional element of type ns2:VideoSourceExtension2 */
public:
	virtual int soap_type() const { return 220; } /* = unique type id SOAP_TYPE_ns2__VideoSourceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceExtension() { ns2__VideoSourceExtension::soap_default(NULL); }
	virtual ~ns2__VideoSourceExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceExtension2
#define SOAP_TYPE_ns2__VideoSourceExtension2 (221)
/* ns2:VideoSourceExtension2 */
class SOAP_CMAC ns2__VideoSourceExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 221; } /* = unique type id SOAP_TYPE_ns2__VideoSourceExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceExtension2() { ns2__VideoSourceExtension2::soap_default(NULL); }
	virtual ~ns2__VideoSourceExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Profile
#define SOAP_TYPE_ns2__Profile (223)
/* ns2:Profile */
class SOAP_CMAC ns2__Profile : public xsd__anyType
{
public:
	std::string Name;	/* required element of type ns2:Name */
	ns2__VideoSourceConfiguration *VideoSourceConfiguration;	/* optional element of type ns2:VideoSourceConfiguration */
	ns2__AudioSourceConfiguration *AudioSourceConfiguration;	/* optional element of type ns2:AudioSourceConfiguration */
	ns2__VideoEncoderConfiguration *VideoEncoderConfiguration;	/* optional element of type ns2:VideoEncoderConfiguration */
	ns2__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of type ns2:AudioEncoderConfiguration */
	ns2__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* optional element of type ns2:VideoAnalyticsConfiguration */
	class ns2__PTZConfiguration *PTZConfiguration;	/* optional element of type ns2:PTZConfiguration */
	ns2__MetadataConfiguration *MetadataConfiguration;	/* optional element of type ns2:MetadataConfiguration */
	class ns2__ProfileExtension *Extension;	/* optional element of type ns2:ProfileExtension */
	std::string token;	/* required attribute */
	bool *fixed;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 223; } /* = unique type id SOAP_TYPE_ns2__Profile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Profile() { ns2__Profile::soap_default(NULL); }
	virtual ~ns2__Profile() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ProfileExtension
#define SOAP_TYPE_ns2__ProfileExtension (224)
/* ns2:ProfileExtension */
class SOAP_CMAC ns2__ProfileExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	ns2__AudioOutputConfiguration *AudioOutputConfiguration;	/* optional element of type ns2:AudioOutputConfiguration */
	ns2__AudioDecoderConfiguration *AudioDecoderConfiguration;	/* optional element of type ns2:AudioDecoderConfiguration */
	class ns2__ProfileExtension2 *Extension;	/* optional element of type ns2:ProfileExtension2 */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 224; } /* = unique type id SOAP_TYPE_ns2__ProfileExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ProfileExtension() { ns2__ProfileExtension::soap_default(NULL); }
	virtual ~ns2__ProfileExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ProfileExtension2
#define SOAP_TYPE_ns2__ProfileExtension2 (225)
/* ns2:ProfileExtension2 */
class SOAP_CMAC ns2__ProfileExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 225; } /* = unique type id SOAP_TYPE_ns2__ProfileExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ProfileExtension2() { ns2__ProfileExtension2::soap_default(NULL); }
	virtual ~ns2__ProfileExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ConfigurationEntity
#define SOAP_TYPE_ns2__ConfigurationEntity (226)
/* ns2:ConfigurationEntity */
class SOAP_CMAC ns2__ConfigurationEntity : public xsd__anyType
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
public:
	virtual int soap_type() const { return 226; } /* = unique type id SOAP_TYPE_ns2__ConfigurationEntity */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ConfigurationEntity() { ns2__ConfigurationEntity::soap_default(NULL); }
	virtual ~ns2__ConfigurationEntity() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationExtension
#define SOAP_TYPE_ns2__VideoSourceConfigurationExtension (228)
/* ns2:VideoSourceConfigurationExtension */
class SOAP_CMAC ns2__VideoSourceConfigurationExtension : public xsd__anyType
{
public:
	class ns2__Rotate *Rotate;	/* optional element of type ns2:Rotate */
	class ns2__VideoSourceConfigurationExtension2 *Extension;	/* optional element of type ns2:VideoSourceConfigurationExtension2 */
public:
	virtual int soap_type() const { return 228; } /* = unique type id SOAP_TYPE_ns2__VideoSourceConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceConfigurationExtension() { ns2__VideoSourceConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__VideoSourceConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationExtension2
#define SOAP_TYPE_ns2__VideoSourceConfigurationExtension2 (229)
/* ns2:VideoSourceConfigurationExtension2 */
class SOAP_CMAC ns2__VideoSourceConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 229; } /* = unique type id SOAP_TYPE_ns2__VideoSourceConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceConfigurationExtension2() { ns2__VideoSourceConfigurationExtension2::soap_default(NULL); }
	virtual ~ns2__VideoSourceConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Rotate
#define SOAP_TYPE_ns2__Rotate (230)
/* ns2:Rotate */
class SOAP_CMAC ns2__Rotate : public xsd__anyType
{
public:
	enum ns2__RotateMode Mode;	/* required element of type ns2:RotateMode */
	int *Degree;	/* optional element of type xsd:int */
	class ns2__RotateExtension *Extension;	/* optional element of type ns2:RotateExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 230; } /* = unique type id SOAP_TYPE_ns2__Rotate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Rotate() { ns2__Rotate::soap_default(NULL); }
	virtual ~ns2__Rotate() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RotateExtension
#define SOAP_TYPE_ns2__RotateExtension (231)
/* ns2:RotateExtension */
class SOAP_CMAC ns2__RotateExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 231; } /* = unique type id SOAP_TYPE_ns2__RotateExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RotateExtension() { ns2__RotateExtension::soap_default(NULL); }
	virtual ~ns2__RotateExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptions
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptions (232)
/* ns2:VideoSourceConfigurationOptions */
class SOAP_CMAC ns2__VideoSourceConfigurationOptions : public xsd__anyType
{
public:
	ns2__IntRectangleRange *BoundsRange;	/* required element of type ns2:IntRectangleRange */
	std::vector<std::string >VideoSourceTokensAvailable;	/* required element of type ns2:ReferenceToken */
	class ns2__VideoSourceConfigurationOptionsExtension *Extension;	/* optional element of type ns2:VideoSourceConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 232; } /* = unique type id SOAP_TYPE_ns2__VideoSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceConfigurationOptions() { ns2__VideoSourceConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__VideoSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension (233)
/* ns2:VideoSourceConfigurationOptionsExtension */
class SOAP_CMAC ns2__VideoSourceConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__RotateOptions *Rotate;	/* optional element of type ns2:RotateOptions */
	class ns2__VideoSourceConfigurationOptionsExtension2 *Extension;	/* optional element of type ns2:VideoSourceConfigurationOptionsExtension2 */
public:
	virtual int soap_type() const { return 233; } /* = unique type id SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceConfigurationOptionsExtension() { ns2__VideoSourceConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~ns2__VideoSourceConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2
#define SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2 (234)
/* ns2:VideoSourceConfigurationOptionsExtension2 */
class SOAP_CMAC ns2__VideoSourceConfigurationOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 234; } /* = unique type id SOAP_TYPE_ns2__VideoSourceConfigurationOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceConfigurationOptionsExtension2() { ns2__VideoSourceConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~ns2__VideoSourceConfigurationOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RotateOptions
#define SOAP_TYPE_ns2__RotateOptions (235)
/* ns2:RotateOptions */
class SOAP_CMAC ns2__RotateOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__RotateMode >Mode;	/* required element of type ns2:RotateMode */
	ns2__IntList *DegreeList;	/* optional element of type ns2:IntList */
	class ns2__RotateOptionsExtension *Extension;	/* optional element of type ns2:RotateOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 235; } /* = unique type id SOAP_TYPE_ns2__RotateOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RotateOptions() { ns2__RotateOptions::soap_default(NULL); }
	virtual ~ns2__RotateOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RotateOptionsExtension
#define SOAP_TYPE_ns2__RotateOptionsExtension (236)
/* ns2:RotateOptionsExtension */
class SOAP_CMAC ns2__RotateOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 236; } /* = unique type id SOAP_TYPE_ns2__RotateOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RotateOptionsExtension() { ns2__RotateOptionsExtension::soap_default(NULL); }
	virtual ~ns2__RotateOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoResolution
#define SOAP_TYPE_ns2__VideoResolution (238)
/* ns2:VideoResolution */
class SOAP_CMAC ns2__VideoResolution : public xsd__anyType
{
public:
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 238; } /* = unique type id SOAP_TYPE_ns2__VideoResolution */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoResolution() { ns2__VideoResolution::soap_default(NULL); }
	virtual ~ns2__VideoResolution() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoRateControl
#define SOAP_TYPE_ns2__VideoRateControl (239)
/* ns2:VideoRateControl */
class SOAP_CMAC ns2__VideoRateControl : public xsd__anyType
{
public:
	int FrameRateLimit;	/* required element of type xsd:int */
	int EncodingInterval;	/* required element of type xsd:int */
	int BitrateLimit;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 239; } /* = unique type id SOAP_TYPE_ns2__VideoRateControl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoRateControl() { ns2__VideoRateControl::soap_default(NULL); }
	virtual ~ns2__VideoRateControl() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Mpeg4Configuration
#define SOAP_TYPE_ns2__Mpeg4Configuration (240)
/* ns2:Mpeg4Configuration */
class SOAP_CMAC ns2__Mpeg4Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum ns2__Mpeg4Profile Mpeg4Profile;	/* required element of type ns2:Mpeg4Profile */
public:
	virtual int soap_type() const { return 240; } /* = unique type id SOAP_TYPE_ns2__Mpeg4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Mpeg4Configuration() { ns2__Mpeg4Configuration::soap_default(NULL); }
	virtual ~ns2__Mpeg4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__H264Configuration
#define SOAP_TYPE_ns2__H264Configuration (241)
/* ns2:H264Configuration */
class SOAP_CMAC ns2__H264Configuration : public xsd__anyType
{
public:
	int GovLength;	/* required element of type xsd:int */
	enum ns2__H264Profile H264Profile;	/* required element of type ns2:H264Profile */
public:
	virtual int soap_type() const { return 241; } /* = unique type id SOAP_TYPE_ns2__H264Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__H264Configuration() { ns2__H264Configuration::soap_default(NULL); }
	virtual ~ns2__H264Configuration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoEncoderConfigurationOptions
#define SOAP_TYPE_ns2__VideoEncoderConfigurationOptions (242)
/* ns2:VideoEncoderConfigurationOptions */
class SOAP_CMAC ns2__VideoEncoderConfigurationOptions : public xsd__anyType
{
public:
	ns2__IntRange *QualityRange;	/* required element of type ns2:IntRange */
	class ns2__JpegOptions *JPEG;	/* optional element of type ns2:JpegOptions */
	class ns2__Mpeg4Options *MPEG4;	/* optional element of type ns2:Mpeg4Options */
	class ns2__H264Options *H264;	/* optional element of type ns2:H264Options */
	class ns2__VideoEncoderOptionsExtension *Extension;	/* optional element of type ns2:VideoEncoderOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 242; } /* = unique type id SOAP_TYPE_ns2__VideoEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoEncoderConfigurationOptions() { ns2__VideoEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__VideoEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoEncoderOptionsExtension
#define SOAP_TYPE_ns2__VideoEncoderOptionsExtension (243)
/* ns2:VideoEncoderOptionsExtension */
class SOAP_CMAC ns2__VideoEncoderOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__JpegOptions2 *JPEG;	/* optional element of type ns2:JpegOptions2 */
	class ns2__Mpeg4Options2 *MPEG4;	/* optional element of type ns2:Mpeg4Options2 */
	class ns2__H264Options2 *H264;	/* optional element of type ns2:H264Options2 */
	class ns2__VideoEncoderOptionsExtension2 *Extension;	/* optional element of type ns2:VideoEncoderOptionsExtension2 */
public:
	virtual int soap_type() const { return 243; } /* = unique type id SOAP_TYPE_ns2__VideoEncoderOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoEncoderOptionsExtension() { ns2__VideoEncoderOptionsExtension::soap_default(NULL); }
	virtual ~ns2__VideoEncoderOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoEncoderOptionsExtension2
#define SOAP_TYPE_ns2__VideoEncoderOptionsExtension2 (244)
/* ns2:VideoEncoderOptionsExtension2 */
class SOAP_CMAC ns2__VideoEncoderOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 244; } /* = unique type id SOAP_TYPE_ns2__VideoEncoderOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoEncoderOptionsExtension2() { ns2__VideoEncoderOptionsExtension2::soap_default(NULL); }
	virtual ~ns2__VideoEncoderOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__JpegOptions
#define SOAP_TYPE_ns2__JpegOptions (245)
/* ns2:JpegOptions */
class SOAP_CMAC ns2__JpegOptions : public xsd__anyType
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	ns2__IntRange *FrameRateRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *EncodingIntervalRange;	/* required element of type ns2:IntRange */
public:
	virtual int soap_type() const { return 245; } /* = unique type id SOAP_TYPE_ns2__JpegOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__JpegOptions() { ns2__JpegOptions::soap_default(NULL); }
	virtual ~ns2__JpegOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Mpeg4Options
#define SOAP_TYPE_ns2__Mpeg4Options (247)
/* ns2:Mpeg4Options */
class SOAP_CMAC ns2__Mpeg4Options : public xsd__anyType
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	ns2__IntRange *GovLengthRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *FrameRateRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *EncodingIntervalRange;	/* required element of type ns2:IntRange */
	std::vector<enum ns2__Mpeg4Profile >Mpeg4ProfilesSupported;	/* required element of type ns2:Mpeg4Profile */
public:
	virtual int soap_type() const { return 247; } /* = unique type id SOAP_TYPE_ns2__Mpeg4Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Mpeg4Options() { ns2__Mpeg4Options::soap_default(NULL); }
	virtual ~ns2__Mpeg4Options() { }
};
#endif

#ifndef SOAP_TYPE_ns2__H264Options
#define SOAP_TYPE_ns2__H264Options (249)
/* ns2:H264Options */
class SOAP_CMAC ns2__H264Options : public xsd__anyType
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	ns2__IntRange *GovLengthRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *FrameRateRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *EncodingIntervalRange;	/* required element of type ns2:IntRange */
	std::vector<enum ns2__H264Profile >H264ProfilesSupported;	/* required element of type ns2:H264Profile */
public:
	virtual int soap_type() const { return 249; } /* = unique type id SOAP_TYPE_ns2__H264Options */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__H264Options() { ns2__H264Options::soap_default(NULL); }
	virtual ~ns2__H264Options() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioSourceConfigurationOptions
#define SOAP_TYPE_ns2__AudioSourceConfigurationOptions (252)
/* ns2:AudioSourceConfigurationOptions */
class SOAP_CMAC ns2__AudioSourceConfigurationOptions : public xsd__anyType
{
public:
	std::vector<std::string >InputTokensAvailable;	/* required element of type ns2:ReferenceToken */
	class ns2__AudioSourceOptionsExtension *Extension;	/* optional element of type ns2:AudioSourceOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 252; } /* = unique type id SOAP_TYPE_ns2__AudioSourceConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioSourceConfigurationOptions() { ns2__AudioSourceConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__AudioSourceConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioSourceOptionsExtension
#define SOAP_TYPE_ns2__AudioSourceOptionsExtension (253)
/* ns2:AudioSourceOptionsExtension */
class SOAP_CMAC ns2__AudioSourceOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 253; } /* = unique type id SOAP_TYPE_ns2__AudioSourceOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioSourceOptionsExtension() { ns2__AudioSourceOptionsExtension::soap_default(NULL); }
	virtual ~ns2__AudioSourceOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioEncoderConfigurationOptions
#define SOAP_TYPE_ns2__AudioEncoderConfigurationOptions (255)
/* ns2:AudioEncoderConfigurationOptions */
class SOAP_CMAC ns2__AudioEncoderConfigurationOptions : public xsd__anyType
{
public:
	std::vector<class ns2__AudioEncoderConfigurationOption * >Options;	/* optional element of type ns2:AudioEncoderConfigurationOption */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 255; } /* = unique type id SOAP_TYPE_ns2__AudioEncoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioEncoderConfigurationOptions() { ns2__AudioEncoderConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__AudioEncoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioEncoderConfigurationOption
#define SOAP_TYPE_ns2__AudioEncoderConfigurationOption (256)
/* ns2:AudioEncoderConfigurationOption */
class SOAP_CMAC ns2__AudioEncoderConfigurationOption : public xsd__anyType
{
public:
	enum ns2__AudioEncoding Encoding;	/* required element of type ns2:AudioEncoding */
	ns2__IntList *BitrateList;	/* required element of type ns2:IntList */
	ns2__IntList *SampleRateList;	/* required element of type ns2:IntList */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 256; } /* = unique type id SOAP_TYPE_ns2__AudioEncoderConfigurationOption */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioEncoderConfigurationOption() { ns2__AudioEncoderConfigurationOption::soap_default(NULL); }
	virtual ~ns2__AudioEncoderConfigurationOption() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataConfigurationExtension
#define SOAP_TYPE_ns2__MetadataConfigurationExtension (259)
/* ns2:MetadataConfigurationExtension */
class SOAP_CMAC ns2__MetadataConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 259; } /* = unique type id SOAP_TYPE_ns2__MetadataConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataConfigurationExtension() { ns2__MetadataConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__MetadataConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZFilter
#define SOAP_TYPE_ns2__PTZFilter (260)
/* ns2:PTZFilter */
class SOAP_CMAC ns2__PTZFilter : public xsd__anyType
{
public:
	bool Status;	/* required element of type xsd:boolean */
	bool Position;	/* required element of type xsd:boolean */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 260; } /* = unique type id SOAP_TYPE_ns2__PTZFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZFilter() { ns2__PTZFilter::soap_default(NULL); }
	virtual ~ns2__PTZFilter() { }
};
#endif

#ifndef SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy
#define SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy (1018)
/* ns2:EventSubscription-SubscriptionPolicy */
class SOAP_CMAC _ns2__EventSubscription_SubscriptionPolicy
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1018; } /* = unique type id SOAP_TYPE__ns2__EventSubscription_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__EventSubscription_SubscriptionPolicy() { _ns2__EventSubscription_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_ns2__EventSubscription_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EventSubscription
#define SOAP_TYPE_ns2__EventSubscription (261)
/* ns2:EventSubscription */
class SOAP_CMAC ns2__EventSubscription : public xsd__anyType
{
public:
	class ns3__FilterType *Filter;	/* optional element of type ns3:FilterType */
	_ns2__EventSubscription_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type ns2:EventSubscription-SubscriptionPolicy */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 261; } /* = unique type id SOAP_TYPE_ns2__EventSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EventSubscription() { ns2__EventSubscription::soap_default(NULL); }
	virtual ~ns2__EventSubscription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptions
#define SOAP_TYPE_ns2__MetadataConfigurationOptions (262)
/* ns2:MetadataConfigurationOptions */
class SOAP_CMAC ns2__MetadataConfigurationOptions : public xsd__anyType
{
public:
	class ns2__PTZStatusFilterOptions *PTZStatusFilterOptions;	/* required element of type ns2:PTZStatusFilterOptions */
	std::vector<char * >__any;
	class ns2__MetadataConfigurationOptionsExtension *Extension;	/* optional element of type ns2:MetadataConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 262; } /* = unique type id SOAP_TYPE_ns2__MetadataConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataConfigurationOptions() { ns2__MetadataConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__MetadataConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension
#define SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension (263)
/* ns2:MetadataConfigurationOptionsExtension */
class SOAP_CMAC ns2__MetadataConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<std::string >CompressionType;	/* optional element of type xsd:string */
	class ns2__MetadataConfigurationOptionsExtension2 *Extension;	/* optional element of type ns2:MetadataConfigurationOptionsExtension2 */
public:
	virtual int soap_type() const { return 263; } /* = unique type id SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataConfigurationOptionsExtension() { ns2__MetadataConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~ns2__MetadataConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2
#define SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2 (264)
/* ns2:MetadataConfigurationOptionsExtension2 */
class SOAP_CMAC ns2__MetadataConfigurationOptionsExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 264; } /* = unique type id SOAP_TYPE_ns2__MetadataConfigurationOptionsExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataConfigurationOptionsExtension2() { ns2__MetadataConfigurationOptionsExtension2::soap_default(NULL); }
	virtual ~ns2__MetadataConfigurationOptionsExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZStatusFilterOptions
#define SOAP_TYPE_ns2__PTZStatusFilterOptions (265)
/* ns2:PTZStatusFilterOptions */
class SOAP_CMAC ns2__PTZStatusFilterOptions : public xsd__anyType
{
public:
	bool PanTiltStatusSupported;	/* required element of type xsd:boolean */
	bool ZoomStatusSupported;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	bool *PanTiltPositionSupported;	/* optional element of type xsd:boolean */
	bool *ZoomPositionSupported;	/* optional element of type xsd:boolean */
	class ns2__PTZStatusFilterOptionsExtension *Extension;	/* optional element of type ns2:PTZStatusFilterOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 265; } /* = unique type id SOAP_TYPE_ns2__PTZStatusFilterOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZStatusFilterOptions() { ns2__PTZStatusFilterOptions::soap_default(NULL); }
	virtual ~ns2__PTZStatusFilterOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension
#define SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension (266)
/* ns2:PTZStatusFilterOptionsExtension */
class SOAP_CMAC ns2__PTZStatusFilterOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 266; } /* = unique type id SOAP_TYPE_ns2__PTZStatusFilterOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZStatusFilterOptionsExtension() { ns2__PTZStatusFilterOptionsExtension::soap_default(NULL); }
	virtual ~ns2__PTZStatusFilterOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoOutputExtension
#define SOAP_TYPE_ns2__VideoOutputExtension (268)
/* ns2:VideoOutputExtension */
class SOAP_CMAC ns2__VideoOutputExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 268; } /* = unique type id SOAP_TYPE_ns2__VideoOutputExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoOutputExtension() { ns2__VideoOutputExtension::soap_default(NULL); }
	virtual ~ns2__VideoOutputExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoOutputConfigurationOptions
#define SOAP_TYPE_ns2__VideoOutputConfigurationOptions (270)
/* ns2:VideoOutputConfigurationOptions */
class SOAP_CMAC ns2__VideoOutputConfigurationOptions : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 270; } /* = unique type id SOAP_TYPE_ns2__VideoOutputConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoOutputConfigurationOptions() { ns2__VideoOutputConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__VideoOutputConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoDecoderConfigurationOptions
#define SOAP_TYPE_ns2__VideoDecoderConfigurationOptions (271)
/* ns2:VideoDecoderConfigurationOptions */
class SOAP_CMAC ns2__VideoDecoderConfigurationOptions : public xsd__anyType
{
public:
	class ns2__JpegDecOptions *JpegDecOptions;	/* optional element of type ns2:JpegDecOptions */
	class ns2__H264DecOptions *H264DecOptions;	/* optional element of type ns2:H264DecOptions */
	class ns2__Mpeg4DecOptions *Mpeg4DecOptions;	/* optional element of type ns2:Mpeg4DecOptions */
	class ns2__VideoDecoderConfigurationOptionsExtension *Extension;	/* optional element of type ns2:VideoDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 271; } /* = unique type id SOAP_TYPE_ns2__VideoDecoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoDecoderConfigurationOptions() { ns2__VideoDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__VideoDecoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__H264DecOptions
#define SOAP_TYPE_ns2__H264DecOptions (272)
/* ns2:H264DecOptions */
class SOAP_CMAC ns2__H264DecOptions : public xsd__anyType
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	std::vector<enum ns2__H264Profile >SupportedH264Profiles;	/* required element of type ns2:H264Profile */
	ns2__IntRange *SupportedInputBitrate;	/* required element of type ns2:IntRange */
	ns2__IntRange *SupportedFrameRate;	/* required element of type ns2:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 272; } /* = unique type id SOAP_TYPE_ns2__H264DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__H264DecOptions() { ns2__H264DecOptions::soap_default(NULL); }
	virtual ~ns2__H264DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__JpegDecOptions
#define SOAP_TYPE_ns2__JpegDecOptions (273)
/* ns2:JpegDecOptions */
class SOAP_CMAC ns2__JpegDecOptions : public xsd__anyType
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	ns2__IntRange *SupportedInputBitrate;	/* required element of type ns2:IntRange */
	ns2__IntRange *SupportedFrameRate;	/* required element of type ns2:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 273; } /* = unique type id SOAP_TYPE_ns2__JpegDecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__JpegDecOptions() { ns2__JpegDecOptions::soap_default(NULL); }
	virtual ~ns2__JpegDecOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Mpeg4DecOptions
#define SOAP_TYPE_ns2__Mpeg4DecOptions (274)
/* ns2:Mpeg4DecOptions */
class SOAP_CMAC ns2__Mpeg4DecOptions : public xsd__anyType
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	std::vector<enum ns2__Mpeg4Profile >SupportedMpeg4Profiles;	/* required element of type ns2:Mpeg4Profile */
	ns2__IntRange *SupportedInputBitrate;	/* required element of type ns2:IntRange */
	ns2__IntRange *SupportedFrameRate;	/* required element of type ns2:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 274; } /* = unique type id SOAP_TYPE_ns2__Mpeg4DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Mpeg4DecOptions() { ns2__Mpeg4DecOptions::soap_default(NULL); }
	virtual ~ns2__Mpeg4DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension
#define SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension (275)
/* ns2:VideoDecoderConfigurationOptionsExtension */
class SOAP_CMAC ns2__VideoDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 275; } /* = unique type id SOAP_TYPE_ns2__VideoDecoderConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoDecoderConfigurationOptionsExtension() { ns2__VideoDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~ns2__VideoDecoderConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioOutputConfigurationOptions
#define SOAP_TYPE_ns2__AudioOutputConfigurationOptions (278)
/* ns2:AudioOutputConfigurationOptions */
class SOAP_CMAC ns2__AudioOutputConfigurationOptions : public xsd__anyType
{
public:
	std::vector<std::string >OutputTokensAvailable;	/* required element of type ns2:ReferenceToken */
	std::vector<std::string >SendPrimacyOptions;	/* optional element of type xsd:anyURI */
	ns2__IntRange *OutputLevelRange;	/* required element of type ns2:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 278; } /* = unique type id SOAP_TYPE_ns2__AudioOutputConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioOutputConfigurationOptions() { ns2__AudioOutputConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__AudioOutputConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioDecoderConfigurationOptions
#define SOAP_TYPE_ns2__AudioDecoderConfigurationOptions (280)
/* ns2:AudioDecoderConfigurationOptions */
class SOAP_CMAC ns2__AudioDecoderConfigurationOptions : public xsd__anyType
{
public:
	class ns2__AACDecOptions *AACDecOptions;	/* optional element of type ns2:AACDecOptions */
	class ns2__G711DecOptions *G711DecOptions;	/* optional element of type ns2:G711DecOptions */
	class ns2__G726DecOptions *G726DecOptions;	/* optional element of type ns2:G726DecOptions */
	class ns2__AudioDecoderConfigurationOptionsExtension *Extension;	/* optional element of type ns2:AudioDecoderConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 280; } /* = unique type id SOAP_TYPE_ns2__AudioDecoderConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioDecoderConfigurationOptions() { ns2__AudioDecoderConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__AudioDecoderConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__G711DecOptions
#define SOAP_TYPE_ns2__G711DecOptions (281)
/* ns2:G711DecOptions */
class SOAP_CMAC ns2__G711DecOptions : public xsd__anyType
{
public:
	ns2__IntList *Bitrate;	/* required element of type ns2:IntList */
	ns2__IntList *SampleRateRange;	/* required element of type ns2:IntList */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 281; } /* = unique type id SOAP_TYPE_ns2__G711DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__G711DecOptions() { ns2__G711DecOptions::soap_default(NULL); }
	virtual ~ns2__G711DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AACDecOptions
#define SOAP_TYPE_ns2__AACDecOptions (282)
/* ns2:AACDecOptions */
class SOAP_CMAC ns2__AACDecOptions : public xsd__anyType
{
public:
	ns2__IntList *Bitrate;	/* required element of type ns2:IntList */
	ns2__IntList *SampleRateRange;	/* required element of type ns2:IntList */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 282; } /* = unique type id SOAP_TYPE_ns2__AACDecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AACDecOptions() { ns2__AACDecOptions::soap_default(NULL); }
	virtual ~ns2__AACDecOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__G726DecOptions
#define SOAP_TYPE_ns2__G726DecOptions (283)
/* ns2:G726DecOptions */
class SOAP_CMAC ns2__G726DecOptions : public xsd__anyType
{
public:
	ns2__IntList *Bitrate;	/* required element of type ns2:IntList */
	ns2__IntList *SampleRateRange;	/* required element of type ns2:IntList */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 283; } /* = unique type id SOAP_TYPE_ns2__G726DecOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__G726DecOptions() { ns2__G726DecOptions::soap_default(NULL); }
	virtual ~ns2__G726DecOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension
#define SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension (284)
/* ns2:AudioDecoderConfigurationOptionsExtension */
class SOAP_CMAC ns2__AudioDecoderConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 284; } /* = unique type id SOAP_TYPE_ns2__AudioDecoderConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioDecoderConfigurationOptionsExtension() { ns2__AudioDecoderConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~ns2__AudioDecoderConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MulticastConfiguration
#define SOAP_TYPE_ns2__MulticastConfiguration (285)
/* ns2:MulticastConfiguration */
class SOAP_CMAC ns2__MulticastConfiguration : public xsd__anyType
{
public:
	class ns2__IPAddress *Address;	/* required element of type ns2:IPAddress */
	int Port;	/* required element of type xsd:int */
	int TTL;	/* required element of type xsd:int */
	bool AutoStart;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 285; } /* = unique type id SOAP_TYPE_ns2__MulticastConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MulticastConfiguration() { ns2__MulticastConfiguration::soap_default(NULL); }
	virtual ~ns2__MulticastConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__StreamSetup
#define SOAP_TYPE_ns2__StreamSetup (286)
/* ns2:StreamSetup */
class SOAP_CMAC ns2__StreamSetup : public xsd__anyType
{
public:
	enum ns2__StreamType Stream;	/* required element of type ns2:StreamType */
	class ns2__Transport *Transport;	/* required element of type ns2:Transport */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 286; } /* = unique type id SOAP_TYPE_ns2__StreamSetup */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__StreamSetup() { ns2__StreamSetup::soap_default(NULL); }
	virtual ~ns2__StreamSetup() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Transport
#define SOAP_TYPE_ns2__Transport (287)
/* ns2:Transport */
class SOAP_CMAC ns2__Transport : public xsd__anyType
{
public:
	enum ns2__TransportProtocol Protocol;	/* required element of type ns2:TransportProtocol */
	ns2__Transport *Tunnel;	/* optional element of type ns2:Transport */
public:
	virtual int soap_type() const { return 287; } /* = unique type id SOAP_TYPE_ns2__Transport */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Transport() { ns2__Transport::soap_default(NULL); }
	virtual ~ns2__Transport() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MediaUri
#define SOAP_TYPE_ns2__MediaUri (288)
/* ns2:MediaUri */
class SOAP_CMAC ns2__MediaUri : public xsd__anyType
{
public:
	std::string Uri;	/* required element of type xsd:anyURI */
	bool InvalidAfterConnect;	/* required element of type xsd:boolean */
	bool InvalidAfterReboot;	/* required element of type xsd:boolean */
	std::string Timeout;	/* required element of type xsd:duration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 288; } /* = unique type id SOAP_TYPE_ns2__MediaUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MediaUri() { ns2__MediaUri::soap_default(NULL); }
	virtual ~ns2__MediaUri() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Scope
#define SOAP_TYPE_ns2__Scope (289)
/* ns2:Scope */
class SOAP_CMAC ns2__Scope : public xsd__anyType
{
public:
	enum ns2__ScopeDefinition ScopeDef;	/* required element of type ns2:ScopeDefinition */
	std::string ScopeItem;	/* required element of type xsd:anyURI */
public:
	virtual int soap_type() const { return 289; } /* = unique type id SOAP_TYPE_ns2__Scope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Scope() { ns2__Scope::soap_default(NULL); }
	virtual ~ns2__Scope() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceExtension
#define SOAP_TYPE_ns2__NetworkInterfaceExtension (291)
/* ns2:NetworkInterfaceExtension */
class SOAP_CMAC ns2__NetworkInterfaceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	int InterfaceType;	/* required element of type ns2:IANA-IfTypes */
	std::vector<class ns2__Dot3Configuration * >Dot3;	/* optional element of type ns2:Dot3Configuration */
	std::vector<class ns2__Dot11Configuration * >Dot11;	/* optional element of type ns2:Dot11Configuration */
	class ns2__NetworkInterfaceExtension2 *Extension;	/* optional element of type ns2:NetworkInterfaceExtension2 */
public:
	virtual int soap_type() const { return 291; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceExtension() { ns2__NetworkInterfaceExtension::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot3Configuration
#define SOAP_TYPE_ns2__Dot3Configuration (292)
/* ns2:Dot3Configuration */
class SOAP_CMAC ns2__Dot3Configuration : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 292; } /* = unique type id SOAP_TYPE_ns2__Dot3Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot3Configuration() { ns2__Dot3Configuration::soap_default(NULL); }
	virtual ~ns2__Dot3Configuration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceExtension2
#define SOAP_TYPE_ns2__NetworkInterfaceExtension2 (293)
/* ns2:NetworkInterfaceExtension2 */
class SOAP_CMAC ns2__NetworkInterfaceExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 293; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceExtension2() { ns2__NetworkInterfaceExtension2::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceLink
#define SOAP_TYPE_ns2__NetworkInterfaceLink (294)
/* ns2:NetworkInterfaceLink */
class SOAP_CMAC ns2__NetworkInterfaceLink : public xsd__anyType
{
public:
	class ns2__NetworkInterfaceConnectionSetting *AdminSettings;	/* required element of type ns2:NetworkInterfaceConnectionSetting */
	ns2__NetworkInterfaceConnectionSetting *OperSettings;	/* required element of type ns2:NetworkInterfaceConnectionSetting */
	int InterfaceType;	/* required element of type ns2:IANA-IfTypes */
public:
	virtual int soap_type() const { return 294; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceLink */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceLink() { ns2__NetworkInterfaceLink::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceLink() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting
#define SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting (295)
/* ns2:NetworkInterfaceConnectionSetting */
class SOAP_CMAC ns2__NetworkInterfaceConnectionSetting : public xsd__anyType
{
public:
	bool AutoNegotiation;	/* required element of type xsd:boolean */
	int Speed;	/* required element of type xsd:int */
	enum ns2__Duplex Duplex;	/* required element of type ns2:Duplex */
public:
	virtual int soap_type() const { return 295; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceConnectionSetting */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceConnectionSetting() { ns2__NetworkInterfaceConnectionSetting::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceConnectionSetting() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceInfo
#define SOAP_TYPE_ns2__NetworkInterfaceInfo (296)
/* ns2:NetworkInterfaceInfo */
class SOAP_CMAC ns2__NetworkInterfaceInfo : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type xsd:string */
	std::string HwAddress;	/* required element of type ns2:HwAddress */
	int *MTU;	/* optional element of type xsd:int */
public:
	virtual int soap_type() const { return 296; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceInfo() { ns2__NetworkInterfaceInfo::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv6NetworkInterface
#define SOAP_TYPE_ns2__IPv6NetworkInterface (297)
/* ns2:IPv6NetworkInterface */
class SOAP_CMAC ns2__IPv6NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class ns2__IPv6Configuration *Config;	/* optional element of type ns2:IPv6Configuration */
public:
	virtual int soap_type() const { return 297; } /* = unique type id SOAP_TYPE_ns2__IPv6NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv6NetworkInterface() { ns2__IPv6NetworkInterface::soap_default(NULL); }
	virtual ~ns2__IPv6NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv4NetworkInterface
#define SOAP_TYPE_ns2__IPv4NetworkInterface (298)
/* ns2:IPv4NetworkInterface */
class SOAP_CMAC ns2__IPv4NetworkInterface : public xsd__anyType
{
public:
	bool Enabled;	/* required element of type xsd:boolean */
	class ns2__IPv4Configuration *Config;	/* required element of type ns2:IPv4Configuration */
public:
	virtual int soap_type() const { return 298; } /* = unique type id SOAP_TYPE_ns2__IPv4NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv4NetworkInterface() { ns2__IPv4NetworkInterface::soap_default(NULL); }
	virtual ~ns2__IPv4NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv4Configuration
#define SOAP_TYPE_ns2__IPv4Configuration (299)
/* ns2:IPv4Configuration */
class SOAP_CMAC ns2__IPv4Configuration : public xsd__anyType
{
public:
	std::vector<class ns2__PrefixedIPv4Address * >Manual;	/* optional element of type ns2:PrefixedIPv4Address */
	ns2__PrefixedIPv4Address *LinkLocal;	/* optional element of type ns2:PrefixedIPv4Address */
	ns2__PrefixedIPv4Address *FromDHCP;	/* optional element of type ns2:PrefixedIPv4Address */
	bool DHCP;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 299; } /* = unique type id SOAP_TYPE_ns2__IPv4Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv4Configuration() { ns2__IPv4Configuration::soap_default(NULL); }
	virtual ~ns2__IPv4Configuration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv6Configuration
#define SOAP_TYPE_ns2__IPv6Configuration (300)
/* ns2:IPv6Configuration */
class SOAP_CMAC ns2__IPv6Configuration : public xsd__anyType
{
public:
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	enum ns2__IPv6DHCPConfiguration DHCP;	/* required element of type ns2:IPv6DHCPConfiguration */
	std::vector<class ns2__PrefixedIPv6Address * >Manual;	/* optional element of type ns2:PrefixedIPv6Address */
	std::vector<ns2__PrefixedIPv6Address * >LinkLocal;	/* optional element of type ns2:PrefixedIPv6Address */
	std::vector<ns2__PrefixedIPv6Address * >FromDHCP;	/* optional element of type ns2:PrefixedIPv6Address */
	std::vector<ns2__PrefixedIPv6Address * >FromRA;	/* optional element of type ns2:PrefixedIPv6Address */
	class ns2__IPv6ConfigurationExtension *Extension;	/* optional element of type ns2:IPv6ConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 300; } /* = unique type id SOAP_TYPE_ns2__IPv6Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv6Configuration() { ns2__IPv6Configuration::soap_default(NULL); }
	virtual ~ns2__IPv6Configuration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv6ConfigurationExtension
#define SOAP_TYPE_ns2__IPv6ConfigurationExtension (301)
/* ns2:IPv6ConfigurationExtension */
class SOAP_CMAC ns2__IPv6ConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 301; } /* = unique type id SOAP_TYPE_ns2__IPv6ConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv6ConfigurationExtension() { ns2__IPv6ConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__IPv6ConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkProtocol
#define SOAP_TYPE_ns2__NetworkProtocol (302)
/* ns2:NetworkProtocol */
class SOAP_CMAC ns2__NetworkProtocol : public xsd__anyType
{
public:
	enum ns2__NetworkProtocolType Name;	/* required element of type ns2:NetworkProtocolType */
	bool Enabled;	/* required element of type xsd:boolean */
	std::vector<int >Port;	/* required element of type xsd:int */
	class ns2__NetworkProtocolExtension *Extension;	/* optional element of type ns2:NetworkProtocolExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 302; } /* = unique type id SOAP_TYPE_ns2__NetworkProtocol */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkProtocol() { ns2__NetworkProtocol::soap_default(NULL); }
	virtual ~ns2__NetworkProtocol() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkProtocolExtension
#define SOAP_TYPE_ns2__NetworkProtocolExtension (303)
/* ns2:NetworkProtocolExtension */
class SOAP_CMAC ns2__NetworkProtocolExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 303; } /* = unique type id SOAP_TYPE_ns2__NetworkProtocolExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkProtocolExtension() { ns2__NetworkProtocolExtension::soap_default(NULL); }
	virtual ~ns2__NetworkProtocolExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkHost
#define SOAP_TYPE_ns2__NetworkHost (304)
/* ns2:NetworkHost */
class SOAP_CMAC ns2__NetworkHost : public xsd__anyType
{
public:
	enum ns2__NetworkHostType Type;	/* required element of type ns2:NetworkHostType */
	std::string *IPv4Address;	/* optional element of type ns2:IPv4Address */
	std::string *IPv6Address;	/* optional element of type ns2:IPv6Address */
	std::string *DNSname;	/* optional element of type ns2:DNSName */
	class ns2__NetworkHostExtension *Extension;	/* optional element of type ns2:NetworkHostExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 304; } /* = unique type id SOAP_TYPE_ns2__NetworkHost */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkHost() { ns2__NetworkHost::soap_default(NULL); }
	virtual ~ns2__NetworkHost() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkHostExtension
#define SOAP_TYPE_ns2__NetworkHostExtension (305)
/* ns2:NetworkHostExtension */
class SOAP_CMAC ns2__NetworkHostExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 305; } /* = unique type id SOAP_TYPE_ns2__NetworkHostExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkHostExtension() { ns2__NetworkHostExtension::soap_default(NULL); }
	virtual ~ns2__NetworkHostExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPAddress
#define SOAP_TYPE_ns2__IPAddress (306)
/* ns2:IPAddress */
class SOAP_CMAC ns2__IPAddress : public xsd__anyType
{
public:
	enum ns2__IPType Type;	/* required element of type ns2:IPType */
	std::string *IPv4Address;	/* optional element of type ns2:IPv4Address */
	std::string *IPv6Address;	/* optional element of type ns2:IPv6Address */
public:
	virtual int soap_type() const { return 306; } /* = unique type id SOAP_TYPE_ns2__IPAddress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPAddress() { ns2__IPAddress::soap_default(NULL); }
	virtual ~ns2__IPAddress() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PrefixedIPv4Address
#define SOAP_TYPE_ns2__PrefixedIPv4Address (307)
/* ns2:PrefixedIPv4Address */
class SOAP_CMAC ns2__PrefixedIPv4Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of type ns2:IPv4Address */
	int PrefixLength;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 307; } /* = unique type id SOAP_TYPE_ns2__PrefixedIPv4Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PrefixedIPv4Address() { ns2__PrefixedIPv4Address::soap_default(NULL); }
	virtual ~ns2__PrefixedIPv4Address() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PrefixedIPv6Address
#define SOAP_TYPE_ns2__PrefixedIPv6Address (308)
/* ns2:PrefixedIPv6Address */
class SOAP_CMAC ns2__PrefixedIPv6Address : public xsd__anyType
{
public:
	std::string Address;	/* required element of type ns2:IPv6Address */
	int PrefixLength;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 308; } /* = unique type id SOAP_TYPE_ns2__PrefixedIPv6Address */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PrefixedIPv6Address() { ns2__PrefixedIPv6Address::soap_default(NULL); }
	virtual ~ns2__PrefixedIPv6Address() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HostnameInformation
#define SOAP_TYPE_ns2__HostnameInformation (309)
/* ns2:HostnameInformation */
class SOAP_CMAC ns2__HostnameInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::string *Name;	/* optional element of type xsd:token */
	class ns2__HostnameInformationExtension *Extension;	/* optional element of type ns2:HostnameInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 309; } /* = unique type id SOAP_TYPE_ns2__HostnameInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HostnameInformation() { ns2__HostnameInformation::soap_default(NULL); }
	virtual ~ns2__HostnameInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__HostnameInformationExtension
#define SOAP_TYPE_ns2__HostnameInformationExtension (310)
/* ns2:HostnameInformationExtension */
class SOAP_CMAC ns2__HostnameInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 310; } /* = unique type id SOAP_TYPE_ns2__HostnameInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__HostnameInformationExtension() { ns2__HostnameInformationExtension::soap_default(NULL); }
	virtual ~ns2__HostnameInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DNSInformation
#define SOAP_TYPE_ns2__DNSInformation (311)
/* ns2:DNSInformation */
class SOAP_CMAC ns2__DNSInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<std::string >SearchDomain;	/* optional element of type xsd:token */
	std::vector<ns2__IPAddress * >DNSFromDHCP;	/* optional element of type ns2:IPAddress */
	std::vector<ns2__IPAddress * >DNSManual;	/* optional element of type ns2:IPAddress */
	class ns2__DNSInformationExtension *Extension;	/* optional element of type ns2:DNSInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 311; } /* = unique type id SOAP_TYPE_ns2__DNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DNSInformation() { ns2__DNSInformation::soap_default(NULL); }
	virtual ~ns2__DNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DNSInformationExtension
#define SOAP_TYPE_ns2__DNSInformationExtension (312)
/* ns2:DNSInformationExtension */
class SOAP_CMAC ns2__DNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 312; } /* = unique type id SOAP_TYPE_ns2__DNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DNSInformationExtension() { ns2__DNSInformationExtension::soap_default(NULL); }
	virtual ~ns2__DNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NTPInformation
#define SOAP_TYPE_ns2__NTPInformation (313)
/* ns2:NTPInformation */
class SOAP_CMAC ns2__NTPInformation : public xsd__anyType
{
public:
	bool FromDHCP;	/* required element of type xsd:boolean */
	std::vector<ns2__NetworkHost * >NTPFromDHCP;	/* optional element of type ns2:NetworkHost */
	std::vector<ns2__NetworkHost * >NTPManual;	/* optional element of type ns2:NetworkHost */
	class ns2__NTPInformationExtension *Extension;	/* optional element of type ns2:NTPInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 313; } /* = unique type id SOAP_TYPE_ns2__NTPInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NTPInformation() { ns2__NTPInformation::soap_default(NULL); }
	virtual ~ns2__NTPInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NTPInformationExtension
#define SOAP_TYPE_ns2__NTPInformationExtension (314)
/* ns2:NTPInformationExtension */
class SOAP_CMAC ns2__NTPInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 314; } /* = unique type id SOAP_TYPE_ns2__NTPInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NTPInformationExtension() { ns2__NTPInformationExtension::soap_default(NULL); }
	virtual ~ns2__NTPInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DynamicDNSInformation
#define SOAP_TYPE_ns2__DynamicDNSInformation (315)
/* ns2:DynamicDNSInformation */
class SOAP_CMAC ns2__DynamicDNSInformation : public xsd__anyType
{
public:
	enum ns2__DynamicDNSType Type;	/* required element of type ns2:DynamicDNSType */
	std::string *Name;	/* optional element of type ns2:DNSName */
	std::string *TTL;	/* optional element of type xsd:duration */
	class ns2__DynamicDNSInformationExtension *Extension;	/* optional element of type ns2:DynamicDNSInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 315; } /* = unique type id SOAP_TYPE_ns2__DynamicDNSInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DynamicDNSInformation() { ns2__DynamicDNSInformation::soap_default(NULL); }
	virtual ~ns2__DynamicDNSInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DynamicDNSInformationExtension
#define SOAP_TYPE_ns2__DynamicDNSInformationExtension (316)
/* ns2:DynamicDNSInformationExtension */
class SOAP_CMAC ns2__DynamicDNSInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 316; } /* = unique type id SOAP_TYPE_ns2__DynamicDNSInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DynamicDNSInformationExtension() { ns2__DynamicDNSInformationExtension::soap_default(NULL); }
	virtual ~ns2__DynamicDNSInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration (317)
/* ns2:NetworkInterfaceSetConfiguration */
class SOAP_CMAC ns2__NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	ns2__NetworkInterfaceConnectionSetting *Link;	/* optional element of type ns2:NetworkInterfaceConnectionSetting */
	int *MTU;	/* optional element of type xsd:int */
	class ns2__IPv4NetworkInterfaceSetConfiguration *IPv4;	/* optional element of type ns2:IPv4NetworkInterfaceSetConfiguration */
	class ns2__IPv6NetworkInterfaceSetConfiguration *IPv6;	/* optional element of type ns2:IPv6NetworkInterfaceSetConfiguration */
	class ns2__NetworkInterfaceSetConfigurationExtension *Extension;	/* optional element of type ns2:NetworkInterfaceSetConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 317; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceSetConfiguration() { ns2__NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension (318)
/* ns2:NetworkInterfaceSetConfigurationExtension */
class SOAP_CMAC ns2__NetworkInterfaceSetConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::vector<ns2__Dot3Configuration * >Dot3;	/* optional element of type ns2:Dot3Configuration */
	std::vector<ns2__Dot11Configuration * >Dot11;	/* optional element of type ns2:Dot11Configuration */
	class ns2__NetworkInterfaceSetConfigurationExtension2 *Extension;	/* optional element of type ns2:NetworkInterfaceSetConfigurationExtension2 */
public:
	virtual int soap_type() const { return 318; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceSetConfigurationExtension() { ns2__NetworkInterfaceSetConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceSetConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration (319)
/* ns2:IPv6NetworkInterfaceSetConfiguration */
class SOAP_CMAC ns2__IPv6NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	bool *AcceptRouterAdvert;	/* optional element of type xsd:boolean */
	std::vector<ns2__PrefixedIPv6Address * >Manual;	/* optional element of type ns2:PrefixedIPv6Address */
	enum ns2__IPv6DHCPConfiguration *DHCP;	/* optional element of type ns2:IPv6DHCPConfiguration */
public:
	virtual int soap_type() const { return 319; } /* = unique type id SOAP_TYPE_ns2__IPv6NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv6NetworkInterfaceSetConfiguration() { ns2__IPv6NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~ns2__IPv6NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration
#define SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration (320)
/* ns2:IPv4NetworkInterfaceSetConfiguration */
class SOAP_CMAC ns2__IPv4NetworkInterfaceSetConfiguration : public xsd__anyType
{
public:
	bool *Enabled;	/* optional element of type xsd:boolean */
	std::vector<ns2__PrefixedIPv4Address * >Manual;	/* optional element of type ns2:PrefixedIPv4Address */
	bool *DHCP;	/* optional element of type xsd:boolean */
public:
	virtual int soap_type() const { return 320; } /* = unique type id SOAP_TYPE_ns2__IPv4NetworkInterfaceSetConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPv4NetworkInterfaceSetConfiguration() { ns2__IPv4NetworkInterfaceSetConfiguration::soap_default(NULL); }
	virtual ~ns2__IPv4NetworkInterfaceSetConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkGateway
#define SOAP_TYPE_ns2__NetworkGateway (321)
/* ns2:NetworkGateway */
class SOAP_CMAC ns2__NetworkGateway : public xsd__anyType
{
public:
	std::vector<std::string >IPv4Address;	/* optional element of type ns2:IPv4Address */
	std::vector<std::string >IPv6Address;	/* optional element of type ns2:IPv6Address */
public:
	virtual int soap_type() const { return 321; } /* = unique type id SOAP_TYPE_ns2__NetworkGateway */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkGateway() { ns2__NetworkGateway::soap_default(NULL); }
	virtual ~ns2__NetworkGateway() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkZeroConfiguration
#define SOAP_TYPE_ns2__NetworkZeroConfiguration (322)
/* ns2:NetworkZeroConfiguration */
class SOAP_CMAC ns2__NetworkZeroConfiguration : public xsd__anyType
{
public:
	std::string InterfaceToken;	/* required element of type ns2:ReferenceToken */
	bool Enabled;	/* required element of type xsd:boolean */
	std::vector<std::string >Addresses;	/* optional element of type ns2:IPv4Address */
	class ns2__NetworkZeroConfigurationExtension *Extension;	/* optional element of type ns2:NetworkZeroConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 322; } /* = unique type id SOAP_TYPE_ns2__NetworkZeroConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkZeroConfiguration() { ns2__NetworkZeroConfiguration::soap_default(NULL); }
	virtual ~ns2__NetworkZeroConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkZeroConfigurationExtension
#define SOAP_TYPE_ns2__NetworkZeroConfigurationExtension (323)
/* ns2:NetworkZeroConfigurationExtension */
class SOAP_CMAC ns2__NetworkZeroConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::vector<ns2__NetworkZeroConfiguration * >Additional;	/* optional element of type ns2:NetworkZeroConfiguration */
	class ns2__NetworkZeroConfigurationExtension2 *Extension;	/* optional element of type ns2:NetworkZeroConfigurationExtension2 */
public:
	virtual int soap_type() const { return 323; } /* = unique type id SOAP_TYPE_ns2__NetworkZeroConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkZeroConfigurationExtension() { ns2__NetworkZeroConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__NetworkZeroConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2
#define SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2 (324)
/* ns2:NetworkZeroConfigurationExtension2 */
class SOAP_CMAC ns2__NetworkZeroConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 324; } /* = unique type id SOAP_TYPE_ns2__NetworkZeroConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkZeroConfigurationExtension2() { ns2__NetworkZeroConfigurationExtension2::soap_default(NULL); }
	virtual ~ns2__NetworkZeroConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPAddressFilter
#define SOAP_TYPE_ns2__IPAddressFilter (325)
/* ns2:IPAddressFilter */
class SOAP_CMAC ns2__IPAddressFilter : public xsd__anyType
{
public:
	enum ns2__IPAddressFilterType Type;	/* required element of type ns2:IPAddressFilterType */
	std::vector<ns2__PrefixedIPv4Address * >IPv4Address;	/* optional element of type ns2:PrefixedIPv4Address */
	std::vector<ns2__PrefixedIPv6Address * >IPv6Address;	/* optional element of type ns2:PrefixedIPv6Address */
	class ns2__IPAddressFilterExtension *Extension;	/* optional element of type ns2:IPAddressFilterExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 325; } /* = unique type id SOAP_TYPE_ns2__IPAddressFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPAddressFilter() { ns2__IPAddressFilter::soap_default(NULL); }
	virtual ~ns2__IPAddressFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IPAddressFilterExtension
#define SOAP_TYPE_ns2__IPAddressFilterExtension (326)
/* ns2:IPAddressFilterExtension */
class SOAP_CMAC ns2__IPAddressFilterExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 326; } /* = unique type id SOAP_TYPE_ns2__IPAddressFilterExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IPAddressFilterExtension() { ns2__IPAddressFilterExtension::soap_default(NULL); }
	virtual ~ns2__IPAddressFilterExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11Configuration
#define SOAP_TYPE_ns2__Dot11Configuration (327)
/* ns2:Dot11Configuration */
class SOAP_CMAC ns2__Dot11Configuration : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of type ns2:Dot11SSIDType */
	enum ns2__Dot11StationMode Mode;	/* required element of type ns2:Dot11StationMode */
	std::string Alias;	/* required element of type ns2:Name */
	std::string Priority;	/* required element of type ns2:NetworkInterfaceConfigPriority */
	class ns2__Dot11SecurityConfiguration *Security;	/* required element of type ns2:Dot11SecurityConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 327; } /* = unique type id SOAP_TYPE_ns2__Dot11Configuration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11Configuration() { ns2__Dot11Configuration::soap_default(NULL); }
	virtual ~ns2__Dot11Configuration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11SecurityConfiguration
#define SOAP_TYPE_ns2__Dot11SecurityConfiguration (328)
/* ns2:Dot11SecurityConfiguration */
class SOAP_CMAC ns2__Dot11SecurityConfiguration : public xsd__anyType
{
public:
	enum ns2__Dot11SecurityMode Mode;	/* required element of type ns2:Dot11SecurityMode */
	enum ns2__Dot11Cipher *Algorithm;	/* optional element of type ns2:Dot11Cipher */
	class ns2__Dot11PSKSet *PSK;	/* optional element of type ns2:Dot11PSKSet */
	std::string *Dot1X;	/* optional element of type ns2:ReferenceToken */
	class ns2__Dot11SecurityConfigurationExtension *Extension;	/* optional element of type ns2:Dot11SecurityConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 328; } /* = unique type id SOAP_TYPE_ns2__Dot11SecurityConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11SecurityConfiguration() { ns2__Dot11SecurityConfiguration::soap_default(NULL); }
	virtual ~ns2__Dot11SecurityConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension
#define SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension (329)
/* ns2:Dot11SecurityConfigurationExtension */
class SOAP_CMAC ns2__Dot11SecurityConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 329; } /* = unique type id SOAP_TYPE_ns2__Dot11SecurityConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11SecurityConfigurationExtension() { ns2__Dot11SecurityConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__Dot11SecurityConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11PSKSet
#define SOAP_TYPE_ns2__Dot11PSKSet (330)
/* ns2:Dot11PSKSet */
class SOAP_CMAC ns2__Dot11PSKSet : public xsd__anyType
{
public:
	xsd__hexBinary *Key;	/* optional element of type ns2:Dot11PSK */
	std::string *Passphrase;	/* optional element of type ns2:Dot11PSKPassphrase */
	class ns2__Dot11PSKSetExtension *Extension;	/* optional element of type ns2:Dot11PSKSetExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 330; } /* = unique type id SOAP_TYPE_ns2__Dot11PSKSet */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11PSKSet() { ns2__Dot11PSKSet::soap_default(NULL); }
	virtual ~ns2__Dot11PSKSet() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11PSKSetExtension
#define SOAP_TYPE_ns2__Dot11PSKSetExtension (331)
/* ns2:Dot11PSKSetExtension */
class SOAP_CMAC ns2__Dot11PSKSetExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 331; } /* = unique type id SOAP_TYPE_ns2__Dot11PSKSetExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11PSKSetExtension() { ns2__Dot11PSKSetExtension::soap_default(NULL); }
	virtual ~ns2__Dot11PSKSetExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2
#define SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2 (332)
/* ns2:NetworkInterfaceSetConfigurationExtension2 */
class SOAP_CMAC ns2__NetworkInterfaceSetConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 332; } /* = unique type id SOAP_TYPE_ns2__NetworkInterfaceSetConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterfaceSetConfigurationExtension2() { ns2__NetworkInterfaceSetConfigurationExtension2::soap_default(NULL); }
	virtual ~ns2__NetworkInterfaceSetConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11Capabilities
#define SOAP_TYPE_ns2__Dot11Capabilities (333)
/* ns2:Dot11Capabilities */
class SOAP_CMAC ns2__Dot11Capabilities : public xsd__anyType
{
public:
	bool TKIP;	/* required element of type xsd:boolean */
	bool ScanAvailableNetworks;	/* required element of type xsd:boolean */
	bool MultipleConfiguration;	/* required element of type xsd:boolean */
	bool AdHocStationMode;	/* required element of type xsd:boolean */
	bool WEP;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 333; } /* = unique type id SOAP_TYPE_ns2__Dot11Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11Capabilities() { ns2__Dot11Capabilities::soap_default(NULL); }
	virtual ~ns2__Dot11Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11Status
#define SOAP_TYPE_ns2__Dot11Status (334)
/* ns2:Dot11Status */
class SOAP_CMAC ns2__Dot11Status : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of type ns2:Dot11SSIDType */
	std::string *BSSID;	/* optional element of type xsd:string */
	enum ns2__Dot11Cipher *PairCipher;	/* optional element of type ns2:Dot11Cipher */
	enum ns2__Dot11Cipher *GroupCipher;	/* optional element of type ns2:Dot11Cipher */
	enum ns2__Dot11SignalStrength *SignalStrength;	/* optional element of type ns2:Dot11SignalStrength */
	std::string ActiveConfigAlias;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 334; } /* = unique type id SOAP_TYPE_ns2__Dot11Status */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11Status() { ns2__Dot11Status::soap_default(NULL); }
	virtual ~ns2__Dot11Status() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11AvailableNetworks
#define SOAP_TYPE_ns2__Dot11AvailableNetworks (335)
/* ns2:Dot11AvailableNetworks */
class SOAP_CMAC ns2__Dot11AvailableNetworks : public xsd__anyType
{
public:
	xsd__hexBinary SSID;	/* required element of type ns2:Dot11SSIDType */
	std::string *BSSID;	/* optional element of type xsd:string */
	std::vector<enum ns2__Dot11AuthAndMangementSuite >AuthAndMangementSuite;	/* optional element of type ns2:Dot11AuthAndMangementSuite */
	std::vector<enum ns2__Dot11Cipher >PairCipher;	/* optional element of type ns2:Dot11Cipher */
	std::vector<enum ns2__Dot11Cipher >GroupCipher;	/* optional element of type ns2:Dot11Cipher */
	enum ns2__Dot11SignalStrength *SignalStrength;	/* optional element of type ns2:Dot11SignalStrength */
	class ns2__Dot11AvailableNetworksExtension *Extension;	/* optional element of type ns2:Dot11AvailableNetworksExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 335; } /* = unique type id SOAP_TYPE_ns2__Dot11AvailableNetworks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11AvailableNetworks() { ns2__Dot11AvailableNetworks::soap_default(NULL); }
	virtual ~ns2__Dot11AvailableNetworks() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot11AvailableNetworksExtension
#define SOAP_TYPE_ns2__Dot11AvailableNetworksExtension (336)
/* ns2:Dot11AvailableNetworksExtension */
class SOAP_CMAC ns2__Dot11AvailableNetworksExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 336; } /* = unique type id SOAP_TYPE_ns2__Dot11AvailableNetworksExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot11AvailableNetworksExtension() { ns2__Dot11AvailableNetworksExtension::soap_default(NULL); }
	virtual ~ns2__Dot11AvailableNetworksExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Capabilities
#define SOAP_TYPE_ns2__Capabilities (337)
/* ns2:Capabilities */
class SOAP_CMAC ns2__Capabilities : public xsd__anyType
{
public:
	class ns2__AnalyticsCapabilities *Analytics;	/* optional element of type ns2:AnalyticsCapabilities */
	class ns2__DeviceCapabilities *Device;	/* optional element of type ns2:DeviceCapabilities */
	class ns2__EventCapabilities *Events;	/* optional element of type ns2:EventCapabilities */
	class ns2__ImagingCapabilities *Imaging;	/* optional element of type ns2:ImagingCapabilities */
	class ns2__MediaCapabilities *Media;	/* optional element of type ns2:MediaCapabilities */
	class ns2__PTZCapabilities *PTZ;	/* optional element of type ns2:PTZCapabilities */
	class ns2__CapabilitiesExtension *Extension;	/* optional element of type ns2:CapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 337; } /* = unique type id SOAP_TYPE_ns2__Capabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Capabilities() { ns2__Capabilities::soap_default(NULL); }
	virtual ~ns2__Capabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CapabilitiesExtension
#define SOAP_TYPE_ns2__CapabilitiesExtension (338)
/* ns2:CapabilitiesExtension */
class SOAP_CMAC ns2__CapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__DeviceIOCapabilities *DeviceIO;	/* optional element of type ns2:DeviceIOCapabilities */
	class ns2__DisplayCapabilities *Display;	/* optional element of type ns2:DisplayCapabilities */
	class ns2__RecordingCapabilities *Recording;	/* optional element of type ns2:RecordingCapabilities */
	class ns2__SearchCapabilities *Search;	/* optional element of type ns2:SearchCapabilities */
	class ns2__ReplayCapabilities *Replay;	/* optional element of type ns2:ReplayCapabilities */
	class ns2__ReceiverCapabilities *Receiver;	/* optional element of type ns2:ReceiverCapabilities */
	class ns2__AnalyticsDeviceCapabilities *AnalyticsDevice;	/* optional element of type ns2:AnalyticsDeviceCapabilities */
	class ns2__CapabilitiesExtension2 *Extensions;	/* optional element of type ns2:CapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 338; } /* = unique type id SOAP_TYPE_ns2__CapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CapabilitiesExtension() { ns2__CapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__CapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CapabilitiesExtension2
#define SOAP_TYPE_ns2__CapabilitiesExtension2 (339)
/* ns2:CapabilitiesExtension2 */
class SOAP_CMAC ns2__CapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 339; } /* = unique type id SOAP_TYPE_ns2__CapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CapabilitiesExtension2() { ns2__CapabilitiesExtension2::soap_default(NULL); }
	virtual ~ns2__CapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsCapabilities
#define SOAP_TYPE_ns2__AnalyticsCapabilities (340)
/* ns2:AnalyticsCapabilities */
class SOAP_CMAC ns2__AnalyticsCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool RuleSupport;	/* required element of type xsd:boolean */
	bool AnalyticsModuleSupport;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 340; } /* = unique type id SOAP_TYPE_ns2__AnalyticsCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsCapabilities() { ns2__AnalyticsCapabilities::soap_default(NULL); }
	virtual ~ns2__AnalyticsCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DeviceCapabilities
#define SOAP_TYPE_ns2__DeviceCapabilities (341)
/* ns2:DeviceCapabilities */
class SOAP_CMAC ns2__DeviceCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	class ns2__NetworkCapabilities *Network;	/* optional element of type ns2:NetworkCapabilities */
	class ns2__SystemCapabilities *System;	/* optional element of type ns2:SystemCapabilities */
	class ns2__IOCapabilities *IO;	/* optional element of type ns2:IOCapabilities */
	class ns2__SecurityCapabilities *Security;	/* optional element of type ns2:SecurityCapabilities */
	class ns2__DeviceCapabilitiesExtension *Extension;	/* optional element of type ns2:DeviceCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 341; } /* = unique type id SOAP_TYPE_ns2__DeviceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DeviceCapabilities() { ns2__DeviceCapabilities::soap_default(NULL); }
	virtual ~ns2__DeviceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DeviceCapabilitiesExtension
#define SOAP_TYPE_ns2__DeviceCapabilitiesExtension (342)
/* ns2:DeviceCapabilitiesExtension */
class SOAP_CMAC ns2__DeviceCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 342; } /* = unique type id SOAP_TYPE_ns2__DeviceCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DeviceCapabilitiesExtension() { ns2__DeviceCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__DeviceCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EventCapabilities
#define SOAP_TYPE_ns2__EventCapabilities (343)
/* ns2:EventCapabilities */
class SOAP_CMAC ns2__EventCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool WSSubscriptionPolicySupport;	/* required element of type xsd:boolean */
	bool WSPullPointSupport;	/* required element of type xsd:boolean */
	bool WSPausableSubscriptionManagerInterfaceSupport;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 343; } /* = unique type id SOAP_TYPE_ns2__EventCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EventCapabilities() { ns2__EventCapabilities::soap_default(NULL); }
	virtual ~ns2__EventCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IOCapabilities
#define SOAP_TYPE_ns2__IOCapabilities (344)
/* ns2:IOCapabilities */
class SOAP_CMAC ns2__IOCapabilities : public xsd__anyType
{
public:
	int *InputConnectors;	/* optional element of type xsd:int */
	int *RelayOutputs;	/* optional element of type xsd:int */
	class ns2__IOCapabilitiesExtension *Extension;	/* optional element of type ns2:IOCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 344; } /* = unique type id SOAP_TYPE_ns2__IOCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IOCapabilities() { ns2__IOCapabilities::soap_default(NULL); }
	virtual ~ns2__IOCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IOCapabilitiesExtension
#define SOAP_TYPE_ns2__IOCapabilitiesExtension (345)
/* ns2:IOCapabilitiesExtension */
class SOAP_CMAC ns2__IOCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *Auxiliary;	/* optional element of type xsd:boolean */
	std::vector<std::string >AuxiliaryCommands;	/* optional element of type ns2:AuxiliaryData */
	class ns2__IOCapabilitiesExtension2 *Extension;	/* required element of type ns2:IOCapabilitiesExtension2 */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 345; } /* = unique type id SOAP_TYPE_ns2__IOCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IOCapabilitiesExtension() { ns2__IOCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__IOCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IOCapabilitiesExtension2
#define SOAP_TYPE_ns2__IOCapabilitiesExtension2 (346)
/* ns2:IOCapabilitiesExtension2 */
class SOAP_CMAC ns2__IOCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 346; } /* = unique type id SOAP_TYPE_ns2__IOCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IOCapabilitiesExtension2() { ns2__IOCapabilitiesExtension2::soap_default(NULL); }
	virtual ~ns2__IOCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MediaCapabilities
#define SOAP_TYPE_ns2__MediaCapabilities (347)
/* ns2:MediaCapabilities */
class SOAP_CMAC ns2__MediaCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	class ns2__RealTimeStreamingCapabilities *StreamingCapabilities;	/* required element of type ns2:RealTimeStreamingCapabilities */
	std::vector<char * >__any;
	class ns2__MediaCapabilitiesExtension *Extension;	/* optional element of type ns2:MediaCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 347; } /* = unique type id SOAP_TYPE_ns2__MediaCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MediaCapabilities() { ns2__MediaCapabilities::soap_default(NULL); }
	virtual ~ns2__MediaCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MediaCapabilitiesExtension
#define SOAP_TYPE_ns2__MediaCapabilitiesExtension (348)
/* ns2:MediaCapabilitiesExtension */
class SOAP_CMAC ns2__MediaCapabilitiesExtension : public xsd__anyType
{
public:
	class ns2__ProfileCapabilities *ProfileCapabilities;	/* required element of type ns2:ProfileCapabilities */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 348; } /* = unique type id SOAP_TYPE_ns2__MediaCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MediaCapabilitiesExtension() { ns2__MediaCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__MediaCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RealTimeStreamingCapabilities
#define SOAP_TYPE_ns2__RealTimeStreamingCapabilities (349)
/* ns2:RealTimeStreamingCapabilities */
class SOAP_CMAC ns2__RealTimeStreamingCapabilities : public xsd__anyType
{
public:
	bool *RTPMulticast;	/* optional element of type xsd:boolean */
	bool *RTP_USCORETCP;	/* optional element of type xsd:boolean */
	bool *RTP_USCORERTSP_USCORETCP;	/* optional element of type xsd:boolean */
	class ns2__RealTimeStreamingCapabilitiesExtension *Extension;	/* optional element of type ns2:RealTimeStreamingCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 349; } /* = unique type id SOAP_TYPE_ns2__RealTimeStreamingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RealTimeStreamingCapabilities() { ns2__RealTimeStreamingCapabilities::soap_default(NULL); }
	virtual ~ns2__RealTimeStreamingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension
#define SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension (350)
/* ns2:RealTimeStreamingCapabilitiesExtension */
class SOAP_CMAC ns2__RealTimeStreamingCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 350; } /* = unique type id SOAP_TYPE_ns2__RealTimeStreamingCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RealTimeStreamingCapabilitiesExtension() { ns2__RealTimeStreamingCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__RealTimeStreamingCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ProfileCapabilities
#define SOAP_TYPE_ns2__ProfileCapabilities (351)
/* ns2:ProfileCapabilities */
class SOAP_CMAC ns2__ProfileCapabilities : public xsd__anyType
{
public:
	int MaximumNumberOfProfiles;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 351; } /* = unique type id SOAP_TYPE_ns2__ProfileCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ProfileCapabilities() { ns2__ProfileCapabilities::soap_default(NULL); }
	virtual ~ns2__ProfileCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkCapabilities
#define SOAP_TYPE_ns2__NetworkCapabilities (352)
/* ns2:NetworkCapabilities */
class SOAP_CMAC ns2__NetworkCapabilities : public xsd__anyType
{
public:
	bool *IPFilter;	/* optional element of type xsd:boolean */
	bool *ZeroConfiguration;	/* optional element of type xsd:boolean */
	bool *IPVersion6;	/* optional element of type xsd:boolean */
	bool *DynDNS;	/* optional element of type xsd:boolean */
	class ns2__NetworkCapabilitiesExtension *Extension;	/* optional element of type ns2:NetworkCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 352; } /* = unique type id SOAP_TYPE_ns2__NetworkCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkCapabilities() { ns2__NetworkCapabilities::soap_default(NULL); }
	virtual ~ns2__NetworkCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkCapabilitiesExtension
#define SOAP_TYPE_ns2__NetworkCapabilitiesExtension (353)
/* ns2:NetworkCapabilitiesExtension */
class SOAP_CMAC ns2__NetworkCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *Dot11Configuration;	/* optional element of type xsd:boolean */
	class ns2__NetworkCapabilitiesExtension2 *Extension;	/* optional element of type ns2:NetworkCapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 353; } /* = unique type id SOAP_TYPE_ns2__NetworkCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkCapabilitiesExtension() { ns2__NetworkCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__NetworkCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkCapabilitiesExtension2
#define SOAP_TYPE_ns2__NetworkCapabilitiesExtension2 (354)
/* ns2:NetworkCapabilitiesExtension2 */
class SOAP_CMAC ns2__NetworkCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 354; } /* = unique type id SOAP_TYPE_ns2__NetworkCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkCapabilitiesExtension2() { ns2__NetworkCapabilitiesExtension2::soap_default(NULL); }
	virtual ~ns2__NetworkCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SecurityCapabilities
#define SOAP_TYPE_ns2__SecurityCapabilities (355)
/* ns2:SecurityCapabilities */
class SOAP_CMAC ns2__SecurityCapabilities : public xsd__anyType
{
public:
	bool TLS1_x002e1;	/* required element of type xsd:boolean */
	bool TLS1_x002e2;	/* required element of type xsd:boolean */
	bool OnboardKeyGeneration;	/* required element of type xsd:boolean */
	bool AccessPolicyConfig;	/* required element of type xsd:boolean */
	bool X_x002e509Token;	/* required element of type xsd:boolean */
	bool SAMLToken;	/* required element of type xsd:boolean */
	bool KerberosToken;	/* required element of type xsd:boolean */
	bool RELToken;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	class ns2__SecurityCapabilitiesExtension *Extension;	/* optional element of type ns2:SecurityCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 355; } /* = unique type id SOAP_TYPE_ns2__SecurityCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SecurityCapabilities() { ns2__SecurityCapabilities::soap_default(NULL); }
	virtual ~ns2__SecurityCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SecurityCapabilitiesExtension
#define SOAP_TYPE_ns2__SecurityCapabilitiesExtension (356)
/* ns2:SecurityCapabilitiesExtension */
class SOAP_CMAC ns2__SecurityCapabilitiesExtension : public xsd__anyType
{
public:
	bool TLS1_x002e0;	/* required element of type xsd:boolean */
	class ns2__SecurityCapabilitiesExtension2 *Extension;	/* optional element of type ns2:SecurityCapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 356; } /* = unique type id SOAP_TYPE_ns2__SecurityCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SecurityCapabilitiesExtension() { ns2__SecurityCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__SecurityCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SecurityCapabilitiesExtension2
#define SOAP_TYPE_ns2__SecurityCapabilitiesExtension2 (357)
/* ns2:SecurityCapabilitiesExtension2 */
class SOAP_CMAC ns2__SecurityCapabilitiesExtension2 : public xsd__anyType
{
public:
	bool Dot1X;	/* required element of type xsd:boolean */
	std::vector<int >SupportedEAPMethod;	/* optional element of type xsd:int */
	bool RemoteUserHandling;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 357; } /* = unique type id SOAP_TYPE_ns2__SecurityCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SecurityCapabilitiesExtension2() { ns2__SecurityCapabilitiesExtension2::soap_default(NULL); }
	virtual ~ns2__SecurityCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemCapabilities
#define SOAP_TYPE_ns2__SystemCapabilities (358)
/* ns2:SystemCapabilities */
class SOAP_CMAC ns2__SystemCapabilities : public xsd__anyType
{
public:
	bool DiscoveryResolve;	/* required element of type xsd:boolean */
	bool DiscoveryBye;	/* required element of type xsd:boolean */
	bool RemoteDiscovery;	/* required element of type xsd:boolean */
	bool SystemBackup;	/* required element of type xsd:boolean */
	bool SystemLogging;	/* required element of type xsd:boolean */
	bool FirmwareUpgrade;	/* required element of type xsd:boolean */
	std::vector<class ns2__OnvifVersion * >SupportedVersions;	/* required element of type ns2:OnvifVersion */
	class ns2__SystemCapabilitiesExtension *Extension;	/* optional element of type ns2:SystemCapabilitiesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 358; } /* = unique type id SOAP_TYPE_ns2__SystemCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemCapabilities() { ns2__SystemCapabilities::soap_default(NULL); }
	virtual ~ns2__SystemCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemCapabilitiesExtension
#define SOAP_TYPE_ns2__SystemCapabilitiesExtension (359)
/* ns2:SystemCapabilitiesExtension */
class SOAP_CMAC ns2__SystemCapabilitiesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	bool *HttpFirmwareUpgrade;	/* optional element of type xsd:boolean */
	bool *HttpSystemBackup;	/* optional element of type xsd:boolean */
	bool *HttpSystemLogging;	/* optional element of type xsd:boolean */
	bool *HttpSupportInformation;	/* optional element of type xsd:boolean */
	class ns2__SystemCapabilitiesExtension2 *Extension;	/* optional element of type ns2:SystemCapabilitiesExtension2 */
public:
	virtual int soap_type() const { return 359; } /* = unique type id SOAP_TYPE_ns2__SystemCapabilitiesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemCapabilitiesExtension() { ns2__SystemCapabilitiesExtension::soap_default(NULL); }
	virtual ~ns2__SystemCapabilitiesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemCapabilitiesExtension2
#define SOAP_TYPE_ns2__SystemCapabilitiesExtension2 (360)
/* ns2:SystemCapabilitiesExtension2 */
class SOAP_CMAC ns2__SystemCapabilitiesExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 360; } /* = unique type id SOAP_TYPE_ns2__SystemCapabilitiesExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemCapabilitiesExtension2() { ns2__SystemCapabilitiesExtension2::soap_default(NULL); }
	virtual ~ns2__SystemCapabilitiesExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OnvifVersion
#define SOAP_TYPE_ns2__OnvifVersion (361)
/* ns2:OnvifVersion */
class SOAP_CMAC ns2__OnvifVersion : public xsd__anyType
{
public:
	int Major;	/* required element of type xsd:int */
	int Minor;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 361; } /* = unique type id SOAP_TYPE_ns2__OnvifVersion */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OnvifVersion() { ns2__OnvifVersion::soap_default(NULL); }
	virtual ~ns2__OnvifVersion() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingCapabilities
#define SOAP_TYPE_ns2__ImagingCapabilities (362)
/* ns2:ImagingCapabilities */
class SOAP_CMAC ns2__ImagingCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 362; } /* = unique type id SOAP_TYPE_ns2__ImagingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingCapabilities() { ns2__ImagingCapabilities::soap_default(NULL); }
	virtual ~ns2__ImagingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZCapabilities
#define SOAP_TYPE_ns2__PTZCapabilities (363)
/* ns2:PTZCapabilities */
class SOAP_CMAC ns2__PTZCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 363; } /* = unique type id SOAP_TYPE_ns2__PTZCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZCapabilities() { ns2__PTZCapabilities::soap_default(NULL); }
	virtual ~ns2__PTZCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DeviceIOCapabilities
#define SOAP_TYPE_ns2__DeviceIOCapabilities (364)
/* ns2:DeviceIOCapabilities */
class SOAP_CMAC ns2__DeviceIOCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	int VideoSources;	/* required element of type xsd:int */
	int VideoOutputs;	/* required element of type xsd:int */
	int AudioSources;	/* required element of type xsd:int */
	int AudioOutputs;	/* required element of type xsd:int */
	int RelayOutputs;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 364; } /* = unique type id SOAP_TYPE_ns2__DeviceIOCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DeviceIOCapabilities() { ns2__DeviceIOCapabilities::soap_default(NULL); }
	virtual ~ns2__DeviceIOCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DisplayCapabilities
#define SOAP_TYPE_ns2__DisplayCapabilities (365)
/* ns2:DisplayCapabilities */
class SOAP_CMAC ns2__DisplayCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool FixedLayout;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 365; } /* = unique type id SOAP_TYPE_ns2__DisplayCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DisplayCapabilities() { ns2__DisplayCapabilities::soap_default(NULL); }
	virtual ~ns2__DisplayCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingCapabilities
#define SOAP_TYPE_ns2__RecordingCapabilities (366)
/* ns2:RecordingCapabilities */
class SOAP_CMAC ns2__RecordingCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool ReceiverSource;	/* required element of type xsd:boolean */
	bool MediaProfileSource;	/* required element of type xsd:boolean */
	bool DynamicRecordings;	/* required element of type xsd:boolean */
	bool DynamicTracks;	/* required element of type xsd:boolean */
	int MaxStringLength;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 366; } /* = unique type id SOAP_TYPE_ns2__RecordingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingCapabilities() { ns2__RecordingCapabilities::soap_default(NULL); }
	virtual ~ns2__RecordingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SearchCapabilities
#define SOAP_TYPE_ns2__SearchCapabilities (367)
/* ns2:SearchCapabilities */
class SOAP_CMAC ns2__SearchCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool MetadataSearch;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 367; } /* = unique type id SOAP_TYPE_ns2__SearchCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SearchCapabilities() { ns2__SearchCapabilities::soap_default(NULL); }
	virtual ~ns2__SearchCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReplayCapabilities
#define SOAP_TYPE_ns2__ReplayCapabilities (368)
/* ns2:ReplayCapabilities */
class SOAP_CMAC ns2__ReplayCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 368; } /* = unique type id SOAP_TYPE_ns2__ReplayCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReplayCapabilities() { ns2__ReplayCapabilities::soap_default(NULL); }
	virtual ~ns2__ReplayCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReceiverCapabilities
#define SOAP_TYPE_ns2__ReceiverCapabilities (369)
/* ns2:ReceiverCapabilities */
class SOAP_CMAC ns2__ReceiverCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool RTP_USCOREMulticast;	/* required element of type xsd:boolean */
	bool RTP_USCORETCP;	/* required element of type xsd:boolean */
	bool RTP_USCORERTSP_USCORETCP;	/* required element of type xsd:boolean */
	int SupportedReceivers;	/* required element of type xsd:int */
	int MaximumRTSPURILength;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 369; } /* = unique type id SOAP_TYPE_ns2__ReceiverCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReceiverCapabilities() { ns2__ReceiverCapabilities::soap_default(NULL); }
	virtual ~ns2__ReceiverCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsDeviceCapabilities
#define SOAP_TYPE_ns2__AnalyticsDeviceCapabilities (370)
/* ns2:AnalyticsDeviceCapabilities */
class SOAP_CMAC ns2__AnalyticsDeviceCapabilities : public xsd__anyType
{
public:
	std::string XAddr;	/* required element of type xsd:anyURI */
	bool *RuleSupport;	/* optional element of type xsd:boolean */
	class ns2__AnalyticsDeviceExtension *Extension;	/* optional element of type ns2:AnalyticsDeviceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 370; } /* = unique type id SOAP_TYPE_ns2__AnalyticsDeviceCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsDeviceCapabilities() { ns2__AnalyticsDeviceCapabilities::soap_default(NULL); }
	virtual ~ns2__AnalyticsDeviceCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsDeviceExtension
#define SOAP_TYPE_ns2__AnalyticsDeviceExtension (371)
/* ns2:AnalyticsDeviceExtension */
class SOAP_CMAC ns2__AnalyticsDeviceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 371; } /* = unique type id SOAP_TYPE_ns2__AnalyticsDeviceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsDeviceExtension() { ns2__AnalyticsDeviceExtension::soap_default(NULL); }
	virtual ~ns2__AnalyticsDeviceExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemLog
#define SOAP_TYPE_ns2__SystemLog (372)
/* ns2:SystemLog */
class SOAP_CMAC ns2__SystemLog : public xsd__anyType
{
public:
	class ns2__AttachmentData *Binary;	/* optional element of type ns2:AttachmentData */
	std::string *String;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 372; } /* = unique type id SOAP_TYPE_ns2__SystemLog */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemLog() { ns2__SystemLog::soap_default(NULL); }
	virtual ~ns2__SystemLog() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SupportInformation
#define SOAP_TYPE_ns2__SupportInformation (373)
/* ns2:SupportInformation */
class SOAP_CMAC ns2__SupportInformation : public xsd__anyType
{
public:
	ns2__AttachmentData *Binary;	/* optional element of type ns2:AttachmentData */
	std::string *String;	/* optional element of type xsd:string */
public:
	virtual int soap_type() const { return 373; } /* = unique type id SOAP_TYPE_ns2__SupportInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SupportInformation() { ns2__SupportInformation::soap_default(NULL); }
	virtual ~ns2__SupportInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BinaryData
#define SOAP_TYPE_ns2__BinaryData (374)
/* ns2:BinaryData */
class SOAP_CMAC ns2__BinaryData : public xsd__anyType
{
public:
	xsd__base64Binary Data;	/* required element of type xsd:base64Binary */
	std::string *xmime__contentType;	/* optional attribute */
public:
	virtual int soap_type() const { return 374; } /* = unique type id SOAP_TYPE_ns2__BinaryData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BinaryData() { ns2__BinaryData::soap_default(NULL); }
	virtual ~ns2__BinaryData() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AttachmentData
#define SOAP_TYPE_ns2__AttachmentData (375)
/* ns2:AttachmentData */
class SOAP_CMAC ns2__AttachmentData : public xsd__anyType
{
public:
	class ns4__Include *ns4__Include_;	/* required element of type ns4:Include */
	std::string *xmime__contentType;	/* optional attribute */
public:
	virtual int soap_type() const { return 375; } /* = unique type id SOAP_TYPE_ns2__AttachmentData */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AttachmentData() { ns2__AttachmentData::soap_default(NULL); }
	virtual ~ns2__AttachmentData() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BackupFile
#define SOAP_TYPE_ns2__BackupFile (376)
/* ns2:BackupFile */
class SOAP_CMAC ns2__BackupFile : public xsd__anyType
{
public:
	std::string Name;	/* required element of type xsd:string */
	ns2__AttachmentData *Data;	/* required element of type ns2:AttachmentData */
public:
	virtual int soap_type() const { return 376; } /* = unique type id SOAP_TYPE_ns2__BackupFile */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BackupFile() { ns2__BackupFile::soap_default(NULL); }
	virtual ~ns2__BackupFile() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemLogUriList
#define SOAP_TYPE_ns2__SystemLogUriList (377)
/* ns2:SystemLogUriList */
class SOAP_CMAC ns2__SystemLogUriList : public xsd__anyType
{
public:
	std::vector<class ns2__SystemLogUri * >SystemLog;	/* optional element of type ns2:SystemLogUri */
public:
	virtual int soap_type() const { return 377; } /* = unique type id SOAP_TYPE_ns2__SystemLogUriList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemLogUriList() { ns2__SystemLogUriList::soap_default(NULL); }
	virtual ~ns2__SystemLogUriList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemLogUri
#define SOAP_TYPE_ns2__SystemLogUri (378)
/* ns2:SystemLogUri */
class SOAP_CMAC ns2__SystemLogUri : public xsd__anyType
{
public:
	enum ns2__SystemLogType Type;	/* required element of type ns2:SystemLogType */
	std::string Uri;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 378; } /* = unique type id SOAP_TYPE_ns2__SystemLogUri */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemLogUri() { ns2__SystemLogUri::soap_default(NULL); }
	virtual ~ns2__SystemLogUri() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemDateTime
#define SOAP_TYPE_ns2__SystemDateTime (379)
/* ns2:SystemDateTime */
class SOAP_CMAC ns2__SystemDateTime : public xsd__anyType
{
public:
	enum ns2__SetDateTimeType DateTimeType;	/* required element of type ns2:SetDateTimeType */
	bool DaylightSavings;	/* required element of type xsd:boolean */
	class ns2__TimeZone *TimeZone;	/* optional element of type ns2:TimeZone */
	class ns2__DateTime *UTCDateTime;	/* optional element of type ns2:DateTime */
	ns2__DateTime *LocalDateTime;	/* optional element of type ns2:DateTime */
	class ns2__SystemDateTimeExtension *Extension;	/* optional element of type ns2:SystemDateTimeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 379; } /* = unique type id SOAP_TYPE_ns2__SystemDateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemDateTime() { ns2__SystemDateTime::soap_default(NULL); }
	virtual ~ns2__SystemDateTime() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SystemDateTimeExtension
#define SOAP_TYPE_ns2__SystemDateTimeExtension (380)
/* ns2:SystemDateTimeExtension */
class SOAP_CMAC ns2__SystemDateTimeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 380; } /* = unique type id SOAP_TYPE_ns2__SystemDateTimeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SystemDateTimeExtension() { ns2__SystemDateTimeExtension::soap_default(NULL); }
	virtual ~ns2__SystemDateTimeExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DateTime
#define SOAP_TYPE_ns2__DateTime (381)
/* ns2:DateTime */
class SOAP_CMAC ns2__DateTime : public xsd__anyType
{
public:
	class ns2__Time *Time;	/* required element of type ns2:Time */
	class ns2__Date *Date;	/* required element of type ns2:Date */
public:
	virtual int soap_type() const { return 381; } /* = unique type id SOAP_TYPE_ns2__DateTime */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DateTime() { ns2__DateTime::soap_default(NULL); }
	virtual ~ns2__DateTime() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Date
#define SOAP_TYPE_ns2__Date (382)
/* ns2:Date */
class SOAP_CMAC ns2__Date : public xsd__anyType
{
public:
	int Year;	/* required element of type xsd:int */
	int Month;	/* required element of type xsd:int */
	int Day;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 382; } /* = unique type id SOAP_TYPE_ns2__Date */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Date() { ns2__Date::soap_default(NULL); }
	virtual ~ns2__Date() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Time
#define SOAP_TYPE_ns2__Time (383)
/* ns2:Time */
class SOAP_CMAC ns2__Time : public xsd__anyType
{
public:
	int Hour;	/* required element of type xsd:int */
	int Minute;	/* required element of type xsd:int */
	int Second;	/* required element of type xsd:int */
public:
	virtual int soap_type() const { return 383; } /* = unique type id SOAP_TYPE_ns2__Time */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Time() { ns2__Time::soap_default(NULL); }
	virtual ~ns2__Time() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TimeZone
#define SOAP_TYPE_ns2__TimeZone (384)
/* ns2:TimeZone */
class SOAP_CMAC ns2__TimeZone : public xsd__anyType
{
public:
	std::string TZ;	/* required element of type xsd:token */
public:
	virtual int soap_type() const { return 384; } /* = unique type id SOAP_TYPE_ns2__TimeZone */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TimeZone() { ns2__TimeZone::soap_default(NULL); }
	virtual ~ns2__TimeZone() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RemoteUser
#define SOAP_TYPE_ns2__RemoteUser (385)
/* ns2:RemoteUser */
class SOAP_CMAC ns2__RemoteUser : public xsd__anyType
{
public:
	std::string Username;	/* required element of type xsd:string */
	std::string *Password;	/* optional element of type xsd:string */
	bool UseDerivedPassword;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 385; } /* = unique type id SOAP_TYPE_ns2__RemoteUser */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RemoteUser() { ns2__RemoteUser::soap_default(NULL); }
	virtual ~ns2__RemoteUser() { }
};
#endif

#ifndef SOAP_TYPE_ns2__User
#define SOAP_TYPE_ns2__User (386)
/* ns2:User */
class SOAP_CMAC ns2__User : public xsd__anyType
{
public:
	std::string Username;	/* required element of type xsd:string */
	std::string *Password;	/* optional element of type xsd:string */
	enum ns2__UserLevel UserLevel;	/* required element of type ns2:UserLevel */
	class ns2__UserExtension *Extension;	/* optional element of type ns2:UserExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 386; } /* = unique type id SOAP_TYPE_ns2__User */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__User() { ns2__User::soap_default(NULL); }
	virtual ~ns2__User() { }
};
#endif

#ifndef SOAP_TYPE_ns2__UserExtension
#define SOAP_TYPE_ns2__UserExtension (387)
/* ns2:UserExtension */
class SOAP_CMAC ns2__UserExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 387; } /* = unique type id SOAP_TYPE_ns2__UserExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__UserExtension() { ns2__UserExtension::soap_default(NULL); }
	virtual ~ns2__UserExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CertificateGenerationParameters
#define SOAP_TYPE_ns2__CertificateGenerationParameters (388)
/* ns2:CertificateGenerationParameters */
class SOAP_CMAC ns2__CertificateGenerationParameters : public xsd__anyType
{
public:
	std::string *CertificateID;	/* optional element of type xsd:token */
	std::string *Subject;	/* optional element of type xsd:string */
	std::string *ValidNotBefore;	/* optional element of type xsd:token */
	std::string *ValidNotAfter;	/* optional element of type xsd:token */
	class ns2__CertificateGenerationParametersExtension *Extension;	/* optional element of type ns2:CertificateGenerationParametersExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 388; } /* = unique type id SOAP_TYPE_ns2__CertificateGenerationParameters */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CertificateGenerationParameters() { ns2__CertificateGenerationParameters::soap_default(NULL); }
	virtual ~ns2__CertificateGenerationParameters() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CertificateGenerationParametersExtension
#define SOAP_TYPE_ns2__CertificateGenerationParametersExtension (389)
/* ns2:CertificateGenerationParametersExtension */
class SOAP_CMAC ns2__CertificateGenerationParametersExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 389; } /* = unique type id SOAP_TYPE_ns2__CertificateGenerationParametersExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CertificateGenerationParametersExtension() { ns2__CertificateGenerationParametersExtension::soap_default(NULL); }
	virtual ~ns2__CertificateGenerationParametersExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Certificate
#define SOAP_TYPE_ns2__Certificate (390)
/* ns2:Certificate */
class SOAP_CMAC ns2__Certificate : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	ns2__BinaryData *Certificate;	/* required element of type ns2:BinaryData */
public:
	virtual int soap_type() const { return 390; } /* = unique type id SOAP_TYPE_ns2__Certificate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Certificate() { ns2__Certificate::soap_default(NULL); }
	virtual ~ns2__Certificate() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CertificateStatus
#define SOAP_TYPE_ns2__CertificateStatus (391)
/* ns2:CertificateStatus */
class SOAP_CMAC ns2__CertificateStatus : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	bool Status;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 391; } /* = unique type id SOAP_TYPE_ns2__CertificateStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CertificateStatus() { ns2__CertificateStatus::soap_default(NULL); }
	virtual ~ns2__CertificateStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CertificateWithPrivateKey
#define SOAP_TYPE_ns2__CertificateWithPrivateKey (392)
/* ns2:CertificateWithPrivateKey */
class SOAP_CMAC ns2__CertificateWithPrivateKey : public xsd__anyType
{
public:
	std::string *CertificateID;	/* optional element of type xsd:token */
	ns2__BinaryData *Certificate;	/* required element of type ns2:BinaryData */
	ns2__BinaryData *PrivateKey;	/* required element of type ns2:BinaryData */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 392; } /* = unique type id SOAP_TYPE_ns2__CertificateWithPrivateKey */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CertificateWithPrivateKey() { ns2__CertificateWithPrivateKey::soap_default(NULL); }
	virtual ~ns2__CertificateWithPrivateKey() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CertificateInformation
#define SOAP_TYPE_ns2__CertificateInformation (393)
/* ns2:CertificateInformation */
class SOAP_CMAC ns2__CertificateInformation : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	std::string *IssuerDN;	/* optional element of type xsd:string */
	std::string *SubjectDN;	/* optional element of type xsd:string */
	class ns2__CertificateUsage *KeyUsage;	/* optional element of type ns2:CertificateUsage */
	ns2__CertificateUsage *ExtendedKeyUsage;	/* optional element of type ns2:CertificateUsage */
	int *KeyLength;	/* optional element of type xsd:int */
	std::string *Version;	/* optional element of type xsd:string */
	std::string *SerialNum;	/* optional element of type xsd:string */
	std::string *SignatureAlgorithm;	/* optional element of type xsd:string */
	class ns2__DateTimeRange *Validity;	/* optional element of type ns2:DateTimeRange */
	class ns2__CertificateInformationExtension *Extension;	/* optional element of type ns2:CertificateInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 393; } /* = unique type id SOAP_TYPE_ns2__CertificateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CertificateInformation() { ns2__CertificateInformation::soap_default(NULL); }
	virtual ~ns2__CertificateInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CertificateInformationExtension
#define SOAP_TYPE_ns2__CertificateInformationExtension (395)
/* ns2:CertificateInformationExtension */
class SOAP_CMAC ns2__CertificateInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 395; } /* = unique type id SOAP_TYPE_ns2__CertificateInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CertificateInformationExtension() { ns2__CertificateInformationExtension::soap_default(NULL); }
	virtual ~ns2__CertificateInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot1XConfiguration
#define SOAP_TYPE_ns2__Dot1XConfiguration (396)
/* ns2:Dot1XConfiguration */
class SOAP_CMAC ns2__Dot1XConfiguration : public xsd__anyType
{
public:
	std::string Dot1XConfigurationToken;	/* required element of type ns2:ReferenceToken */
	std::string Identity;	/* required element of type xsd:string */
	std::string *AnonymousID;	/* optional element of type xsd:string */
	int EAPMethod;	/* required element of type xsd:int */
	std::vector<std::string >CACertificateID;	/* optional element of type xsd:token */
	class ns2__EAPMethodConfiguration *EAPMethodConfiguration;	/* optional element of type ns2:EAPMethodConfiguration */
	class ns2__Dot1XConfigurationExtension *Extension;	/* optional element of type ns2:Dot1XConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 396; } /* = unique type id SOAP_TYPE_ns2__Dot1XConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot1XConfiguration() { ns2__Dot1XConfiguration::soap_default(NULL); }
	virtual ~ns2__Dot1XConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Dot1XConfigurationExtension
#define SOAP_TYPE_ns2__Dot1XConfigurationExtension (397)
/* ns2:Dot1XConfigurationExtension */
class SOAP_CMAC ns2__Dot1XConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 397; } /* = unique type id SOAP_TYPE_ns2__Dot1XConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Dot1XConfigurationExtension() { ns2__Dot1XConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__Dot1XConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EAPMethodConfiguration
#define SOAP_TYPE_ns2__EAPMethodConfiguration (398)
/* ns2:EAPMethodConfiguration */
class SOAP_CMAC ns2__EAPMethodConfiguration : public xsd__anyType
{
public:
	class ns2__TLSConfiguration *TLSConfiguration;	/* optional element of type ns2:TLSConfiguration */
	std::string *Password;	/* optional element of type xsd:string */
	class ns2__EapMethodExtension *Extension;	/* optional element of type ns2:EapMethodExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 398; } /* = unique type id SOAP_TYPE_ns2__EAPMethodConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EAPMethodConfiguration() { ns2__EAPMethodConfiguration::soap_default(NULL); }
	virtual ~ns2__EAPMethodConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EapMethodExtension
#define SOAP_TYPE_ns2__EapMethodExtension (399)
/* ns2:EapMethodExtension */
class SOAP_CMAC ns2__EapMethodExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 399; } /* = unique type id SOAP_TYPE_ns2__EapMethodExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EapMethodExtension() { ns2__EapMethodExtension::soap_default(NULL); }
	virtual ~ns2__EapMethodExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TLSConfiguration
#define SOAP_TYPE_ns2__TLSConfiguration (400)
/* ns2:TLSConfiguration */
class SOAP_CMAC ns2__TLSConfiguration : public xsd__anyType
{
public:
	std::string CertificateID;	/* required element of type xsd:token */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 400; } /* = unique type id SOAP_TYPE_ns2__TLSConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TLSConfiguration() { ns2__TLSConfiguration::soap_default(NULL); }
	virtual ~ns2__TLSConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension
#define SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension (401)
/* ns2:GenericEapPwdConfigurationExtension */
class SOAP_CMAC ns2__GenericEapPwdConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 401; } /* = unique type id SOAP_TYPE_ns2__GenericEapPwdConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__GenericEapPwdConfigurationExtension() { ns2__GenericEapPwdConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__GenericEapPwdConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelayOutputSettings
#define SOAP_TYPE_ns2__RelayOutputSettings (402)
/* ns2:RelayOutputSettings */
class SOAP_CMAC ns2__RelayOutputSettings : public xsd__anyType
{
public:
	enum ns2__RelayMode Mode;	/* required element of type ns2:RelayMode */
	std::string DelayTime;	/* required element of type xsd:duration */
	enum ns2__RelayIdleState IdleState;	/* required element of type ns2:RelayIdleState */
public:
	virtual int soap_type() const { return 402; } /* = unique type id SOAP_TYPE_ns2__RelayOutputSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelayOutputSettings() { ns2__RelayOutputSettings::soap_default(NULL); }
	virtual ~ns2__RelayOutputSettings() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZNodeExtension
#define SOAP_TYPE_ns2__PTZNodeExtension (406)
/* ns2:PTZNodeExtension */
class SOAP_CMAC ns2__PTZNodeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__PTZPresetTourSupported *SupportedPresetTour;	/* optional element of type ns2:PTZPresetTourSupported */
	class ns2__PTZNodeExtension2 *Extension;	/* optional element of type ns2:PTZNodeExtension2 */
public:
	virtual int soap_type() const { return 406; } /* = unique type id SOAP_TYPE_ns2__PTZNodeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZNodeExtension() { ns2__PTZNodeExtension::soap_default(NULL); }
	virtual ~ns2__PTZNodeExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZNodeExtension2
#define SOAP_TYPE_ns2__PTZNodeExtension2 (407)
/* ns2:PTZNodeExtension2 */
class SOAP_CMAC ns2__PTZNodeExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 407; } /* = unique type id SOAP_TYPE_ns2__PTZNodeExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZNodeExtension2() { ns2__PTZNodeExtension2::soap_default(NULL); }
	virtual ~ns2__PTZNodeExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourSupported
#define SOAP_TYPE_ns2__PTZPresetTourSupported (408)
/* ns2:PTZPresetTourSupported */
class SOAP_CMAC ns2__PTZPresetTourSupported : public xsd__anyType
{
public:
	int MaximumNumberOfPresetTours;	/* required element of type xsd:int */
	std::vector<enum ns2__PTZPresetTourOperation >PTZPresetTourOperation;	/* optional element of type ns2:PTZPresetTourOperation */
	class ns2__PTZPresetTourSupportedExtension *Extension;	/* optional element of type ns2:PTZPresetTourSupportedExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 408; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourSupported */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourSupported() { ns2__PTZPresetTourSupported::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourSupported() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourSupportedExtension
#define SOAP_TYPE_ns2__PTZPresetTourSupportedExtension (409)
/* ns2:PTZPresetTourSupportedExtension */
class SOAP_CMAC ns2__PTZPresetTourSupportedExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 409; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourSupportedExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourSupportedExtension() { ns2__PTZPresetTourSupportedExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourSupportedExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZConfigurationExtension
#define SOAP_TYPE_ns2__PTZConfigurationExtension (411)
/* ns2:PTZConfigurationExtension */
class SOAP_CMAC ns2__PTZConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__PTControlDirection *PTControlDirection;	/* optional element of type ns2:PTControlDirection */
	class ns2__PTZConfigurationExtension2 *Extension;	/* optional element of type ns2:PTZConfigurationExtension2 */
public:
	virtual int soap_type() const { return 411; } /* = unique type id SOAP_TYPE_ns2__PTZConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZConfigurationExtension() { ns2__PTZConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__PTZConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZConfigurationExtension2
#define SOAP_TYPE_ns2__PTZConfigurationExtension2 (412)
/* ns2:PTZConfigurationExtension2 */
class SOAP_CMAC ns2__PTZConfigurationExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 412; } /* = unique type id SOAP_TYPE_ns2__PTZConfigurationExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZConfigurationExtension2() { ns2__PTZConfigurationExtension2::soap_default(NULL); }
	virtual ~ns2__PTZConfigurationExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTControlDirection
#define SOAP_TYPE_ns2__PTControlDirection (413)
/* ns2:PTControlDirection */
class SOAP_CMAC ns2__PTControlDirection : public xsd__anyType
{
public:
	class ns2__EFlip *EFlip;	/* optional element of type ns2:EFlip */
	class ns2__Reverse *Reverse;	/* optional element of type ns2:Reverse */
	class ns2__PTControlDirectionExtension *Extension;	/* optional element of type ns2:PTControlDirectionExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 413; } /* = unique type id SOAP_TYPE_ns2__PTControlDirection */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTControlDirection() { ns2__PTControlDirection::soap_default(NULL); }
	virtual ~ns2__PTControlDirection() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTControlDirectionExtension
#define SOAP_TYPE_ns2__PTControlDirectionExtension (414)
/* ns2:PTControlDirectionExtension */
class SOAP_CMAC ns2__PTControlDirectionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 414; } /* = unique type id SOAP_TYPE_ns2__PTControlDirectionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTControlDirectionExtension() { ns2__PTControlDirectionExtension::soap_default(NULL); }
	virtual ~ns2__PTControlDirectionExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EFlip
#define SOAP_TYPE_ns2__EFlip (415)
/* ns2:EFlip */
class SOAP_CMAC ns2__EFlip : public xsd__anyType
{
public:
	enum ns2__EFlipMode Mode;	/* required element of type ns2:EFlipMode */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 415; } /* = unique type id SOAP_TYPE_ns2__EFlip */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EFlip() { ns2__EFlip::soap_default(NULL); }
	virtual ~ns2__EFlip() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Reverse
#define SOAP_TYPE_ns2__Reverse (416)
/* ns2:Reverse */
class SOAP_CMAC ns2__Reverse : public xsd__anyType
{
public:
	enum ns2__ReverseMode Mode;	/* required element of type ns2:ReverseMode */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 416; } /* = unique type id SOAP_TYPE_ns2__Reverse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Reverse() { ns2__Reverse::soap_default(NULL); }
	virtual ~ns2__Reverse() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZConfigurationOptions
#define SOAP_TYPE_ns2__PTZConfigurationOptions (417)
/* ns2:PTZConfigurationOptions */
class SOAP_CMAC ns2__PTZConfigurationOptions : public xsd__anyType
{
public:
	class ns2__PTZSpaces *Spaces;	/* required element of type ns2:PTZSpaces */
	ns2__DurationRange *PTZTimeout;	/* required element of type ns2:DurationRange */
	std::vector<char * >__any;
	class ns2__PTControlDirectionOptions *PTControlDirection;	/* optional element of type ns2:PTControlDirectionOptions */
	class ns2__PTZConfigurationOptions2 *Extension;	/* optional element of type ns2:PTZConfigurationOptions2 */
	std::string *PTZRamps;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 417; } /* = unique type id SOAP_TYPE_ns2__PTZConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZConfigurationOptions() { ns2__PTZConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__PTZConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZConfigurationOptions2
#define SOAP_TYPE_ns2__PTZConfigurationOptions2 (418)
/* ns2:PTZConfigurationOptions2 */
class SOAP_CMAC ns2__PTZConfigurationOptions2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 418; } /* = unique type id SOAP_TYPE_ns2__PTZConfigurationOptions2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZConfigurationOptions2() { ns2__PTZConfigurationOptions2::soap_default(NULL); }
	virtual ~ns2__PTZConfigurationOptions2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTControlDirectionOptions
#define SOAP_TYPE_ns2__PTControlDirectionOptions (419)
/* ns2:PTControlDirectionOptions */
class SOAP_CMAC ns2__PTControlDirectionOptions : public xsd__anyType
{
public:
	class ns2__EFlipOptions *EFlip;	/* optional element of type ns2:EFlipOptions */
	class ns2__ReverseOptions *Reverse;	/* optional element of type ns2:ReverseOptions */
	class ns2__PTControlDirectionOptionsExtension *Extension;	/* optional element of type ns2:PTControlDirectionOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 419; } /* = unique type id SOAP_TYPE_ns2__PTControlDirectionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTControlDirectionOptions() { ns2__PTControlDirectionOptions::soap_default(NULL); }
	virtual ~ns2__PTControlDirectionOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTControlDirectionOptionsExtension
#define SOAP_TYPE_ns2__PTControlDirectionOptionsExtension (420)
/* ns2:PTControlDirectionOptionsExtension */
class SOAP_CMAC ns2__PTControlDirectionOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 420; } /* = unique type id SOAP_TYPE_ns2__PTControlDirectionOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTControlDirectionOptionsExtension() { ns2__PTControlDirectionOptionsExtension::soap_default(NULL); }
	virtual ~ns2__PTControlDirectionOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EFlipOptions
#define SOAP_TYPE_ns2__EFlipOptions (421)
/* ns2:EFlipOptions */
class SOAP_CMAC ns2__EFlipOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__EFlipMode >Mode;	/* optional element of type ns2:EFlipMode */
	class ns2__EFlipOptionsExtension *Extension;	/* optional element of type ns2:EFlipOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 421; } /* = unique type id SOAP_TYPE_ns2__EFlipOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EFlipOptions() { ns2__EFlipOptions::soap_default(NULL); }
	virtual ~ns2__EFlipOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EFlipOptionsExtension
#define SOAP_TYPE_ns2__EFlipOptionsExtension (422)
/* ns2:EFlipOptionsExtension */
class SOAP_CMAC ns2__EFlipOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 422; } /* = unique type id SOAP_TYPE_ns2__EFlipOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EFlipOptionsExtension() { ns2__EFlipOptionsExtension::soap_default(NULL); }
	virtual ~ns2__EFlipOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReverseOptions
#define SOAP_TYPE_ns2__ReverseOptions (423)
/* ns2:ReverseOptions */
class SOAP_CMAC ns2__ReverseOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__ReverseMode >Mode;	/* optional element of type ns2:ReverseMode */
	class ns2__ReverseOptionsExtension *Extension;	/* optional element of type ns2:ReverseOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 423; } /* = unique type id SOAP_TYPE_ns2__ReverseOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReverseOptions() { ns2__ReverseOptions::soap_default(NULL); }
	virtual ~ns2__ReverseOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReverseOptionsExtension
#define SOAP_TYPE_ns2__ReverseOptionsExtension (424)
/* ns2:ReverseOptionsExtension */
class SOAP_CMAC ns2__ReverseOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 424; } /* = unique type id SOAP_TYPE_ns2__ReverseOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReverseOptionsExtension() { ns2__ReverseOptionsExtension::soap_default(NULL); }
	virtual ~ns2__ReverseOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PanTiltLimits
#define SOAP_TYPE_ns2__PanTiltLimits (425)
/* ns2:PanTiltLimits */
class SOAP_CMAC ns2__PanTiltLimits : public xsd__anyType
{
public:
	class ns2__Space2DDescription *Range;	/* required element of type ns2:Space2DDescription */
public:
	virtual int soap_type() const { return 425; } /* = unique type id SOAP_TYPE_ns2__PanTiltLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PanTiltLimits() { ns2__PanTiltLimits::soap_default(NULL); }
	virtual ~ns2__PanTiltLimits() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ZoomLimits
#define SOAP_TYPE_ns2__ZoomLimits (426)
/* ns2:ZoomLimits */
class SOAP_CMAC ns2__ZoomLimits : public xsd__anyType
{
public:
	class ns2__Space1DDescription *Range;	/* required element of type ns2:Space1DDescription */
public:
	virtual int soap_type() const { return 426; } /* = unique type id SOAP_TYPE_ns2__ZoomLimits */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ZoomLimits() { ns2__ZoomLimits::soap_default(NULL); }
	virtual ~ns2__ZoomLimits() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZSpaces
#define SOAP_TYPE_ns2__PTZSpaces (427)
/* ns2:PTZSpaces */
class SOAP_CMAC ns2__PTZSpaces : public xsd__anyType
{
public:
	std::vector<ns2__Space2DDescription * >AbsolutePanTiltPositionSpace;	/* optional element of type ns2:Space2DDescription */
	std::vector<ns2__Space1DDescription * >AbsoluteZoomPositionSpace;	/* optional element of type ns2:Space1DDescription */
	std::vector<ns2__Space2DDescription * >RelativePanTiltTranslationSpace;	/* optional element of type ns2:Space2DDescription */
	std::vector<ns2__Space1DDescription * >RelativeZoomTranslationSpace;	/* optional element of type ns2:Space1DDescription */
	std::vector<ns2__Space2DDescription * >ContinuousPanTiltVelocitySpace;	/* optional element of type ns2:Space2DDescription */
	std::vector<ns2__Space1DDescription * >ContinuousZoomVelocitySpace;	/* optional element of type ns2:Space1DDescription */
	std::vector<ns2__Space1DDescription * >PanTiltSpeedSpace;	/* optional element of type ns2:Space1DDescription */
	std::vector<ns2__Space1DDescription * >ZoomSpeedSpace;	/* optional element of type ns2:Space1DDescription */
	class ns2__PTZSpacesExtension *Extension;	/* optional element of type ns2:PTZSpacesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 427; } /* = unique type id SOAP_TYPE_ns2__PTZSpaces */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZSpaces() { ns2__PTZSpaces::soap_default(NULL); }
	virtual ~ns2__PTZSpaces() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZSpacesExtension
#define SOAP_TYPE_ns2__PTZSpacesExtension (428)
/* ns2:PTZSpacesExtension */
class SOAP_CMAC ns2__PTZSpacesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 428; } /* = unique type id SOAP_TYPE_ns2__PTZSpacesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZSpacesExtension() { ns2__PTZSpacesExtension::soap_default(NULL); }
	virtual ~ns2__PTZSpacesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Space2DDescription
#define SOAP_TYPE_ns2__Space2DDescription (429)
/* ns2:Space2DDescription */
class SOAP_CMAC ns2__Space2DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of type xsd:anyURI */
	ns2__FloatRange *XRange;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *YRange;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 429; } /* = unique type id SOAP_TYPE_ns2__Space2DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Space2DDescription() { ns2__Space2DDescription::soap_default(NULL); }
	virtual ~ns2__Space2DDescription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Space1DDescription
#define SOAP_TYPE_ns2__Space1DDescription (430)
/* ns2:Space1DDescription */
class SOAP_CMAC ns2__Space1DDescription : public xsd__anyType
{
public:
	std::string URI;	/* required element of type xsd:anyURI */
	ns2__FloatRange *XRange;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 430; } /* = unique type id SOAP_TYPE_ns2__Space1DDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Space1DDescription() { ns2__Space1DDescription::soap_default(NULL); }
	virtual ~ns2__Space1DDescription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Vector2D
#define SOAP_TYPE_ns2__Vector2D (431)
/* Primitive ns2:Vector2D schema type: */
class SOAP_CMAC ns2__Vector2D : public xsd__anyType
{
public:
	float x;	/* required attribute */
	float y;	/* required attribute */
	std::string *space;	/* optional attribute */
public:
	virtual int soap_type() const { return 431; } /* = unique type id SOAP_TYPE_ns2__Vector2D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Vector2D() { ns2__Vector2D::soap_default(NULL); }
	virtual ~ns2__Vector2D() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Vector1D
#define SOAP_TYPE_ns2__Vector1D (432)
/* Primitive ns2:Vector1D schema type: */
class SOAP_CMAC ns2__Vector1D : public xsd__anyType
{
public:
	float x;	/* required attribute */
	std::string *space;	/* optional attribute */
public:
	virtual int soap_type() const { return 432; } /* = unique type id SOAP_TYPE_ns2__Vector1D */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Vector1D() { ns2__Vector1D::soap_default(NULL); }
	virtual ~ns2__Vector1D() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZVector
#define SOAP_TYPE_ns2__PTZVector (433)
/* ns2:PTZVector */
class SOAP_CMAC ns2__PTZVector : public xsd__anyType
{
public:
	ns2__Vector2D *PanTilt;	/* optional element of type ns2:Vector2D */
	ns2__Vector1D *Zoom;	/* optional element of type ns2:Vector1D */
public:
	virtual int soap_type() const { return 433; } /* = unique type id SOAP_TYPE_ns2__PTZVector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZVector() { ns2__PTZVector::soap_default(NULL); }
	virtual ~ns2__PTZVector() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZSpeed
#define SOAP_TYPE_ns2__PTZSpeed (434)
/* ns2:PTZSpeed */
class SOAP_CMAC ns2__PTZSpeed : public xsd__anyType
{
public:
	ns2__Vector2D *PanTilt;	/* optional element of type ns2:Vector2D */
	ns2__Vector1D *Zoom;	/* optional element of type ns2:Vector1D */
public:
	virtual int soap_type() const { return 434; } /* = unique type id SOAP_TYPE_ns2__PTZSpeed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZSpeed() { ns2__PTZSpeed::soap_default(NULL); }
	virtual ~ns2__PTZSpeed() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZStatus
#define SOAP_TYPE_ns2__PTZStatus (435)
/* ns2:PTZStatus */
class SOAP_CMAC ns2__PTZStatus : public xsd__anyType
{
public:
	ns2__PTZVector *Position;	/* optional element of type ns2:PTZVector */
	class ns2__PTZMoveStatus *MoveStatus;	/* optional element of type ns2:PTZMoveStatus */
	std::string *Error;	/* optional element of type xsd:string */
	time_t UtcTime;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 435; } /* = unique type id SOAP_TYPE_ns2__PTZStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZStatus() { ns2__PTZStatus::soap_default(NULL); }
	virtual ~ns2__PTZStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPreset
#define SOAP_TYPE_ns2__PTZPreset (436)
/* ns2:PTZPreset */
class SOAP_CMAC ns2__PTZPreset : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type ns2:Name */
	ns2__PTZVector *PTZPosition;	/* optional element of type ns2:PTZVector */
	std::string *token;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 436; } /* = unique type id SOAP_TYPE_ns2__PTZPreset */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPreset() { ns2__PTZPreset::soap_default(NULL); }
	virtual ~ns2__PTZPreset() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZMoveStatus
#define SOAP_TYPE_ns2__PTZMoveStatus (437)
/* ns2:PTZMoveStatus */
class SOAP_CMAC ns2__PTZMoveStatus : public xsd__anyType
{
public:
	enum ns2__MoveStatus *PanTilt;	/* optional element of type ns2:MoveStatus */
	enum ns2__MoveStatus *Zoom;	/* optional element of type ns2:MoveStatus */
public:
	virtual int soap_type() const { return 437; } /* = unique type id SOAP_TYPE_ns2__PTZMoveStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZMoveStatus() { ns2__PTZMoveStatus::soap_default(NULL); }
	virtual ~ns2__PTZMoveStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PresetTour
#define SOAP_TYPE_ns2__PresetTour (438)
/* ns2:PresetTour */
class SOAP_CMAC ns2__PresetTour : public xsd__anyType
{
public:
	std::string *Name;	/* optional element of type ns2:Name */
	class ns2__PTZPresetTourStatus *Status;	/* required element of type ns2:PTZPresetTourStatus */
	bool AutoStart;	/* required element of type xsd:boolean */
	class ns2__PTZPresetTourStartingCondition *StartingCondition;	/* required element of type ns2:PTZPresetTourStartingCondition */
	std::vector<class ns2__PTZPresetTourSpot * >TourSpot;	/* optional element of type ns2:PTZPresetTourSpot */
	class ns2__PTZPresetTourExtension *Extension;	/* optional element of type ns2:PTZPresetTourExtension */
	std::string *token;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 438; } /* = unique type id SOAP_TYPE_ns2__PresetTour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PresetTour() { ns2__PresetTour::soap_default(NULL); }
	virtual ~ns2__PresetTour() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourExtension
#define SOAP_TYPE_ns2__PTZPresetTourExtension (439)
/* ns2:PTZPresetTourExtension */
class SOAP_CMAC ns2__PTZPresetTourExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 439; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourExtension() { ns2__PTZPresetTourExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourSpot
#define SOAP_TYPE_ns2__PTZPresetTourSpot (440)
/* ns2:PTZPresetTourSpot */
class SOAP_CMAC ns2__PTZPresetTourSpot : public xsd__anyType
{
public:
	class ns2__PTZPresetTourPresetDetail *PresetDetail;	/* required element of type ns2:PTZPresetTourPresetDetail */
	ns2__PTZSpeed *Speed;	/* optional element of type ns2:PTZSpeed */
	std::string *StayTime;	/* optional element of type xsd:duration */
	class ns2__PTZPresetTourSpotExtension *Extension;	/* optional element of type ns2:PTZPresetTourSpotExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 440; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourSpot */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourSpot() { ns2__PTZPresetTourSpot::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourSpot() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourSpotExtension
#define SOAP_TYPE_ns2__PTZPresetTourSpotExtension (441)
/* ns2:PTZPresetTourSpotExtension */
class SOAP_CMAC ns2__PTZPresetTourSpotExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 441; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourSpotExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourSpotExtension() { ns2__PTZPresetTourSpotExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourSpotExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_PTZPresetTourPresetDetail
#define SOAP_TYPE__ns2__union_PTZPresetTourPresetDetail (1187)
/* xsd:choice */
union _ns2__union_PTZPresetTourPresetDetail
{
#define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_PresetToken	(1)
	std::string *PresetToken;
#define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_Home	(2)
	bool Home;
#define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_PTZPosition	(3)
	ns2__PTZVector *PTZPosition;
#define SOAP_UNION__ns2__union_PTZPresetTourPresetDetail_TypeExtension	(4)
	class ns2__PTZPresetTourTypeExtension *TypeExtension;
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetail
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetail (442)
/* ns2:PTZPresetTourPresetDetail */
class SOAP_CMAC ns2__PTZPresetTourPresetDetail : public xsd__anyType
{
public:
	int __union_PTZPresetTourPresetDetail;	/* union discriminant (of union defined below) */
	union _ns2__union_PTZPresetTourPresetDetail union_PTZPresetTourPresetDetail;	/* required element of type xsd:choice */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 442; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourPresetDetail */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourPresetDetail() { ns2__PTZPresetTourPresetDetail::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourPresetDetail() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourTypeExtension
#define SOAP_TYPE_ns2__PTZPresetTourTypeExtension (443)
/* ns2:PTZPresetTourTypeExtension */
class SOAP_CMAC ns2__PTZPresetTourTypeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 443; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourTypeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourTypeExtension() { ns2__PTZPresetTourTypeExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourTypeExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourStatus
#define SOAP_TYPE_ns2__PTZPresetTourStatus (444)
/* ns2:PTZPresetTourStatus */
class SOAP_CMAC ns2__PTZPresetTourStatus : public xsd__anyType
{
public:
	enum ns2__PTZPresetTourState State;	/* required element of type ns2:PTZPresetTourState */
	ns2__PTZPresetTourSpot *CurrentTourSpot;	/* optional element of type ns2:PTZPresetTourSpot */
	class ns2__PTZPresetTourStatusExtension *Extension;	/* optional element of type ns2:PTZPresetTourStatusExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 444; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourStatus() { ns2__PTZPresetTourStatus::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourStatusExtension
#define SOAP_TYPE_ns2__PTZPresetTourStatusExtension (445)
/* ns2:PTZPresetTourStatusExtension */
class SOAP_CMAC ns2__PTZPresetTourStatusExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 445; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourStatusExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourStatusExtension() { ns2__PTZPresetTourStatusExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourStatusExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingCondition
#define SOAP_TYPE_ns2__PTZPresetTourStartingCondition (446)
/* ns2:PTZPresetTourStartingCondition */
class SOAP_CMAC ns2__PTZPresetTourStartingCondition : public xsd__anyType
{
public:
	int *RecurringTime;	/* optional element of type xsd:int */
	std::string *RecurringDuration;	/* optional element of type xsd:duration */
	enum ns2__PTZPresetTourDirection *Direction;	/* optional element of type ns2:PTZPresetTourDirection */
	class ns2__PTZPresetTourStartingConditionExtension *Extension;	/* optional element of type ns2:PTZPresetTourStartingConditionExtension */
	bool *RandomPresetOrder;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 446; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourStartingCondition */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourStartingCondition() { ns2__PTZPresetTourStartingCondition::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourStartingCondition() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension (447)
/* ns2:PTZPresetTourStartingConditionExtension */
class SOAP_CMAC ns2__PTZPresetTourStartingConditionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 447; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourStartingConditionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourStartingConditionExtension() { ns2__PTZPresetTourStartingConditionExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourStartingConditionExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourOptions
#define SOAP_TYPE_ns2__PTZPresetTourOptions (448)
/* ns2:PTZPresetTourOptions */
class SOAP_CMAC ns2__PTZPresetTourOptions : public xsd__anyType
{
public:
	bool AutoStart;	/* required element of type xsd:boolean */
	class ns2__PTZPresetTourStartingConditionOptions *StartingCondition;	/* required element of type ns2:PTZPresetTourStartingConditionOptions */
	class ns2__PTZPresetTourSpotOptions *TourSpot;	/* required element of type ns2:PTZPresetTourSpotOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 448; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourOptions() { ns2__PTZPresetTourOptions::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourSpotOptions
#define SOAP_TYPE_ns2__PTZPresetTourSpotOptions (449)
/* ns2:PTZPresetTourSpotOptions */
class SOAP_CMAC ns2__PTZPresetTourSpotOptions : public xsd__anyType
{
public:
	class ns2__PTZPresetTourPresetDetailOptions *PresetDetail;	/* required element of type ns2:PTZPresetTourPresetDetailOptions */
	ns2__DurationRange *StayTime;	/* required element of type ns2:DurationRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 449; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourSpotOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourSpotOptions() { ns2__PTZPresetTourSpotOptions::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourSpotOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions (450)
/* ns2:PTZPresetTourPresetDetailOptions */
class SOAP_CMAC ns2__PTZPresetTourPresetDetailOptions : public xsd__anyType
{
public:
	std::vector<std::string >PresetToken;	/* optional element of type ns2:ReferenceToken */
	bool *Home;	/* optional element of type xsd:boolean */
	ns2__Space2DDescription *PanTiltPositionSpace;	/* optional element of type ns2:Space2DDescription */
	ns2__Space1DDescription *ZoomPositionSpace;	/* optional element of type ns2:Space1DDescription */
	class ns2__PTZPresetTourPresetDetailOptionsExtension *Extension;	/* optional element of type ns2:PTZPresetTourPresetDetailOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 450; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourPresetDetailOptions() { ns2__PTZPresetTourPresetDetailOptions::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourPresetDetailOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension
#define SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension (451)
/* ns2:PTZPresetTourPresetDetailOptionsExtension */
class SOAP_CMAC ns2__PTZPresetTourPresetDetailOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 451; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourPresetDetailOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourPresetDetailOptionsExtension() { ns2__PTZPresetTourPresetDetailOptionsExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourPresetDetailOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions (452)
/* ns2:PTZPresetTourStartingConditionOptions */
class SOAP_CMAC ns2__PTZPresetTourStartingConditionOptions : public xsd__anyType
{
public:
	ns2__IntRange *RecurringTime;	/* optional element of type ns2:IntRange */
	ns2__DurationRange *RecurringDuration;	/* optional element of type ns2:DurationRange */
	std::vector<enum ns2__PTZPresetTourDirection >Direction;	/* optional element of type ns2:PTZPresetTourDirection */
	class ns2__PTZPresetTourStartingConditionOptionsExtension *Extension;	/* optional element of type ns2:PTZPresetTourStartingConditionOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 452; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourStartingConditionOptions() { ns2__PTZPresetTourStartingConditionOptions::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourStartingConditionOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension
#define SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension (453)
/* ns2:PTZPresetTourStartingConditionOptionsExtension */
class SOAP_CMAC ns2__PTZPresetTourStartingConditionOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 453; } /* = unique type id SOAP_TYPE_ns2__PTZPresetTourStartingConditionOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPresetTourStartingConditionOptionsExtension() { ns2__PTZPresetTourStartingConditionOptionsExtension::soap_default(NULL); }
	virtual ~ns2__PTZPresetTourStartingConditionOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingStatus
#define SOAP_TYPE_ns2__ImagingStatus (454)
/* ns2:ImagingStatus */
class SOAP_CMAC ns2__ImagingStatus : public xsd__anyType
{
public:
	class ns2__FocusStatus *FocusStatus;	/* required element of type ns2:FocusStatus */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 454; } /* = unique type id SOAP_TYPE_ns2__ImagingStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingStatus() { ns2__ImagingStatus::soap_default(NULL); }
	virtual ~ns2__ImagingStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusStatus
#define SOAP_TYPE_ns2__FocusStatus (455)
/* ns2:FocusStatus */
class SOAP_CMAC ns2__FocusStatus : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	enum ns2__MoveStatus MoveStatus;	/* required element of type ns2:MoveStatus */
	std::string Error;	/* required element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 455; } /* = unique type id SOAP_TYPE_ns2__FocusStatus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusStatus() { ns2__FocusStatus::soap_default(NULL); }
	virtual ~ns2__FocusStatus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusConfiguration
#define SOAP_TYPE_ns2__FocusConfiguration (456)
/* ns2:FocusConfiguration */
class SOAP_CMAC ns2__FocusConfiguration : public xsd__anyType
{
public:
	enum ns2__AutoFocusMode AutoFocusMode;	/* required element of type ns2:AutoFocusMode */
	float DefaultSpeed;	/* required element of type xsd:float */
	float NearLimit;	/* required element of type xsd:float */
	float FarLimit;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 456; } /* = unique type id SOAP_TYPE_ns2__FocusConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusConfiguration() { ns2__FocusConfiguration::soap_default(NULL); }
	virtual ~ns2__FocusConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingSettings
#define SOAP_TYPE_ns2__ImagingSettings (457)
/* ns2:ImagingSettings */
class SOAP_CMAC ns2__ImagingSettings : public xsd__anyType
{
public:
	class ns2__BacklightCompensation *BacklightCompensation;	/* optional element of type ns2:BacklightCompensation */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class ns2__Exposure *Exposure;	/* optional element of type ns2:Exposure */
	ns2__FocusConfiguration *Focus;	/* optional element of type ns2:FocusConfiguration */
	enum ns2__IrCutFilterMode *IrCutFilter;	/* optional element of type ns2:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class ns2__WideDynamicRange *WideDynamicRange;	/* optional element of type ns2:WideDynamicRange */
	class ns2__WhiteBalance *WhiteBalance;	/* optional element of type ns2:WhiteBalance */
	class ns2__ImagingSettingsExtension *Extension;	/* optional element of type ns2:ImagingSettingsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 457; } /* = unique type id SOAP_TYPE_ns2__ImagingSettings */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingSettings() { ns2__ImagingSettings::soap_default(NULL); }
	virtual ~ns2__ImagingSettings() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension
#define SOAP_TYPE_ns2__ImagingSettingsExtension (458)
/* ns2:ImagingSettingsExtension */
class SOAP_CMAC ns2__ImagingSettingsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 458; } /* = unique type id SOAP_TYPE_ns2__ImagingSettingsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingSettingsExtension() { ns2__ImagingSettingsExtension::soap_default(NULL); }
	virtual ~ns2__ImagingSettingsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Exposure
#define SOAP_TYPE_ns2__Exposure (459)
/* ns2:Exposure */
class SOAP_CMAC ns2__Exposure : public xsd__anyType
{
public:
	enum ns2__ExposureMode Mode;	/* required element of type ns2:ExposureMode */
	enum ns2__ExposurePriority Priority;	/* required element of type ns2:ExposurePriority */
	class ns2__Rectangle *Window;	/* required element of type ns2:Rectangle */
	float MinExposureTime;	/* required element of type xsd:float */
	float MaxExposureTime;	/* required element of type xsd:float */
	float MinGain;	/* required element of type xsd:float */
	float MaxGain;	/* required element of type xsd:float */
	float MinIris;	/* required element of type xsd:float */
	float MaxIris;	/* required element of type xsd:float */
	float ExposureTime;	/* required element of type xsd:float */
	float Gain;	/* required element of type xsd:float */
	float Iris;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 459; } /* = unique type id SOAP_TYPE_ns2__Exposure */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Exposure() { ns2__Exposure::soap_default(NULL); }
	virtual ~ns2__Exposure() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WideDynamicRange
#define SOAP_TYPE_ns2__WideDynamicRange (460)
/* ns2:WideDynamicRange */
class SOAP_CMAC ns2__WideDynamicRange : public xsd__anyType
{
public:
	enum ns2__WideDynamicMode Mode;	/* required element of type ns2:WideDynamicMode */
	float Level;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 460; } /* = unique type id SOAP_TYPE_ns2__WideDynamicRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WideDynamicRange() { ns2__WideDynamicRange::soap_default(NULL); }
	virtual ~ns2__WideDynamicRange() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BacklightCompensation
#define SOAP_TYPE_ns2__BacklightCompensation (461)
/* ns2:BacklightCompensation */
class SOAP_CMAC ns2__BacklightCompensation : public xsd__anyType
{
public:
	enum ns2__BacklightCompensationMode Mode;	/* required element of type ns2:BacklightCompensationMode */
	float Level;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 461; } /* = unique type id SOAP_TYPE_ns2__BacklightCompensation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BacklightCompensation() { ns2__BacklightCompensation::soap_default(NULL); }
	virtual ~ns2__BacklightCompensation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingOptions
#define SOAP_TYPE_ns2__ImagingOptions (462)
/* ns2:ImagingOptions */
class SOAP_CMAC ns2__ImagingOptions : public xsd__anyType
{
public:
	class ns2__BacklightCompensationOptions *BacklightCompensation;	/* required element of type ns2:BacklightCompensationOptions */
	ns2__FloatRange *Brightness;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *ColorSaturation;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Contrast;	/* required element of type ns2:FloatRange */
	class ns2__ExposureOptions *Exposure;	/* required element of type ns2:ExposureOptions */
	class ns2__FocusOptions *Focus;	/* required element of type ns2:FocusOptions */
	std::vector<enum ns2__IrCutFilterMode >IrCutFilterModes;	/* required element of type ns2:IrCutFilterMode */
	ns2__FloatRange *Sharpness;	/* required element of type ns2:FloatRange */
	class ns2__WideDynamicRangeOptions *WideDynamicRange;	/* required element of type ns2:WideDynamicRangeOptions */
	class ns2__WhiteBalanceOptions *WhiteBalance;	/* required element of type ns2:WhiteBalanceOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 462; } /* = unique type id SOAP_TYPE_ns2__ImagingOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingOptions() { ns2__ImagingOptions::soap_default(NULL); }
	virtual ~ns2__ImagingOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WideDynamicRangeOptions
#define SOAP_TYPE_ns2__WideDynamicRangeOptions (463)
/* ns2:WideDynamicRangeOptions */
class SOAP_CMAC ns2__WideDynamicRangeOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__WideDynamicMode >Mode;	/* required element of type ns2:WideDynamicMode */
	ns2__FloatRange *Level;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 463; } /* = unique type id SOAP_TYPE_ns2__WideDynamicRangeOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WideDynamicRangeOptions() { ns2__WideDynamicRangeOptions::soap_default(NULL); }
	virtual ~ns2__WideDynamicRangeOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BacklightCompensationOptions
#define SOAP_TYPE_ns2__BacklightCompensationOptions (464)
/* ns2:BacklightCompensationOptions */
class SOAP_CMAC ns2__BacklightCompensationOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__WideDynamicMode >Mode;	/* required element of type ns2:WideDynamicMode */
	ns2__FloatRange *Level;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 464; } /* = unique type id SOAP_TYPE_ns2__BacklightCompensationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BacklightCompensationOptions() { ns2__BacklightCompensationOptions::soap_default(NULL); }
	virtual ~ns2__BacklightCompensationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusOptions
#define SOAP_TYPE_ns2__FocusOptions (465)
/* ns2:FocusOptions */
class SOAP_CMAC ns2__FocusOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__AutoFocusMode >AutoFocusModes;	/* optional element of type ns2:AutoFocusMode */
	ns2__FloatRange *DefaultSpeed;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *NearLimit;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *FarLimit;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 465; } /* = unique type id SOAP_TYPE_ns2__FocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusOptions() { ns2__FocusOptions::soap_default(NULL); }
	virtual ~ns2__FocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ExposureOptions
#define SOAP_TYPE_ns2__ExposureOptions (466)
/* ns2:ExposureOptions */
class SOAP_CMAC ns2__ExposureOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__ExposureMode >Mode;	/* required element of type ns2:ExposureMode */
	std::vector<enum ns2__ExposurePriority >Priority;	/* required element of type ns2:ExposurePriority */
	ns2__FloatRange *MinExposureTime;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *MaxExposureTime;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *MinGain;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *MaxGain;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *MinIris;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *MaxIris;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *ExposureTime;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Gain;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Iris;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 466; } /* = unique type id SOAP_TYPE_ns2__ExposureOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ExposureOptions() { ns2__ExposureOptions::soap_default(NULL); }
	virtual ~ns2__ExposureOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions
#define SOAP_TYPE_ns2__WhiteBalanceOptions (467)
/* ns2:WhiteBalanceOptions */
class SOAP_CMAC ns2__WhiteBalanceOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__WhiteBalanceMode >Mode;	/* required element of type ns2:WhiteBalanceMode */
	ns2__FloatRange *YrGain;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *YbGain;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 467; } /* = unique type id SOAP_TYPE_ns2__WhiteBalanceOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WhiteBalanceOptions() { ns2__WhiteBalanceOptions::soap_default(NULL); }
	virtual ~ns2__WhiteBalanceOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusMove
#define SOAP_TYPE_ns2__FocusMove (468)
/* ns2:FocusMove */
class SOAP_CMAC ns2__FocusMove : public xsd__anyType
{
public:
	class ns2__AbsoluteFocus *Absolute;	/* optional element of type ns2:AbsoluteFocus */
	class ns2__RelativeFocus *Relative;	/* optional element of type ns2:RelativeFocus */
	class ns2__ContinuousFocus *Continuous;	/* optional element of type ns2:ContinuousFocus */
public:
	virtual int soap_type() const { return 468; } /* = unique type id SOAP_TYPE_ns2__FocusMove */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusMove() { ns2__FocusMove::soap_default(NULL); }
	virtual ~ns2__FocusMove() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AbsoluteFocus
#define SOAP_TYPE_ns2__AbsoluteFocus (469)
/* ns2:AbsoluteFocus */
class SOAP_CMAC ns2__AbsoluteFocus : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 469; } /* = unique type id SOAP_TYPE_ns2__AbsoluteFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AbsoluteFocus() { ns2__AbsoluteFocus::soap_default(NULL); }
	virtual ~ns2__AbsoluteFocus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelativeFocus
#define SOAP_TYPE_ns2__RelativeFocus (470)
/* ns2:RelativeFocus */
class SOAP_CMAC ns2__RelativeFocus : public xsd__anyType
{
public:
	float Distance;	/* required element of type xsd:float */
	float *Speed;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 470; } /* = unique type id SOAP_TYPE_ns2__RelativeFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelativeFocus() { ns2__RelativeFocus::soap_default(NULL); }
	virtual ~ns2__RelativeFocus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ContinuousFocus
#define SOAP_TYPE_ns2__ContinuousFocus (471)
/* ns2:ContinuousFocus */
class SOAP_CMAC ns2__ContinuousFocus : public xsd__anyType
{
public:
	float Speed;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 471; } /* = unique type id SOAP_TYPE_ns2__ContinuousFocus */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ContinuousFocus() { ns2__ContinuousFocus::soap_default(NULL); }
	virtual ~ns2__ContinuousFocus() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MoveOptions
#define SOAP_TYPE_ns2__MoveOptions (472)
/* ns2:MoveOptions */
class SOAP_CMAC ns2__MoveOptions : public xsd__anyType
{
public:
	class ns2__AbsoluteFocusOptions *Absolute;	/* optional element of type ns2:AbsoluteFocusOptions */
	class ns2__RelativeFocusOptions *Relative;	/* optional element of type ns2:RelativeFocusOptions */
	class ns2__ContinuousFocusOptions *Continuous;	/* optional element of type ns2:ContinuousFocusOptions */
public:
	virtual int soap_type() const { return 472; } /* = unique type id SOAP_TYPE_ns2__MoveOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MoveOptions() { ns2__MoveOptions::soap_default(NULL); }
	virtual ~ns2__MoveOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AbsoluteFocusOptions
#define SOAP_TYPE_ns2__AbsoluteFocusOptions (473)
/* ns2:AbsoluteFocusOptions */
class SOAP_CMAC ns2__AbsoluteFocusOptions : public xsd__anyType
{
public:
	ns2__FloatRange *Position;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Speed;	/* optional element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 473; } /* = unique type id SOAP_TYPE_ns2__AbsoluteFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AbsoluteFocusOptions() { ns2__AbsoluteFocusOptions::soap_default(NULL); }
	virtual ~ns2__AbsoluteFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelativeFocusOptions
#define SOAP_TYPE_ns2__RelativeFocusOptions (474)
/* ns2:RelativeFocusOptions */
class SOAP_CMAC ns2__RelativeFocusOptions : public xsd__anyType
{
public:
	ns2__FloatRange *Distance;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Speed;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 474; } /* = unique type id SOAP_TYPE_ns2__RelativeFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelativeFocusOptions() { ns2__RelativeFocusOptions::soap_default(NULL); }
	virtual ~ns2__RelativeFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ContinuousFocusOptions
#define SOAP_TYPE_ns2__ContinuousFocusOptions (475)
/* ns2:ContinuousFocusOptions */
class SOAP_CMAC ns2__ContinuousFocusOptions : public xsd__anyType
{
public:
	ns2__FloatRange *Speed;	/* required element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 475; } /* = unique type id SOAP_TYPE_ns2__ContinuousFocusOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ContinuousFocusOptions() { ns2__ContinuousFocusOptions::soap_default(NULL); }
	virtual ~ns2__ContinuousFocusOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalance
#define SOAP_TYPE_ns2__WhiteBalance (476)
/* ns2:WhiteBalance */
class SOAP_CMAC ns2__WhiteBalance : public xsd__anyType
{
public:
	enum ns2__WhiteBalanceMode Mode;	/* required element of type ns2:WhiteBalanceMode */
	float CrGain;	/* required element of type xsd:float */
	float CbGain;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 476; } /* = unique type id SOAP_TYPE_ns2__WhiteBalance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WhiteBalance() { ns2__WhiteBalance::soap_default(NULL); }
	virtual ~ns2__WhiteBalance() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingStatus20
#define SOAP_TYPE_ns2__ImagingStatus20 (477)
/* ns2:ImagingStatus20 */
class SOAP_CMAC ns2__ImagingStatus20 : public xsd__anyType
{
public:
	class ns2__FocusStatus20 *FocusStatus20;	/* optional element of type ns2:FocusStatus20 */
	class ns2__ImagingStatus20Extension *Extension;	/* optional element of type ns2:ImagingStatus20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 477; } /* = unique type id SOAP_TYPE_ns2__ImagingStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingStatus20() { ns2__ImagingStatus20::soap_default(NULL); }
	virtual ~ns2__ImagingStatus20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingStatus20Extension
#define SOAP_TYPE_ns2__ImagingStatus20Extension (478)
/* ns2:ImagingStatus20Extension */
class SOAP_CMAC ns2__ImagingStatus20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 478; } /* = unique type id SOAP_TYPE_ns2__ImagingStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingStatus20Extension() { ns2__ImagingStatus20Extension::soap_default(NULL); }
	virtual ~ns2__ImagingStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusStatus20
#define SOAP_TYPE_ns2__FocusStatus20 (479)
/* ns2:FocusStatus20 */
class SOAP_CMAC ns2__FocusStatus20 : public xsd__anyType
{
public:
	float Position;	/* required element of type xsd:float */
	enum ns2__MoveStatus MoveStatus;	/* required element of type ns2:MoveStatus */
	std::string *Error;	/* optional element of type xsd:string */
	class ns2__FocusStatus20Extension *Extension;	/* optional element of type ns2:FocusStatus20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 479; } /* = unique type id SOAP_TYPE_ns2__FocusStatus20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusStatus20() { ns2__FocusStatus20::soap_default(NULL); }
	virtual ~ns2__FocusStatus20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusStatus20Extension
#define SOAP_TYPE_ns2__FocusStatus20Extension (480)
/* ns2:FocusStatus20Extension */
class SOAP_CMAC ns2__FocusStatus20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 480; } /* = unique type id SOAP_TYPE_ns2__FocusStatus20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusStatus20Extension() { ns2__FocusStatus20Extension::soap_default(NULL); }
	virtual ~ns2__FocusStatus20Extension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingSettings20
#define SOAP_TYPE_ns2__ImagingSettings20 (481)
/* ns2:ImagingSettings20 */
class SOAP_CMAC ns2__ImagingSettings20 : public xsd__anyType
{
public:
	class ns2__BacklightCompensation20 *BacklightCompensation;	/* optional element of type ns2:BacklightCompensation20 */
	float *Brightness;	/* optional element of type xsd:float */
	float *ColorSaturation;	/* optional element of type xsd:float */
	float *Contrast;	/* optional element of type xsd:float */
	class ns2__Exposure20 *Exposure;	/* optional element of type ns2:Exposure20 */
	class ns2__FocusConfiguration20 *Focus;	/* optional element of type ns2:FocusConfiguration20 */
	enum ns2__IrCutFilterMode *IrCutFilter;	/* optional element of type ns2:IrCutFilterMode */
	float *Sharpness;	/* optional element of type xsd:float */
	class ns2__WideDynamicRange20 *WideDynamicRange;	/* optional element of type ns2:WideDynamicRange20 */
	class ns2__WhiteBalance20 *WhiteBalance;	/* optional element of type ns2:WhiteBalance20 */
	class ns2__ImagingSettingsExtension20 *Extension;	/* optional element of type ns2:ImagingSettingsExtension20 */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 481; } /* = unique type id SOAP_TYPE_ns2__ImagingSettings20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingSettings20() { ns2__ImagingSettings20::soap_default(NULL); }
	virtual ~ns2__ImagingSettings20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension20
#define SOAP_TYPE_ns2__ImagingSettingsExtension20 (482)
/* ns2:ImagingSettingsExtension20 */
class SOAP_CMAC ns2__ImagingSettingsExtension20 : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__ImageStabilization *ImageStabilization;	/* optional element of type ns2:ImageStabilization */
	class ns2__ImagingSettingsExtension202 *Extension;	/* optional element of type ns2:ImagingSettingsExtension202 */
public:
	virtual int soap_type() const { return 482; } /* = unique type id SOAP_TYPE_ns2__ImagingSettingsExtension20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingSettingsExtension20() { ns2__ImagingSettingsExtension20::soap_default(NULL); }
	virtual ~ns2__ImagingSettingsExtension20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension202
#define SOAP_TYPE_ns2__ImagingSettingsExtension202 (483)
/* ns2:ImagingSettingsExtension202 */
class SOAP_CMAC ns2__ImagingSettingsExtension202 : public xsd__anyType
{
public:
	std::vector<class ns2__IrCutFilterAutoAdjustment * >IrCutFilterAutoAdjustment;	/* optional element of type ns2:IrCutFilterAutoAdjustment */
	class ns2__ImagingSettingsExtension203 *Extension;	/* optional element of type ns2:ImagingSettingsExtension203 */
public:
	virtual int soap_type() const { return 483; } /* = unique type id SOAP_TYPE_ns2__ImagingSettingsExtension202 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingSettingsExtension202() { ns2__ImagingSettingsExtension202::soap_default(NULL); }
	virtual ~ns2__ImagingSettingsExtension202() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension203
#define SOAP_TYPE_ns2__ImagingSettingsExtension203 (484)
/* ns2:ImagingSettingsExtension203 */
class SOAP_CMAC ns2__ImagingSettingsExtension203 : public xsd__anyType
{
public:
	class ns2__ToneCompensation *ToneCompensation;	/* optional element of type ns2:ToneCompensation */
	class ns2__Defogging *Defogging;	/* optional element of type ns2:Defogging */
	class ns2__NoiseReduction *NoiseReduction;	/* optional element of type ns2:NoiseReduction */
	class ns2__ImagingSettingsExtension204 *Extension;	/* optional element of type ns2:ImagingSettingsExtension204 */
public:
	virtual int soap_type() const { return 484; } /* = unique type id SOAP_TYPE_ns2__ImagingSettingsExtension203 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingSettingsExtension203() { ns2__ImagingSettingsExtension203::soap_default(NULL); }
	virtual ~ns2__ImagingSettingsExtension203() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingSettingsExtension204
#define SOAP_TYPE_ns2__ImagingSettingsExtension204 (485)
/* ns2:ImagingSettingsExtension204 */
class SOAP_CMAC ns2__ImagingSettingsExtension204 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 485; } /* = unique type id SOAP_TYPE_ns2__ImagingSettingsExtension204 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingSettingsExtension204() { ns2__ImagingSettingsExtension204::soap_default(NULL); }
	virtual ~ns2__ImagingSettingsExtension204() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImageStabilization
#define SOAP_TYPE_ns2__ImageStabilization (486)
/* ns2:ImageStabilization */
class SOAP_CMAC ns2__ImageStabilization : public xsd__anyType
{
public:
	enum ns2__ImageStabilizationMode Mode;	/* required element of type ns2:ImageStabilizationMode */
	float *Level;	/* optional element of type xsd:float */
	class ns2__ImageStabilizationExtension *Extension;	/* optional element of type ns2:ImageStabilizationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 486; } /* = unique type id SOAP_TYPE_ns2__ImageStabilization */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImageStabilization() { ns2__ImageStabilization::soap_default(NULL); }
	virtual ~ns2__ImageStabilization() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImageStabilizationExtension
#define SOAP_TYPE_ns2__ImageStabilizationExtension (487)
/* ns2:ImageStabilizationExtension */
class SOAP_CMAC ns2__ImageStabilizationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 487; } /* = unique type id SOAP_TYPE_ns2__ImageStabilizationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImageStabilizationExtension() { ns2__ImageStabilizationExtension::soap_default(NULL); }
	virtual ~ns2__ImageStabilizationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustment
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustment (488)
/* ns2:IrCutFilterAutoAdjustment */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustment : public xsd__anyType
{
public:
	std::string BoundaryType;	/* required element of type xsd:string */
	float *BoundaryOffset;	/* optional element of type xsd:float */
	std::string *ResponseTime;	/* optional element of type xsd:duration */
	class ns2__IrCutFilterAutoAdjustmentExtension *Extension;	/* optional element of type ns2:IrCutFilterAutoAdjustmentExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 488; } /* = unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustment */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IrCutFilterAutoAdjustment() { ns2__IrCutFilterAutoAdjustment::soap_default(NULL); }
	virtual ~ns2__IrCutFilterAutoAdjustment() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension (489)
/* ns2:IrCutFilterAutoAdjustmentExtension */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustmentExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 489; } /* = unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IrCutFilterAutoAdjustmentExtension() { ns2__IrCutFilterAutoAdjustmentExtension::soap_default(NULL); }
	virtual ~ns2__IrCutFilterAutoAdjustmentExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WideDynamicRange20
#define SOAP_TYPE_ns2__WideDynamicRange20 (490)
/* ns2:WideDynamicRange20 */
class SOAP_CMAC ns2__WideDynamicRange20 : public xsd__anyType
{
public:
	enum ns2__WideDynamicMode Mode;	/* required element of type ns2:WideDynamicMode */
	float *Level;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 490; } /* = unique type id SOAP_TYPE_ns2__WideDynamicRange20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WideDynamicRange20() { ns2__WideDynamicRange20::soap_default(NULL); }
	virtual ~ns2__WideDynamicRange20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BacklightCompensation20
#define SOAP_TYPE_ns2__BacklightCompensation20 (491)
/* ns2:BacklightCompensation20 */
class SOAP_CMAC ns2__BacklightCompensation20 : public xsd__anyType
{
public:
	enum ns2__BacklightCompensationMode Mode;	/* required element of type ns2:BacklightCompensationMode */
	float *Level;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 491; } /* = unique type id SOAP_TYPE_ns2__BacklightCompensation20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BacklightCompensation20() { ns2__BacklightCompensation20::soap_default(NULL); }
	virtual ~ns2__BacklightCompensation20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Exposure20
#define SOAP_TYPE_ns2__Exposure20 (492)
/* ns2:Exposure20 */
class SOAP_CMAC ns2__Exposure20 : public xsd__anyType
{
public:
	enum ns2__ExposureMode Mode;	/* required element of type ns2:ExposureMode */
	enum ns2__ExposurePriority *Priority;	/* optional element of type ns2:ExposurePriority */
	ns2__Rectangle *Window;	/* optional element of type ns2:Rectangle */
	float *MinExposureTime;	/* optional element of type xsd:float */
	float *MaxExposureTime;	/* optional element of type xsd:float */
	float *MinGain;	/* optional element of type xsd:float */
	float *MaxGain;	/* optional element of type xsd:float */
	float *MinIris;	/* optional element of type xsd:float */
	float *MaxIris;	/* optional element of type xsd:float */
	float *ExposureTime;	/* optional element of type xsd:float */
	float *Gain;	/* optional element of type xsd:float */
	float *Iris;	/* optional element of type xsd:float */
public:
	virtual int soap_type() const { return 492; } /* = unique type id SOAP_TYPE_ns2__Exposure20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Exposure20() { ns2__Exposure20::soap_default(NULL); }
	virtual ~ns2__Exposure20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ToneCompensation
#define SOAP_TYPE_ns2__ToneCompensation (493)
/* ns2:ToneCompensation */
class SOAP_CMAC ns2__ToneCompensation : public xsd__anyType
{
public:
	std::string Mode;	/* required element of type xsd:string */
	float *Level;	/* optional element of type xsd:float */
	class ns2__ToneCompensationExtension *Extension;	/* optional element of type ns2:ToneCompensationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 493; } /* = unique type id SOAP_TYPE_ns2__ToneCompensation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ToneCompensation() { ns2__ToneCompensation::soap_default(NULL); }
	virtual ~ns2__ToneCompensation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ToneCompensationExtension
#define SOAP_TYPE_ns2__ToneCompensationExtension (494)
/* ns2:ToneCompensationExtension */
class SOAP_CMAC ns2__ToneCompensationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 494; } /* = unique type id SOAP_TYPE_ns2__ToneCompensationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ToneCompensationExtension() { ns2__ToneCompensationExtension::soap_default(NULL); }
	virtual ~ns2__ToneCompensationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Defogging
#define SOAP_TYPE_ns2__Defogging (495)
/* ns2:Defogging */
class SOAP_CMAC ns2__Defogging : public xsd__anyType
{
public:
	std::string Mode;	/* required element of type xsd:string */
	float *Level;	/* optional element of type xsd:float */
	class ns2__DefoggingExtension *Extension;	/* optional element of type ns2:DefoggingExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 495; } /* = unique type id SOAP_TYPE_ns2__Defogging */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Defogging() { ns2__Defogging::soap_default(NULL); }
	virtual ~ns2__Defogging() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DefoggingExtension
#define SOAP_TYPE_ns2__DefoggingExtension (496)
/* ns2:DefoggingExtension */
class SOAP_CMAC ns2__DefoggingExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 496; } /* = unique type id SOAP_TYPE_ns2__DefoggingExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DefoggingExtension() { ns2__DefoggingExtension::soap_default(NULL); }
	virtual ~ns2__DefoggingExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NoiseReduction
#define SOAP_TYPE_ns2__NoiseReduction (497)
/* ns2:NoiseReduction */
class SOAP_CMAC ns2__NoiseReduction : public xsd__anyType
{
public:
	float Level;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 497; } /* = unique type id SOAP_TYPE_ns2__NoiseReduction */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NoiseReduction() { ns2__NoiseReduction::soap_default(NULL); }
	virtual ~ns2__NoiseReduction() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingOptions20
#define SOAP_TYPE_ns2__ImagingOptions20 (498)
/* ns2:ImagingOptions20 */
class SOAP_CMAC ns2__ImagingOptions20 : public xsd__anyType
{
public:
	class ns2__BacklightCompensationOptions20 *BacklightCompensation;	/* optional element of type ns2:BacklightCompensationOptions20 */
	ns2__FloatRange *Brightness;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *ColorSaturation;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *Contrast;	/* optional element of type ns2:FloatRange */
	class ns2__ExposureOptions20 *Exposure;	/* optional element of type ns2:ExposureOptions20 */
	class ns2__FocusOptions20 *Focus;	/* optional element of type ns2:FocusOptions20 */
	std::vector<enum ns2__IrCutFilterMode >IrCutFilterModes;	/* optional element of type ns2:IrCutFilterMode */
	ns2__FloatRange *Sharpness;	/* optional element of type ns2:FloatRange */
	class ns2__WideDynamicRangeOptions20 *WideDynamicRange;	/* optional element of type ns2:WideDynamicRangeOptions20 */
	class ns2__WhiteBalanceOptions20 *WhiteBalance;	/* optional element of type ns2:WhiteBalanceOptions20 */
	class ns2__ImagingOptions20Extension *Extension;	/* optional element of type ns2:ImagingOptions20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 498; } /* = unique type id SOAP_TYPE_ns2__ImagingOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingOptions20() { ns2__ImagingOptions20::soap_default(NULL); }
	virtual ~ns2__ImagingOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension
#define SOAP_TYPE_ns2__ImagingOptions20Extension (499)
/* ns2:ImagingOptions20Extension */
class SOAP_CMAC ns2__ImagingOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__ImageStabilizationOptions *ImageStabilization;	/* optional element of type ns2:ImageStabilizationOptions */
	class ns2__ImagingOptions20Extension2 *Extension;	/* optional element of type ns2:ImagingOptions20Extension2 */
public:
	virtual int soap_type() const { return 499; } /* = unique type id SOAP_TYPE_ns2__ImagingOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingOptions20Extension() { ns2__ImagingOptions20Extension::soap_default(NULL); }
	virtual ~ns2__ImagingOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension2
#define SOAP_TYPE_ns2__ImagingOptions20Extension2 (500)
/* ns2:ImagingOptions20Extension2 */
class SOAP_CMAC ns2__ImagingOptions20Extension2 : public xsd__anyType
{
public:
	class ns2__IrCutFilterAutoAdjustmentOptions *IrCutFilterAutoAdjustment;	/* optional element of type ns2:IrCutFilterAutoAdjustmentOptions */
	class ns2__ImagingOptions20Extension3 *Extension;	/* optional element of type ns2:ImagingOptions20Extension3 */
public:
	virtual int soap_type() const { return 500; } /* = unique type id SOAP_TYPE_ns2__ImagingOptions20Extension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingOptions20Extension2() { ns2__ImagingOptions20Extension2::soap_default(NULL); }
	virtual ~ns2__ImagingOptions20Extension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension3
#define SOAP_TYPE_ns2__ImagingOptions20Extension3 (501)
/* ns2:ImagingOptions20Extension3 */
class SOAP_CMAC ns2__ImagingOptions20Extension3 : public xsd__anyType
{
public:
	class ns2__ToneCompensationOptions *ToneCompensationOptions;	/* optional element of type ns2:ToneCompensationOptions */
	class ns2__DefoggingOptions *DefoggingOptions;	/* optional element of type ns2:DefoggingOptions */
	class ns2__NoiseReductionOptions *NoiseReductionOptions;	/* optional element of type ns2:NoiseReductionOptions */
	class ns2__ImagingOptions20Extension4 *Extension;	/* optional element of type ns2:ImagingOptions20Extension4 */
public:
	virtual int soap_type() const { return 501; } /* = unique type id SOAP_TYPE_ns2__ImagingOptions20Extension3 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingOptions20Extension3() { ns2__ImagingOptions20Extension3::soap_default(NULL); }
	virtual ~ns2__ImagingOptions20Extension3() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImagingOptions20Extension4
#define SOAP_TYPE_ns2__ImagingOptions20Extension4 (502)
/* ns2:ImagingOptions20Extension4 */
class SOAP_CMAC ns2__ImagingOptions20Extension4 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 502; } /* = unique type id SOAP_TYPE_ns2__ImagingOptions20Extension4 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImagingOptions20Extension4() { ns2__ImagingOptions20Extension4::soap_default(NULL); }
	virtual ~ns2__ImagingOptions20Extension4() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImageStabilizationOptions
#define SOAP_TYPE_ns2__ImageStabilizationOptions (503)
/* ns2:ImageStabilizationOptions */
class SOAP_CMAC ns2__ImageStabilizationOptions : public xsd__anyType
{
public:
	std::vector<enum ns2__ImageStabilizationMode >Mode;	/* required element of type ns2:ImageStabilizationMode */
	ns2__FloatRange *Level;	/* optional element of type ns2:FloatRange */
	class ns2__ImageStabilizationOptionsExtension *Extension;	/* optional element of type ns2:ImageStabilizationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 503; } /* = unique type id SOAP_TYPE_ns2__ImageStabilizationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImageStabilizationOptions() { ns2__ImageStabilizationOptions::soap_default(NULL); }
	virtual ~ns2__ImageStabilizationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ImageStabilizationOptionsExtension
#define SOAP_TYPE_ns2__ImageStabilizationOptionsExtension (504)
/* ns2:ImageStabilizationOptionsExtension */
class SOAP_CMAC ns2__ImageStabilizationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 504; } /* = unique type id SOAP_TYPE_ns2__ImageStabilizationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ImageStabilizationOptionsExtension() { ns2__ImageStabilizationOptionsExtension::soap_default(NULL); }
	virtual ~ns2__ImageStabilizationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions (505)
/* ns2:IrCutFilterAutoAdjustmentOptions */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustmentOptions : public xsd__anyType
{
public:
	std::vector<std::string >BoundaryType;	/* required element of type xsd:string */
	bool *BoundaryOffset;	/* optional element of type xsd:boolean */
	ns2__DurationRange *ResponseTimeRange;	/* optional element of type ns2:DurationRange */
	class ns2__IrCutFilterAutoAdjustmentOptionsExtension *Extension;	/* optional element of type ns2:IrCutFilterAutoAdjustmentOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 505; } /* = unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IrCutFilterAutoAdjustmentOptions() { ns2__IrCutFilterAutoAdjustmentOptions::soap_default(NULL); }
	virtual ~ns2__IrCutFilterAutoAdjustmentOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension
#define SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension (506)
/* ns2:IrCutFilterAutoAdjustmentOptionsExtension */
class SOAP_CMAC ns2__IrCutFilterAutoAdjustmentOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 506; } /* = unique type id SOAP_TYPE_ns2__IrCutFilterAutoAdjustmentOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__IrCutFilterAutoAdjustmentOptionsExtension() { ns2__IrCutFilterAutoAdjustmentOptionsExtension::soap_default(NULL); }
	virtual ~ns2__IrCutFilterAutoAdjustmentOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WideDynamicRangeOptions20
#define SOAP_TYPE_ns2__WideDynamicRangeOptions20 (507)
/* ns2:WideDynamicRangeOptions20 */
class SOAP_CMAC ns2__WideDynamicRangeOptions20 : public xsd__anyType
{
public:
	std::vector<enum ns2__WideDynamicMode >Mode;	/* required element of type ns2:WideDynamicMode */
	ns2__FloatRange *Level;	/* optional element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 507; } /* = unique type id SOAP_TYPE_ns2__WideDynamicRangeOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WideDynamicRangeOptions20() { ns2__WideDynamicRangeOptions20::soap_default(NULL); }
	virtual ~ns2__WideDynamicRangeOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BacklightCompensationOptions20
#define SOAP_TYPE_ns2__BacklightCompensationOptions20 (508)
/* ns2:BacklightCompensationOptions20 */
class SOAP_CMAC ns2__BacklightCompensationOptions20 : public xsd__anyType
{
public:
	std::vector<enum ns2__BacklightCompensationMode >Mode;	/* required element of type ns2:BacklightCompensationMode */
	ns2__FloatRange *Level;	/* optional element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 508; } /* = unique type id SOAP_TYPE_ns2__BacklightCompensationOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BacklightCompensationOptions20() { ns2__BacklightCompensationOptions20::soap_default(NULL); }
	virtual ~ns2__BacklightCompensationOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ExposureOptions20
#define SOAP_TYPE_ns2__ExposureOptions20 (509)
/* ns2:ExposureOptions20 */
class SOAP_CMAC ns2__ExposureOptions20 : public xsd__anyType
{
public:
	std::vector<enum ns2__ExposureMode >Mode;	/* required element of type ns2:ExposureMode */
	std::vector<enum ns2__ExposurePriority >Priority;	/* optional element of type ns2:ExposurePriority */
	ns2__FloatRange *MinExposureTime;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *MaxExposureTime;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *MinGain;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *MaxGain;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *MinIris;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *MaxIris;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *ExposureTime;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *Gain;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *Iris;	/* optional element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 509; } /* = unique type id SOAP_TYPE_ns2__ExposureOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ExposureOptions20() { ns2__ExposureOptions20::soap_default(NULL); }
	virtual ~ns2__ExposureOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MoveOptions20
#define SOAP_TYPE_ns2__MoveOptions20 (510)
/* ns2:MoveOptions20 */
class SOAP_CMAC ns2__MoveOptions20 : public xsd__anyType
{
public:
	ns2__AbsoluteFocusOptions *Absolute;	/* optional element of type ns2:AbsoluteFocusOptions */
	class ns2__RelativeFocusOptions20 *Relative;	/* optional element of type ns2:RelativeFocusOptions20 */
	ns2__ContinuousFocusOptions *Continuous;	/* optional element of type ns2:ContinuousFocusOptions */
public:
	virtual int soap_type() const { return 510; } /* = unique type id SOAP_TYPE_ns2__MoveOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MoveOptions20() { ns2__MoveOptions20::soap_default(NULL); }
	virtual ~ns2__MoveOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelativeFocusOptions20
#define SOAP_TYPE_ns2__RelativeFocusOptions20 (511)
/* ns2:RelativeFocusOptions20 */
class SOAP_CMAC ns2__RelativeFocusOptions20 : public xsd__anyType
{
public:
	ns2__FloatRange *Distance;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Speed;	/* optional element of type ns2:FloatRange */
public:
	virtual int soap_type() const { return 511; } /* = unique type id SOAP_TYPE_ns2__RelativeFocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelativeFocusOptions20() { ns2__RelativeFocusOptions20::soap_default(NULL); }
	virtual ~ns2__RelativeFocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalance20
#define SOAP_TYPE_ns2__WhiteBalance20 (512)
/* ns2:WhiteBalance20 */
class SOAP_CMAC ns2__WhiteBalance20 : public xsd__anyType
{
public:
	enum ns2__WhiteBalanceMode Mode;	/* required element of type ns2:WhiteBalanceMode */
	float *CrGain;	/* optional element of type xsd:float */
	float *CbGain;	/* optional element of type xsd:float */
	class ns2__WhiteBalance20Extension *Extension;	/* optional element of type ns2:WhiteBalance20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 512; } /* = unique type id SOAP_TYPE_ns2__WhiteBalance20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WhiteBalance20() { ns2__WhiteBalance20::soap_default(NULL); }
	virtual ~ns2__WhiteBalance20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalance20Extension
#define SOAP_TYPE_ns2__WhiteBalance20Extension (513)
/* ns2:WhiteBalance20Extension */
class SOAP_CMAC ns2__WhiteBalance20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 513; } /* = unique type id SOAP_TYPE_ns2__WhiteBalance20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WhiteBalance20Extension() { ns2__WhiteBalance20Extension::soap_default(NULL); }
	virtual ~ns2__WhiteBalance20Extension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusConfiguration20
#define SOAP_TYPE_ns2__FocusConfiguration20 (514)
/* ns2:FocusConfiguration20 */
class SOAP_CMAC ns2__FocusConfiguration20 : public xsd__anyType
{
public:
	enum ns2__AutoFocusMode AutoFocusMode;	/* required element of type ns2:AutoFocusMode */
	float *DefaultSpeed;	/* optional element of type xsd:float */
	float *NearLimit;	/* optional element of type xsd:float */
	float *FarLimit;	/* optional element of type xsd:float */
	class ns2__FocusConfiguration20Extension *Extension;	/* optional element of type ns2:FocusConfiguration20Extension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 514; } /* = unique type id SOAP_TYPE_ns2__FocusConfiguration20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusConfiguration20() { ns2__FocusConfiguration20::soap_default(NULL); }
	virtual ~ns2__FocusConfiguration20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusConfiguration20Extension
#define SOAP_TYPE_ns2__FocusConfiguration20Extension (515)
/* ns2:FocusConfiguration20Extension */
class SOAP_CMAC ns2__FocusConfiguration20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 515; } /* = unique type id SOAP_TYPE_ns2__FocusConfiguration20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusConfiguration20Extension() { ns2__FocusConfiguration20Extension::soap_default(NULL); }
	virtual ~ns2__FocusConfiguration20Extension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions20
#define SOAP_TYPE_ns2__WhiteBalanceOptions20 (516)
/* ns2:WhiteBalanceOptions20 */
class SOAP_CMAC ns2__WhiteBalanceOptions20 : public xsd__anyType
{
public:
	std::vector<enum ns2__WhiteBalanceMode >Mode;	/* required element of type ns2:WhiteBalanceMode */
	ns2__FloatRange *YrGain;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *YbGain;	/* optional element of type ns2:FloatRange */
	class ns2__WhiteBalanceOptions20Extension *Extension;	/* optional element of type ns2:WhiteBalanceOptions20Extension */
public:
	virtual int soap_type() const { return 516; } /* = unique type id SOAP_TYPE_ns2__WhiteBalanceOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WhiteBalanceOptions20() { ns2__WhiteBalanceOptions20::soap_default(NULL); }
	virtual ~ns2__WhiteBalanceOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__WhiteBalanceOptions20Extension
#define SOAP_TYPE_ns2__WhiteBalanceOptions20Extension (517)
/* ns2:WhiteBalanceOptions20Extension */
class SOAP_CMAC ns2__WhiteBalanceOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 517; } /* = unique type id SOAP_TYPE_ns2__WhiteBalanceOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__WhiteBalanceOptions20Extension() { ns2__WhiteBalanceOptions20Extension::soap_default(NULL); }
	virtual ~ns2__WhiteBalanceOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusOptions20
#define SOAP_TYPE_ns2__FocusOptions20 (518)
/* ns2:FocusOptions20 */
class SOAP_CMAC ns2__FocusOptions20 : public xsd__anyType
{
public:
	std::vector<enum ns2__AutoFocusMode >AutoFocusModes;	/* optional element of type ns2:AutoFocusMode */
	ns2__FloatRange *DefaultSpeed;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *NearLimit;	/* optional element of type ns2:FloatRange */
	ns2__FloatRange *FarLimit;	/* optional element of type ns2:FloatRange */
	class ns2__FocusOptions20Extension *Extension;	/* optional element of type ns2:FocusOptions20Extension */
public:
	virtual int soap_type() const { return 518; } /* = unique type id SOAP_TYPE_ns2__FocusOptions20 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusOptions20() { ns2__FocusOptions20::soap_default(NULL); }
	virtual ~ns2__FocusOptions20() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FocusOptions20Extension
#define SOAP_TYPE_ns2__FocusOptions20Extension (519)
/* ns2:FocusOptions20Extension */
class SOAP_CMAC ns2__FocusOptions20Extension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 519; } /* = unique type id SOAP_TYPE_ns2__FocusOptions20Extension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FocusOptions20Extension() { ns2__FocusOptions20Extension::soap_default(NULL); }
	virtual ~ns2__FocusOptions20Extension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ToneCompensationOptions
#define SOAP_TYPE_ns2__ToneCompensationOptions (520)
/* ns2:ToneCompensationOptions */
class SOAP_CMAC ns2__ToneCompensationOptions : public xsd__anyType
{
public:
	std::vector<std::string >Mode;	/* required element of type xsd:string */
	bool Level;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 520; } /* = unique type id SOAP_TYPE_ns2__ToneCompensationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ToneCompensationOptions() { ns2__ToneCompensationOptions::soap_default(NULL); }
	virtual ~ns2__ToneCompensationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DefoggingOptions
#define SOAP_TYPE_ns2__DefoggingOptions (521)
/* ns2:DefoggingOptions */
class SOAP_CMAC ns2__DefoggingOptions : public xsd__anyType
{
public:
	std::vector<std::string >Mode;	/* required element of type xsd:string */
	bool Level;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 521; } /* = unique type id SOAP_TYPE_ns2__DefoggingOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DefoggingOptions() { ns2__DefoggingOptions::soap_default(NULL); }
	virtual ~ns2__DefoggingOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NoiseReductionOptions
#define SOAP_TYPE_ns2__NoiseReductionOptions (522)
/* ns2:NoiseReductionOptions */
class SOAP_CMAC ns2__NoiseReductionOptions : public xsd__anyType
{
public:
	bool Level;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 522; } /* = unique type id SOAP_TYPE_ns2__NoiseReductionOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NoiseReductionOptions() { ns2__NoiseReductionOptions::soap_default(NULL); }
	virtual ~ns2__NoiseReductionOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MessageExtension
#define SOAP_TYPE_ns2__MessageExtension (523)
/* ns2:MessageExtension */
class SOAP_CMAC ns2__MessageExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 523; } /* = unique type id SOAP_TYPE_ns2__MessageExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MessageExtension() { ns2__MessageExtension::soap_default(NULL); }
	virtual ~ns2__MessageExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ItemList_SimpleItem
#define SOAP_TYPE__ns2__ItemList_SimpleItem (1270)
/* ns2:ItemList-SimpleItem */
class SOAP_CMAC _ns2__ItemList_SimpleItem
{
public:
	std::string Name;	/* required attribute */
	std::string Value;	/* required attribute */
public:
	virtual int soap_type() const { return 1270; } /* = unique type id SOAP_TYPE__ns2__ItemList_SimpleItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ItemList_SimpleItem() { _ns2__ItemList_SimpleItem::soap_default(NULL); }
	virtual ~_ns2__ItemList_SimpleItem() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ItemList_ElementItem
#define SOAP_TYPE__ns2__ItemList_ElementItem (1273)
/* ns2:ItemList-ElementItem */
class SOAP_CMAC _ns2__ItemList_ElementItem
{
public:
	char *__any;
	std::string Name;	/* required attribute */
public:
	virtual int soap_type() const { return 1273; } /* = unique type id SOAP_TYPE__ns2__ItemList_ElementItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ItemList_ElementItem() { _ns2__ItemList_ElementItem::soap_default(NULL); }
	virtual ~_ns2__ItemList_ElementItem() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ItemList
#define SOAP_TYPE_ns2__ItemList (524)
/* ns2:ItemList */
class SOAP_CMAC ns2__ItemList : public xsd__anyType
{
public:
	std::vector<_ns2__ItemList_SimpleItem >*SimpleItem;	/* optional element of type ns2:ItemList-SimpleItem */
	std::vector<_ns2__ItemList_ElementItem >*ElementItem;	/* optional element of type ns2:ItemList-ElementItem */
	class ns2__ItemListExtension *Extension;	/* optional element of type ns2:ItemListExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 524; } /* = unique type id SOAP_TYPE_ns2__ItemList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ItemList() { ns2__ItemList::soap_default(NULL); }
	virtual ~ns2__ItemList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ItemListExtension
#define SOAP_TYPE_ns2__ItemListExtension (525)
/* ns2:ItemListExtension */
class SOAP_CMAC ns2__ItemListExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 525; } /* = unique type id SOAP_TYPE_ns2__ItemListExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ItemListExtension() { ns2__ItemListExtension::soap_default(NULL); }
	virtual ~ns2__ItemListExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MessageDescription
#define SOAP_TYPE_ns2__MessageDescription (526)
/* ns2:MessageDescription */
class SOAP_CMAC ns2__MessageDescription : public xsd__anyType
{
public:
	class ns2__ItemListDescription *Source;	/* optional element of type ns2:ItemListDescription */
	ns2__ItemListDescription *Key;	/* optional element of type ns2:ItemListDescription */
	ns2__ItemListDescription *Data;	/* optional element of type ns2:ItemListDescription */
	class ns2__MessageDescriptionExtension *Extension;	/* optional element of type ns2:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 526; } /* = unique type id SOAP_TYPE_ns2__MessageDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MessageDescription() { ns2__MessageDescription::soap_default(NULL); }
	virtual ~ns2__MessageDescription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MessageDescriptionExtension
#define SOAP_TYPE_ns2__MessageDescriptionExtension (527)
/* ns2:MessageDescriptionExtension */
class SOAP_CMAC ns2__MessageDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 527; } /* = unique type id SOAP_TYPE_ns2__MessageDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MessageDescriptionExtension() { ns2__MessageDescriptionExtension::soap_default(NULL); }
	virtual ~ns2__MessageDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription
#define SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription (1279)
/* ns2:ItemListDescription-SimpleItemDescription */
class SOAP_CMAC _ns2__ItemListDescription_SimpleItemDescription
{
public:
	std::string Name;	/* required attribute */
	std::string Type;	/* required attribute */
public:
	virtual int soap_type() const { return 1279; } /* = unique type id SOAP_TYPE__ns2__ItemListDescription_SimpleItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ItemListDescription_SimpleItemDescription() { _ns2__ItemListDescription_SimpleItemDescription::soap_default(NULL); }
	virtual ~_ns2__ItemListDescription_SimpleItemDescription() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription
#define SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription (1282)
/* ns2:ItemListDescription-ElementItemDescription */
class SOAP_CMAC _ns2__ItemListDescription_ElementItemDescription
{
public:
	std::string Name;	/* required attribute */
	std::string Type;	/* required attribute */
public:
	virtual int soap_type() const { return 1282; } /* = unique type id SOAP_TYPE__ns2__ItemListDescription_ElementItemDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ItemListDescription_ElementItemDescription() { _ns2__ItemListDescription_ElementItemDescription::soap_default(NULL); }
	virtual ~_ns2__ItemListDescription_ElementItemDescription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ItemListDescription
#define SOAP_TYPE_ns2__ItemListDescription (528)
/* ns2:ItemListDescription */
class SOAP_CMAC ns2__ItemListDescription : public xsd__anyType
{
public:
	std::vector<_ns2__ItemListDescription_SimpleItemDescription >*SimpleItemDescription;	/* optional element of type ns2:ItemListDescription-SimpleItemDescription */
	std::vector<_ns2__ItemListDescription_ElementItemDescription >*ElementItemDescription;	/* optional element of type ns2:ItemListDescription-ElementItemDescription */
	class ns2__ItemListDescriptionExtension *Extension;	/* optional element of type ns2:ItemListDescriptionExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 528; } /* = unique type id SOAP_TYPE_ns2__ItemListDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ItemListDescription() { ns2__ItemListDescription::soap_default(NULL); }
	virtual ~ns2__ItemListDescription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ItemListDescriptionExtension
#define SOAP_TYPE_ns2__ItemListDescriptionExtension (529)
/* ns2:ItemListDescriptionExtension */
class SOAP_CMAC ns2__ItemListDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 529; } /* = unique type id SOAP_TYPE_ns2__ItemListDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ItemListDescriptionExtension() { ns2__ItemListDescriptionExtension::soap_default(NULL); }
	virtual ~ns2__ItemListDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Vector
#define SOAP_TYPE_ns2__Vector (530)
/* Primitive ns2:Vector schema type: */
class SOAP_CMAC ns2__Vector : public xsd__anyType
{
public:
	float *x;	/* optional attribute */
	float *y;	/* optional attribute */
public:
	virtual int soap_type() const { return 530; } /* = unique type id SOAP_TYPE_ns2__Vector */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Vector() { ns2__Vector::soap_default(NULL); }
	virtual ~ns2__Vector() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Rectangle
#define SOAP_TYPE_ns2__Rectangle (531)
/* Primitive ns2:Rectangle schema type: */
class SOAP_CMAC ns2__Rectangle : public xsd__anyType
{
public:
	float *bottom;	/* optional attribute */
	float *top;	/* optional attribute */
	float *right;	/* optional attribute */
	float *left;	/* optional attribute */
public:
	virtual int soap_type() const { return 531; } /* = unique type id SOAP_TYPE_ns2__Rectangle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Rectangle() { ns2__Rectangle::soap_default(NULL); }
	virtual ~ns2__Rectangle() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Polygon
#define SOAP_TYPE_ns2__Polygon (532)
/* ns2:Polygon */
class SOAP_CMAC ns2__Polygon : public xsd__anyType
{
public:
	std::vector<ns2__Vector * >Point;	/* required element of type ns2:Vector */
public:
	virtual int soap_type() const { return 532; } /* = unique type id SOAP_TYPE_ns2__Polygon */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Polygon() { ns2__Polygon::soap_default(NULL); }
	virtual ~ns2__Polygon() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Polyline
#define SOAP_TYPE_ns2__Polyline (533)
/* ns2:Polyline */
class SOAP_CMAC ns2__Polyline : public xsd__anyType
{
public:
	std::vector<ns2__Vector * >Point;	/* required element of type ns2:Vector */
public:
	virtual int soap_type() const { return 533; } /* = unique type id SOAP_TYPE_ns2__Polyline */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Polyline() { ns2__Polyline::soap_default(NULL); }
	virtual ~ns2__Polyline() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Color
#define SOAP_TYPE_ns2__Color (534)
/* Primitive ns2:Color schema type: */
class SOAP_CMAC ns2__Color : public xsd__anyType
{
public:
	float X;	/* required attribute */
	float Y;	/* required attribute */
	float Z;	/* required attribute */
	std::string *Colorspace;	/* optional attribute */
public:
	virtual int soap_type() const { return 534; } /* = unique type id SOAP_TYPE_ns2__Color */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Color() { ns2__Color::soap_default(NULL); }
	virtual ~ns2__Color() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ColorCovariance
#define SOAP_TYPE_ns2__ColorCovariance (535)
/* Primitive ns2:ColorCovariance schema type: */
class SOAP_CMAC ns2__ColorCovariance : public xsd__anyType
{
public:
	float XX;	/* required attribute */
	float YY;	/* required attribute */
	float ZZ;	/* required attribute */
	float *XY;	/* optional attribute */
	float *XZ;	/* optional attribute */
	float *YZ;	/* optional attribute */
	std::string *Colorspace;	/* optional attribute */
public:
	virtual int soap_type() const { return 535; } /* = unique type id SOAP_TYPE_ns2__ColorCovariance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ColorCovariance() { ns2__ColorCovariance::soap_default(NULL); }
	virtual ~ns2__ColorCovariance() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Appearance
#define SOAP_TYPE_ns2__Appearance (536)
/* ns2:Appearance */
class SOAP_CMAC ns2__Appearance : public xsd__anyType
{
public:
	class ns2__Transformation *Transformation;	/* optional element of type ns2:Transformation */
	class ns2__ShapeDescriptor *Shape;	/* optional element of type ns2:ShapeDescriptor */
	class ns2__ColorDescriptor *Color;	/* optional element of type ns2:ColorDescriptor */
	class ns2__ClassDescriptor *Class;	/* optional element of type ns2:ClassDescriptor */
	class ns2__AppearanceExtension *Extension;	/* optional element of type ns2:AppearanceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 536; } /* = unique type id SOAP_TYPE_ns2__Appearance */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Appearance() { ns2__Appearance::soap_default(NULL); }
	virtual ~ns2__Appearance() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AppearanceExtension
#define SOAP_TYPE_ns2__AppearanceExtension (537)
/* ns2:AppearanceExtension */
class SOAP_CMAC ns2__AppearanceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 537; } /* = unique type id SOAP_TYPE_ns2__AppearanceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AppearanceExtension() { ns2__AppearanceExtension::soap_default(NULL); }
	virtual ~ns2__AppearanceExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ShapeDescriptor
#define SOAP_TYPE_ns2__ShapeDescriptor (538)
/* ns2:ShapeDescriptor */
class SOAP_CMAC ns2__ShapeDescriptor : public xsd__anyType
{
public:
	ns2__Rectangle *BoundingBox;	/* required element of type ns2:Rectangle */
	ns2__Vector *CenterOfGravity;	/* required element of type ns2:Vector */
	std::vector<ns2__Polygon * >Polygon;	/* optional element of type ns2:Polygon */
	class ns2__ShapeDescriptorExtension *Extension;	/* optional element of type ns2:ShapeDescriptorExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 538; } /* = unique type id SOAP_TYPE_ns2__ShapeDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ShapeDescriptor() { ns2__ShapeDescriptor::soap_default(NULL); }
	virtual ~ns2__ShapeDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ShapeDescriptorExtension
#define SOAP_TYPE_ns2__ShapeDescriptorExtension (539)
/* ns2:ShapeDescriptorExtension */
class SOAP_CMAC ns2__ShapeDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 539; } /* = unique type id SOAP_TYPE_ns2__ShapeDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ShapeDescriptorExtension() { ns2__ShapeDescriptorExtension::soap_default(NULL); }
	virtual ~ns2__ShapeDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ColorDescriptor_ColorCluster
#define SOAP_TYPE__ns2__ColorDescriptor_ColorCluster (1296)
/* ns2:ColorDescriptor-ColorCluster */
class SOAP_CMAC _ns2__ColorDescriptor_ColorCluster
{
public:
	ns2__Color *Color;	/* required element of type ns2:Color */
	float *Weight;	/* optional element of type xsd:float */
	ns2__ColorCovariance *Covariance;	/* optional element of type ns2:ColorCovariance */
public:
	virtual int soap_type() const { return 1296; } /* = unique type id SOAP_TYPE__ns2__ColorDescriptor_ColorCluster */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ColorDescriptor_ColorCluster() { _ns2__ColorDescriptor_ColorCluster::soap_default(NULL); }
	virtual ~_ns2__ColorDescriptor_ColorCluster() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ColorDescriptor
#define SOAP_TYPE_ns2__ColorDescriptor (540)
/* ns2:ColorDescriptor */
class SOAP_CMAC ns2__ColorDescriptor : public xsd__anyType
{
public:
	std::vector<_ns2__ColorDescriptor_ColorCluster >*ColorCluster;	/* optional element of type ns2:ColorDescriptor-ColorCluster */
	class ns2__ColorDescriptorExtension *Extension;	/* optional element of type ns2:ColorDescriptorExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 540; } /* = unique type id SOAP_TYPE_ns2__ColorDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ColorDescriptor() { ns2__ColorDescriptor::soap_default(NULL); }
	virtual ~ns2__ColorDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ColorDescriptorExtension
#define SOAP_TYPE_ns2__ColorDescriptorExtension (541)
/* ns2:ColorDescriptorExtension */
class SOAP_CMAC ns2__ColorDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 541; } /* = unique type id SOAP_TYPE_ns2__ColorDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ColorDescriptorExtension() { ns2__ColorDescriptorExtension::soap_default(NULL); }
	virtual ~ns2__ColorDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate
#define SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate (1302)
/* ns2:ClassDescriptor-ClassCandidate */
class SOAP_CMAC _ns2__ClassDescriptor_ClassCandidate
{
public:
	enum ns2__ClassType Type;	/* required element of type ns2:ClassType */
	float Likelihood;	/* required element of type xsd:float */
public:
	virtual int soap_type() const { return 1302; } /* = unique type id SOAP_TYPE__ns2__ClassDescriptor_ClassCandidate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ClassDescriptor_ClassCandidate() { _ns2__ClassDescriptor_ClassCandidate::soap_default(NULL); }
	virtual ~_ns2__ClassDescriptor_ClassCandidate() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ClassDescriptor
#define SOAP_TYPE_ns2__ClassDescriptor (542)
/* ns2:ClassDescriptor */
class SOAP_CMAC ns2__ClassDescriptor : public xsd__anyType
{
public:
	std::vector<_ns2__ClassDescriptor_ClassCandidate >*ClassCandidate;	/* optional element of type ns2:ClassDescriptor-ClassCandidate */
	class ns2__ClassDescriptorExtension *Extension;	/* optional element of type ns2:ClassDescriptorExtension */
public:
	virtual int soap_type() const { return 542; } /* = unique type id SOAP_TYPE_ns2__ClassDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ClassDescriptor() { ns2__ClassDescriptor::soap_default(NULL); }
	virtual ~ns2__ClassDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ClassDescriptorExtension
#define SOAP_TYPE_ns2__ClassDescriptorExtension (543)
/* ns2:ClassDescriptorExtension */
class SOAP_CMAC ns2__ClassDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::vector<class ns2__OtherType * >OtherTypes;	/* required element of type ns2:OtherType */
	class ns2__ClassDescriptorExtension2 *Extension;	/* optional element of type ns2:ClassDescriptorExtension2 */
public:
	virtual int soap_type() const { return 543; } /* = unique type id SOAP_TYPE_ns2__ClassDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ClassDescriptorExtension() { ns2__ClassDescriptorExtension::soap_default(NULL); }
	virtual ~ns2__ClassDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ClassDescriptorExtension2
#define SOAP_TYPE_ns2__ClassDescriptorExtension2 (544)
/* ns2:ClassDescriptorExtension2 */
class SOAP_CMAC ns2__ClassDescriptorExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 544; } /* = unique type id SOAP_TYPE_ns2__ClassDescriptorExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ClassDescriptorExtension2() { ns2__ClassDescriptorExtension2::soap_default(NULL); }
	virtual ~ns2__ClassDescriptorExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OtherType
#define SOAP_TYPE_ns2__OtherType (545)
/* ns2:OtherType */
class SOAP_CMAC ns2__OtherType : public xsd__anyType
{
public:
	std::string Type;	/* required element of type xsd:string */
	float Likelihood;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 545; } /* = unique type id SOAP_TYPE_ns2__OtherType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OtherType() { ns2__OtherType::soap_default(NULL); }
	virtual ~ns2__OtherType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ObjectExtension
#define SOAP_TYPE_ns2__ObjectExtension (547)
/* ns2:ObjectExtension */
class SOAP_CMAC ns2__ObjectExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 547; } /* = unique type id SOAP_TYPE_ns2__ObjectExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ObjectExtension() { ns2__ObjectExtension::soap_default(NULL); }
	virtual ~ns2__ObjectExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Transformation
#define SOAP_TYPE_ns2__Transformation (548)
/* ns2:Transformation */
class SOAP_CMAC ns2__Transformation : public xsd__anyType
{
public:
	ns2__Vector *Translate;	/* optional element of type ns2:Vector */
	ns2__Vector *Scale;	/* optional element of type ns2:Vector */
	class ns2__TransformationExtension *Extension;	/* optional element of type ns2:TransformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 548; } /* = unique type id SOAP_TYPE_ns2__Transformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Transformation() { ns2__Transformation::soap_default(NULL); }
	virtual ~ns2__Transformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TransformationExtension
#define SOAP_TYPE_ns2__TransformationExtension (549)
/* ns2:TransformationExtension */
class SOAP_CMAC ns2__TransformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 549; } /* = unique type id SOAP_TYPE_ns2__TransformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TransformationExtension() { ns2__TransformationExtension::soap_default(NULL); }
	virtual ~ns2__TransformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Frame
#define SOAP_TYPE_ns2__Frame (550)
/* ns2:Frame */
class SOAP_CMAC ns2__Frame : public xsd__anyType
{
public:
	ns2__PTZStatus *PTZStatus;	/* optional element of type ns2:PTZStatus */
	ns2__Transformation *Transformation;	/* optional element of type ns2:Transformation */
	std::vector<class ns2__Object * >Object;	/* optional element of type ns2:Object */
	class ns2__ObjectTree *ObjectTree;	/* optional element of type ns2:ObjectTree */
	class ns2__FrameExtension *Extension;	/* optional element of type ns2:FrameExtension */
	time_t UtcTime;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 550; } /* = unique type id SOAP_TYPE_ns2__Frame */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Frame() { ns2__Frame::soap_default(NULL); }
	virtual ~ns2__Frame() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FrameExtension
#define SOAP_TYPE_ns2__FrameExtension (551)
/* ns2:FrameExtension */
class SOAP_CMAC ns2__FrameExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__MotionInCells *MotionInCells;	/* optional element of type ns2:MotionInCells */
	class ns2__FrameExtension2 *Extension;	/* optional element of type ns2:FrameExtension2 */
public:
	virtual int soap_type() const { return 551; } /* = unique type id SOAP_TYPE_ns2__FrameExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FrameExtension() { ns2__FrameExtension::soap_default(NULL); }
	virtual ~ns2__FrameExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FrameExtension2
#define SOAP_TYPE_ns2__FrameExtension2 (552)
/* ns2:FrameExtension2 */
class SOAP_CMAC ns2__FrameExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 552; } /* = unique type id SOAP_TYPE_ns2__FrameExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FrameExtension2() { ns2__FrameExtension2::soap_default(NULL); }
	virtual ~ns2__FrameExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Merge
#define SOAP_TYPE_ns2__Merge (553)
/* ns2:Merge */
class SOAP_CMAC ns2__Merge : public xsd__anyType
{
public:
	std::vector<class ns2__ObjectId * >from;	/* required element of type ns2:ObjectId */
	ns2__ObjectId *to;	/* required element of type ns2:ObjectId */
public:
	virtual int soap_type() const { return 553; } /* = unique type id SOAP_TYPE_ns2__Merge */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Merge() { ns2__Merge::soap_default(NULL); }
	virtual ~ns2__Merge() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Split
#define SOAP_TYPE_ns2__Split (554)
/* ns2:Split */
class SOAP_CMAC ns2__Split : public xsd__anyType
{
public:
	ns2__ObjectId *from;	/* required element of type ns2:ObjectId */
	std::vector<ns2__ObjectId * >to;	/* required element of type ns2:ObjectId */
public:
	virtual int soap_type() const { return 554; } /* = unique type id SOAP_TYPE_ns2__Split */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Split() { ns2__Split::soap_default(NULL); }
	virtual ~ns2__Split() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Rename
#define SOAP_TYPE_ns2__Rename (555)
/* ns2:Rename */
class SOAP_CMAC ns2__Rename : public xsd__anyType
{
public:
	ns2__ObjectId *from;	/* required element of type ns2:ObjectId */
	ns2__ObjectId *to;	/* required element of type ns2:ObjectId */
public:
	virtual int soap_type() const { return 555; } /* = unique type id SOAP_TYPE_ns2__Rename */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Rename() { ns2__Rename::soap_default(NULL); }
	virtual ~ns2__Rename() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ObjectId
#define SOAP_TYPE_ns2__ObjectId (556)
/* Primitive ns2:ObjectId schema type: */
class SOAP_CMAC ns2__ObjectId : public xsd__anyType
{
public:
	std::string *ObjectId;	/* optional attribute */
public:
	virtual int soap_type() const { return 556; } /* = unique type id SOAP_TYPE_ns2__ObjectId */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ObjectId() { ns2__ObjectId::soap_default(NULL); }
	virtual ~ns2__ObjectId() { }
};
#endif

#ifndef SOAP_TYPE__ns2__Behaviour_Removed
#define SOAP_TYPE__ns2__Behaviour_Removed (1320)
/* ns2:Behaviour-Removed */
class SOAP_CMAC _ns2__Behaviour_Removed
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1320; } /* = unique type id SOAP_TYPE__ns2__Behaviour_Removed */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__Behaviour_Removed() { _ns2__Behaviour_Removed::soap_default(NULL); }
	virtual ~_ns2__Behaviour_Removed() { }
};
#endif

#ifndef SOAP_TYPE__ns2__Behaviour_Idle
#define SOAP_TYPE__ns2__Behaviour_Idle (1322)
/* ns2:Behaviour-Idle */
class SOAP_CMAC _ns2__Behaviour_Idle
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1322; } /* = unique type id SOAP_TYPE__ns2__Behaviour_Idle */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__Behaviour_Idle() { _ns2__Behaviour_Idle::soap_default(NULL); }
	virtual ~_ns2__Behaviour_Idle() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Behaviour
#define SOAP_TYPE_ns2__Behaviour (557)
/* ns2:Behaviour */
class SOAP_CMAC ns2__Behaviour : public xsd__anyType
{
public:
	_ns2__Behaviour_Removed *Removed;	/* optional element of type ns2:Behaviour-Removed */
	_ns2__Behaviour_Idle *Idle;	/* optional element of type ns2:Behaviour-Idle */
	class ns2__BehaviourExtension *Extension;	/* optional element of type ns2:BehaviourExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 557; } /* = unique type id SOAP_TYPE_ns2__Behaviour */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Behaviour() { ns2__Behaviour::soap_default(NULL); }
	virtual ~ns2__Behaviour() { }
};
#endif

#ifndef SOAP_TYPE_ns2__BehaviourExtension
#define SOAP_TYPE_ns2__BehaviourExtension (558)
/* ns2:BehaviourExtension */
class SOAP_CMAC ns2__BehaviourExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 558; } /* = unique type id SOAP_TYPE_ns2__BehaviourExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__BehaviourExtension() { ns2__BehaviourExtension::soap_default(NULL); }
	virtual ~ns2__BehaviourExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ObjectTree
#define SOAP_TYPE_ns2__ObjectTree (559)
/* ns2:ObjectTree */
class SOAP_CMAC ns2__ObjectTree : public xsd__anyType
{
public:
	std::vector<ns2__Rename * >Rename;	/* optional element of type ns2:Rename */
	std::vector<ns2__Split * >Split;	/* optional element of type ns2:Split */
	std::vector<ns2__Merge * >Merge;	/* optional element of type ns2:Merge */
	std::vector<ns2__ObjectId * >Delete;	/* optional element of type ns2:ObjectId */
	class ns2__ObjectTreeExtension *Extension;	/* optional element of type ns2:ObjectTreeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 559; } /* = unique type id SOAP_TYPE_ns2__ObjectTree */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ObjectTree() { ns2__ObjectTree::soap_default(NULL); }
	virtual ~ns2__ObjectTree() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ObjectTreeExtension
#define SOAP_TYPE_ns2__ObjectTreeExtension (560)
/* ns2:ObjectTreeExtension */
class SOAP_CMAC ns2__ObjectTreeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 560; } /* = unique type id SOAP_TYPE_ns2__ObjectTreeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ObjectTreeExtension() { ns2__ObjectTreeExtension::soap_default(NULL); }
	virtual ~ns2__ObjectTreeExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MotionInCells
#define SOAP_TYPE_ns2__MotionInCells (561)
/* ns2:MotionInCells */
class SOAP_CMAC ns2__MotionInCells : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::string Columns;	/* required attribute */
	std::string Rows;	/* required attribute */
	xsd__base64Binary Cells;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 561; } /* = unique type id SOAP_TYPE_ns2__MotionInCells */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MotionInCells() { ns2__MotionInCells::soap_default(NULL); }
	virtual ~ns2__MotionInCells() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsEngineConfiguration
#define SOAP_TYPE_ns2__AnalyticsEngineConfiguration (562)
/* ns2:AnalyticsEngineConfiguration */
class SOAP_CMAC ns2__AnalyticsEngineConfiguration : public xsd__anyType
{
public:
	std::vector<class ns2__Config * >AnalyticsModule;	/* optional element of type ns2:Config */
	class ns2__AnalyticsEngineConfigurationExtension *Extension;	/* optional element of type ns2:AnalyticsEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 562; } /* = unique type id SOAP_TYPE_ns2__AnalyticsEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsEngineConfiguration() { ns2__AnalyticsEngineConfiguration::soap_default(NULL); }
	virtual ~ns2__AnalyticsEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension
#define SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension (563)
/* ns2:AnalyticsEngineConfigurationExtension */
class SOAP_CMAC ns2__AnalyticsEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 563; } /* = unique type id SOAP_TYPE_ns2__AnalyticsEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsEngineConfigurationExtension() { ns2__AnalyticsEngineConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__AnalyticsEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RuleEngineConfiguration
#define SOAP_TYPE_ns2__RuleEngineConfiguration (564)
/* ns2:RuleEngineConfiguration */
class SOAP_CMAC ns2__RuleEngineConfiguration : public xsd__anyType
{
public:
	std::vector<ns2__Config * >Rule;	/* optional element of type ns2:Config */
	class ns2__RuleEngineConfigurationExtension *Extension;	/* optional element of type ns2:RuleEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 564; } /* = unique type id SOAP_TYPE_ns2__RuleEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RuleEngineConfiguration() { ns2__RuleEngineConfiguration::soap_default(NULL); }
	virtual ~ns2__RuleEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RuleEngineConfigurationExtension
#define SOAP_TYPE_ns2__RuleEngineConfigurationExtension (565)
/* ns2:RuleEngineConfigurationExtension */
class SOAP_CMAC ns2__RuleEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 565; } /* = unique type id SOAP_TYPE_ns2__RuleEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RuleEngineConfigurationExtension() { ns2__RuleEngineConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__RuleEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Config
#define SOAP_TYPE_ns2__Config (566)
/* ns2:Config */
class SOAP_CMAC ns2__Config : public xsd__anyType
{
public:
	ns2__ItemList *Parameters;	/* required element of type ns2:ItemList */
	std::string Name;	/* required attribute */
	std::string Type;	/* required attribute */
public:
	virtual int soap_type() const { return 566; } /* = unique type id SOAP_TYPE_ns2__Config */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Config() { ns2__Config::soap_default(NULL); }
	virtual ~ns2__Config() { }
};
#endif

#ifndef SOAP_TYPE__ns2__ConfigDescription_Messages
#define SOAP_TYPE__ns2__ConfigDescription_Messages (1337)
/* ns2:ConfigDescription-Messages */
class SOAP_CMAC _ns2__ConfigDescription_Messages
{
public:
	ns2__ItemListDescription *Source;	/* optional element of type ns2:ItemListDescription */
	ns2__ItemListDescription *Key;	/* optional element of type ns2:ItemListDescription */
	ns2__ItemListDescription *Data;	/* optional element of type ns2:ItemListDescription */
	ns2__MessageDescriptionExtension *Extension;	/* optional element of type ns2:MessageDescriptionExtension */
	bool *IsProperty;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	std::string ParentTopic;	/* required element of type xsd:string */
public:
	virtual int soap_type() const { return 1337; } /* = unique type id SOAP_TYPE__ns2__ConfigDescription_Messages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__ConfigDescription_Messages() { _ns2__ConfigDescription_Messages::soap_default(NULL); }
	virtual ~_ns2__ConfigDescription_Messages() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ConfigDescription
#define SOAP_TYPE_ns2__ConfigDescription (567)
/* ns2:ConfigDescription */
class SOAP_CMAC ns2__ConfigDescription : public xsd__anyType
{
public:
	ns2__ItemListDescription *Parameters;	/* required element of type ns2:ItemListDescription */
	std::vector<_ns2__ConfigDescription_Messages >*Messages;	/* optional element of type ns2:ConfigDescription-Messages */
	class ns2__ConfigDescriptionExtension *Extension;	/* optional element of type ns2:ConfigDescriptionExtension */
	std::string Name;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 567; } /* = unique type id SOAP_TYPE_ns2__ConfigDescription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ConfigDescription() { ns2__ConfigDescription::soap_default(NULL); }
	virtual ~ns2__ConfigDescription() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ConfigDescriptionExtension
#define SOAP_TYPE_ns2__ConfigDescriptionExtension (568)
/* ns2:ConfigDescriptionExtension */
class SOAP_CMAC ns2__ConfigDescriptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 568; } /* = unique type id SOAP_TYPE_ns2__ConfigDescriptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ConfigDescriptionExtension() { ns2__ConfigDescriptionExtension::soap_default(NULL); }
	virtual ~ns2__ConfigDescriptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SupportedRules
#define SOAP_TYPE_ns2__SupportedRules (569)
/* ns2:SupportedRules */
class SOAP_CMAC ns2__SupportedRules : public xsd__anyType
{
public:
	std::vector<std::string >RuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	std::vector<ns2__ConfigDescription * >RuleDescription;	/* optional element of type ns2:ConfigDescription */
	class ns2__SupportedRulesExtension *Extension;	/* optional element of type ns2:SupportedRulesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 569; } /* = unique type id SOAP_TYPE_ns2__SupportedRules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SupportedRules() { ns2__SupportedRules::soap_default(NULL); }
	virtual ~ns2__SupportedRules() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SupportedRulesExtension
#define SOAP_TYPE_ns2__SupportedRulesExtension (570)
/* ns2:SupportedRulesExtension */
class SOAP_CMAC ns2__SupportedRulesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 570; } /* = unique type id SOAP_TYPE_ns2__SupportedRulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SupportedRulesExtension() { ns2__SupportedRulesExtension::soap_default(NULL); }
	virtual ~ns2__SupportedRulesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SupportedAnalyticsModules
#define SOAP_TYPE_ns2__SupportedAnalyticsModules (571)
/* ns2:SupportedAnalyticsModules */
class SOAP_CMAC ns2__SupportedAnalyticsModules : public xsd__anyType
{
public:
	std::vector<std::string >AnalyticsModuleContentSchemaLocation;	/* optional element of type xsd:anyURI */
	std::vector<ns2__ConfigDescription * >AnalyticsModuleDescription;	/* optional element of type ns2:ConfigDescription */
	class ns2__SupportedAnalyticsModulesExtension *Extension;	/* optional element of type ns2:SupportedAnalyticsModulesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 571; } /* = unique type id SOAP_TYPE_ns2__SupportedAnalyticsModules */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SupportedAnalyticsModules() { ns2__SupportedAnalyticsModules::soap_default(NULL); }
	virtual ~ns2__SupportedAnalyticsModules() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension
#define SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension (572)
/* ns2:SupportedAnalyticsModulesExtension */
class SOAP_CMAC ns2__SupportedAnalyticsModulesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 572; } /* = unique type id SOAP_TYPE_ns2__SupportedAnalyticsModulesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SupportedAnalyticsModulesExtension() { ns2__SupportedAnalyticsModulesExtension::soap_default(NULL); }
	virtual ~ns2__SupportedAnalyticsModulesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PolygonConfiguration
#define SOAP_TYPE_ns2__PolygonConfiguration (573)
/* ns2:PolygonConfiguration */
class SOAP_CMAC ns2__PolygonConfiguration : public xsd__anyType
{
public:
	ns2__Polygon *Polygon;	/* required element of type ns2:Polygon */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 573; } /* = unique type id SOAP_TYPE_ns2__PolygonConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PolygonConfiguration() { ns2__PolygonConfiguration::soap_default(NULL); }
	virtual ~ns2__PolygonConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PolylineArray
#define SOAP_TYPE_ns2__PolylineArray (574)
/* ns2:PolylineArray */
class SOAP_CMAC ns2__PolylineArray : public xsd__anyType
{
public:
	std::vector<ns2__Polyline * >Segment;	/* required element of type ns2:Polyline */
	class ns2__PolylineArrayExtension *Extension;	/* optional element of type ns2:PolylineArrayExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 574; } /* = unique type id SOAP_TYPE_ns2__PolylineArray */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PolylineArray() { ns2__PolylineArray::soap_default(NULL); }
	virtual ~ns2__PolylineArray() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PolylineArrayExtension
#define SOAP_TYPE_ns2__PolylineArrayExtension (575)
/* ns2:PolylineArrayExtension */
class SOAP_CMAC ns2__PolylineArrayExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 575; } /* = unique type id SOAP_TYPE_ns2__PolylineArrayExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PolylineArrayExtension() { ns2__PolylineArrayExtension::soap_default(NULL); }
	virtual ~ns2__PolylineArrayExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PolylineArrayConfiguration
#define SOAP_TYPE_ns2__PolylineArrayConfiguration (576)
/* ns2:PolylineArrayConfiguration */
class SOAP_CMAC ns2__PolylineArrayConfiguration : public xsd__anyType
{
public:
	ns2__PolylineArray *PolylineArray;	/* required element of type ns2:PolylineArray */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 576; } /* = unique type id SOAP_TYPE_ns2__PolylineArrayConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PolylineArrayConfiguration() { ns2__PolylineArrayConfiguration::soap_default(NULL); }
	virtual ~ns2__PolylineArrayConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MotionExpression
#define SOAP_TYPE_ns2__MotionExpression (577)
/* ns2:MotionExpression */
class SOAP_CMAC ns2__MotionExpression : public xsd__anyType
{
public:
	std::string Expression;	/* required element of type xsd:string */
	std::vector<char * >__any;
	std::string *Type;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 577; } /* = unique type id SOAP_TYPE_ns2__MotionExpression */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MotionExpression() { ns2__MotionExpression::soap_default(NULL); }
	virtual ~ns2__MotionExpression() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MotionExpressionConfiguration
#define SOAP_TYPE_ns2__MotionExpressionConfiguration (578)
/* ns2:MotionExpressionConfiguration */
class SOAP_CMAC ns2__MotionExpressionConfiguration : public xsd__anyType
{
public:
	ns2__MotionExpression *MotionExpression;	/* required element of type ns2:MotionExpression */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 578; } /* = unique type id SOAP_TYPE_ns2__MotionExpressionConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MotionExpressionConfiguration() { ns2__MotionExpressionConfiguration::soap_default(NULL); }
	virtual ~ns2__MotionExpressionConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CellLayout
#define SOAP_TYPE_ns2__CellLayout (579)
/* ns2:CellLayout */
class SOAP_CMAC ns2__CellLayout : public xsd__anyType
{
public:
	ns2__Transformation *Transformation;	/* required element of type ns2:Transformation */
	std::vector<char * >__any;
	std::string Columns;	/* required attribute */
	std::string Rows;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 579; } /* = unique type id SOAP_TYPE_ns2__CellLayout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CellLayout() { ns2__CellLayout::soap_default(NULL); }
	virtual ~ns2__CellLayout() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_MetadataStream
#define SOAP_TYPE__ns2__union_MetadataStream (1355)
/* xsd:choice */
union _ns2__union_MetadataStream
{
#define SOAP_UNION__ns2__union_MetadataStream_VideoAnalytics	(1)
	class ns2__VideoAnalyticsStream *VideoAnalytics;
#define SOAP_UNION__ns2__union_MetadataStream_PTZ	(2)
	class ns2__PTZStream *PTZ;
#define SOAP_UNION__ns2__union_MetadataStream_Event	(3)
	class ns2__EventStream *Event;
#define SOAP_UNION__ns2__union_MetadataStream_Extension	(4)
	class ns2__MetadataStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___ns2__union_MetadataStream
#define SOAP_TYPE___ns2__union_MetadataStream (1350)
/* Operation wrapper: */
class SOAP_CMAC __ns2__union_MetadataStream
{
public:
	int __union_MetadataStream;	/* union discriminant (of union defined below) */
	union _ns2__union_MetadataStream union_MetadataStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1350; } /* = unique type id SOAP_TYPE___ns2__union_MetadataStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__union_MetadataStream() { __ns2__union_MetadataStream::soap_default(NULL); }
	virtual ~__ns2__union_MetadataStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataStream
#define SOAP_TYPE_ns2__MetadataStream (580)
/* ns2:MetadataStream */
class SOAP_CMAC ns2__MetadataStream : public xsd__anyType
{
public:
	int __size_MetadataStream;	/* sequence of elements <-union-MetadataStream> */
	__ns2__union_MetadataStream *__union_MetadataStream;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 580; } /* = unique type id SOAP_TYPE_ns2__MetadataStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataStream() { ns2__MetadataStream::soap_default(NULL); }
	virtual ~ns2__MetadataStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataStreamExtension
#define SOAP_TYPE_ns2__MetadataStreamExtension (581)
/* ns2:MetadataStreamExtension */
class SOAP_CMAC ns2__MetadataStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	class ns2__AudioAnalyticsStream *AudioAnalyticsStream;	/* optional element of type ns2:AudioAnalyticsStream */
	class ns2__MetadataStreamExtension2 *Extension;	/* optional element of type ns2:MetadataStreamExtension2 */
public:
	virtual int soap_type() const { return 581; } /* = unique type id SOAP_TYPE_ns2__MetadataStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataStreamExtension() { ns2__MetadataStreamExtension::soap_default(NULL); }
	virtual ~ns2__MetadataStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataStreamExtension2
#define SOAP_TYPE_ns2__MetadataStreamExtension2 (582)
/* ns2:MetadataStreamExtension2 */
class SOAP_CMAC ns2__MetadataStreamExtension2 : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 582; } /* = unique type id SOAP_TYPE_ns2__MetadataStreamExtension2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataStreamExtension2() { ns2__MetadataStreamExtension2::soap_default(NULL); }
	virtual ~ns2__MetadataStreamExtension2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioAnalyticsStream
#define SOAP_TYPE_ns2__AudioAnalyticsStream (583)
/* ns2:AudioAnalyticsStream */
class SOAP_CMAC ns2__AudioAnalyticsStream : public xsd__anyType
{
public:
	std::vector<class ns2__AudioDescriptor * >AudioDescriptor;	/* optional element of type ns2:AudioDescriptor */
	class ns2__AudioAnalyticsStreamExtension *Extension;	/* optional element of type ns2:AudioAnalyticsStreamExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 583; } /* = unique type id SOAP_TYPE_ns2__AudioAnalyticsStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioAnalyticsStream() { ns2__AudioAnalyticsStream::soap_default(NULL); }
	virtual ~ns2__AudioAnalyticsStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioDescriptor
#define SOAP_TYPE_ns2__AudioDescriptor (584)
/* ns2:AudioDescriptor */
class SOAP_CMAC ns2__AudioDescriptor : public xsd__anyType
{
public:
	std::vector<char * >__any;
	time_t UtcTime;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 584; } /* = unique type id SOAP_TYPE_ns2__AudioDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioDescriptor() { ns2__AudioDescriptor::soap_default(NULL); }
	virtual ~ns2__AudioDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioAnalyticsStreamExtension
#define SOAP_TYPE_ns2__AudioAnalyticsStreamExtension (585)
/* ns2:AudioAnalyticsStreamExtension */
class SOAP_CMAC ns2__AudioAnalyticsStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 585; } /* = unique type id SOAP_TYPE_ns2__AudioAnalyticsStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioAnalyticsStreamExtension() { ns2__AudioAnalyticsStreamExtension::soap_default(NULL); }
	virtual ~ns2__AudioAnalyticsStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_VideoAnalyticsStream
#define SOAP_TYPE__ns2__union_VideoAnalyticsStream (1365)
/* xsd:choice */
union _ns2__union_VideoAnalyticsStream
{
#define SOAP_UNION__ns2__union_VideoAnalyticsStream_Frame	(1)
	ns2__Frame *Frame;
#define SOAP_UNION__ns2__union_VideoAnalyticsStream_Extension	(2)
	class ns2__VideoAnalyticsStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___ns2__union_VideoAnalyticsStream
#define SOAP_TYPE___ns2__union_VideoAnalyticsStream (1362)
/* Operation wrapper: */
class SOAP_CMAC __ns2__union_VideoAnalyticsStream
{
public:
	int __union_VideoAnalyticsStream;	/* union discriminant (of union defined below) */
	union _ns2__union_VideoAnalyticsStream union_VideoAnalyticsStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1362; } /* = unique type id SOAP_TYPE___ns2__union_VideoAnalyticsStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__union_VideoAnalyticsStream() { __ns2__union_VideoAnalyticsStream::soap_default(NULL); }
	virtual ~__ns2__union_VideoAnalyticsStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoAnalyticsStream
#define SOAP_TYPE_ns2__VideoAnalyticsStream (586)
/* ns2:VideoAnalyticsStream */
class SOAP_CMAC ns2__VideoAnalyticsStream : public xsd__anyType
{
public:
	int __size_VideoAnalyticsStream;	/* sequence of elements <-union-VideoAnalyticsStream> */
	__ns2__union_VideoAnalyticsStream *__union_VideoAnalyticsStream;
public:
	virtual int soap_type() const { return 586; } /* = unique type id SOAP_TYPE_ns2__VideoAnalyticsStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoAnalyticsStream() { ns2__VideoAnalyticsStream::soap_default(NULL); }
	virtual ~ns2__VideoAnalyticsStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoAnalyticsStreamExtension
#define SOAP_TYPE_ns2__VideoAnalyticsStreamExtension (587)
/* ns2:VideoAnalyticsStreamExtension */
class SOAP_CMAC ns2__VideoAnalyticsStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 587; } /* = unique type id SOAP_TYPE_ns2__VideoAnalyticsStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoAnalyticsStreamExtension() { ns2__VideoAnalyticsStreamExtension::soap_default(NULL); }
	virtual ~ns2__VideoAnalyticsStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_PTZStream
#define SOAP_TYPE__ns2__union_PTZStream (1369)
/* xsd:choice */
union _ns2__union_PTZStream
{
#define SOAP_UNION__ns2__union_PTZStream_PTZStatus	(1)
	ns2__PTZStatus *PTZStatus;
#define SOAP_UNION__ns2__union_PTZStream_Extension	(2)
	class ns2__PTZStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___ns2__union_PTZStream
#define SOAP_TYPE___ns2__union_PTZStream (1367)
/* Operation wrapper: */
class SOAP_CMAC __ns2__union_PTZStream
{
public:
	int __union_PTZStream;	/* union discriminant (of union defined below) */
	union _ns2__union_PTZStream union_PTZStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1367; } /* = unique type id SOAP_TYPE___ns2__union_PTZStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__union_PTZStream() { __ns2__union_PTZStream::soap_default(NULL); }
	virtual ~__ns2__union_PTZStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZStream
#define SOAP_TYPE_ns2__PTZStream (588)
/* ns2:PTZStream */
class SOAP_CMAC ns2__PTZStream : public xsd__anyType
{
public:
	int __size_PTZStream;	/* sequence of elements <-union-PTZStream> */
	__ns2__union_PTZStream *__union_PTZStream;
public:
	virtual int soap_type() const { return 588; } /* = unique type id SOAP_TYPE_ns2__PTZStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZStream() { ns2__PTZStream::soap_default(NULL); }
	virtual ~ns2__PTZStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZStreamExtension
#define SOAP_TYPE_ns2__PTZStreamExtension (589)
/* ns2:PTZStreamExtension */
class SOAP_CMAC ns2__PTZStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 589; } /* = unique type id SOAP_TYPE_ns2__PTZStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZStreamExtension() { ns2__PTZStreamExtension::soap_default(NULL); }
	virtual ~ns2__PTZStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_EventStream
#define SOAP_TYPE__ns2__union_EventStream (1374)
/* xsd:choice */
union _ns2__union_EventStream
{
#define SOAP_UNION__ns2__union_EventStream_ns3__NotificationMessage	(1)
	class ns3__NotificationMessageHolderType *ns3__NotificationMessage;
#define SOAP_UNION__ns2__union_EventStream_Extension	(2)
	class ns2__EventStreamExtension *Extension;
};
#endif

#ifndef SOAP_TYPE___ns2__union_EventStream
#define SOAP_TYPE___ns2__union_EventStream (1371)
/* Operation wrapper: */
class SOAP_CMAC __ns2__union_EventStream
{
public:
	int __union_EventStream;	/* union discriminant (of union defined below) */
	union _ns2__union_EventStream union_EventStream;	/* required element of type xsd:choice */
public:
	virtual int soap_type() const { return 1371; } /* = unique type id SOAP_TYPE___ns2__union_EventStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         __ns2__union_EventStream() { __ns2__union_EventStream::soap_default(NULL); }
	virtual ~__ns2__union_EventStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EventStream
#define SOAP_TYPE_ns2__EventStream (590)
/* ns2:EventStream */
class SOAP_CMAC ns2__EventStream : public xsd__anyType
{
public:
	int __size_EventStream;	/* sequence of elements <-union-EventStream> */
	__ns2__union_EventStream *__union_EventStream;
public:
	virtual int soap_type() const { return 590; } /* = unique type id SOAP_TYPE_ns2__EventStream */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EventStream() { ns2__EventStream::soap_default(NULL); }
	virtual ~ns2__EventStream() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EventStreamExtension
#define SOAP_TYPE_ns2__EventStreamExtension (591)
/* ns2:EventStreamExtension */
class SOAP_CMAC ns2__EventStreamExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 591; } /* = unique type id SOAP_TYPE_ns2__EventStreamExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EventStreamExtension() { ns2__EventStreamExtension::soap_default(NULL); }
	virtual ~ns2__EventStreamExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PaneConfiguration
#define SOAP_TYPE_ns2__PaneConfiguration (592)
/* ns2:PaneConfiguration */
class SOAP_CMAC ns2__PaneConfiguration : public xsd__anyType
{
public:
	std::string *PaneName;	/* optional element of type xsd:string */
	std::string *AudioOutputToken;	/* optional element of type ns2:ReferenceToken */
	std::string *AudioSourceToken;	/* optional element of type ns2:ReferenceToken */
	ns2__AudioEncoderConfiguration *AudioEncoderConfiguration;	/* optional element of type ns2:AudioEncoderConfiguration */
	std::string *ReceiverToken;	/* optional element of type ns2:ReferenceToken */
	std::string Token;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 592; } /* = unique type id SOAP_TYPE_ns2__PaneConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PaneConfiguration() { ns2__PaneConfiguration::soap_default(NULL); }
	virtual ~ns2__PaneConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PaneLayout
#define SOAP_TYPE_ns2__PaneLayout (593)
/* ns2:PaneLayout */
class SOAP_CMAC ns2__PaneLayout : public xsd__anyType
{
public:
	std::string Pane;	/* required element of type ns2:ReferenceToken */
	ns2__Rectangle *Area;	/* required element of type ns2:Rectangle */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 593; } /* = unique type id SOAP_TYPE_ns2__PaneLayout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PaneLayout() { ns2__PaneLayout::soap_default(NULL); }
	virtual ~ns2__PaneLayout() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Layout
#define SOAP_TYPE_ns2__Layout (594)
/* ns2:Layout */
class SOAP_CMAC ns2__Layout : public xsd__anyType
{
public:
	std::vector<ns2__PaneLayout * >PaneLayout;	/* required element of type ns2:PaneLayout */
	class ns2__LayoutExtension *Extension;	/* optional element of type ns2:LayoutExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 594; } /* = unique type id SOAP_TYPE_ns2__Layout */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Layout() { ns2__Layout::soap_default(NULL); }
	virtual ~ns2__Layout() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LayoutExtension
#define SOAP_TYPE_ns2__LayoutExtension (595)
/* ns2:LayoutExtension */
class SOAP_CMAC ns2__LayoutExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 595; } /* = unique type id SOAP_TYPE_ns2__LayoutExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LayoutExtension() { ns2__LayoutExtension::soap_default(NULL); }
	virtual ~ns2__LayoutExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CodingCapabilities
#define SOAP_TYPE_ns2__CodingCapabilities (596)
/* ns2:CodingCapabilities */
class SOAP_CMAC ns2__CodingCapabilities : public xsd__anyType
{
public:
	ns2__AudioEncoderConfigurationOptions *AudioEncodingCapabilities;	/* optional element of type ns2:AudioEncoderConfigurationOptions */
	ns2__AudioDecoderConfigurationOptions *AudioDecodingCapabilities;	/* optional element of type ns2:AudioDecoderConfigurationOptions */
	ns2__VideoDecoderConfigurationOptions *VideoDecodingCapabilities;	/* required element of type ns2:VideoDecoderConfigurationOptions */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 596; } /* = unique type id SOAP_TYPE_ns2__CodingCapabilities */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CodingCapabilities() { ns2__CodingCapabilities::soap_default(NULL); }
	virtual ~ns2__CodingCapabilities() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LayoutOptions
#define SOAP_TYPE_ns2__LayoutOptions (597)
/* ns2:LayoutOptions */
class SOAP_CMAC ns2__LayoutOptions : public xsd__anyType
{
public:
	std::vector<class ns2__PaneLayoutOptions * >PaneLayoutOptions;	/* required element of type ns2:PaneLayoutOptions */
	class ns2__LayoutOptionsExtension *Extension;	/* optional element of type ns2:LayoutOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 597; } /* = unique type id SOAP_TYPE_ns2__LayoutOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LayoutOptions() { ns2__LayoutOptions::soap_default(NULL); }
	virtual ~ns2__LayoutOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__LayoutOptionsExtension
#define SOAP_TYPE_ns2__LayoutOptionsExtension (598)
/* ns2:LayoutOptionsExtension */
class SOAP_CMAC ns2__LayoutOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 598; } /* = unique type id SOAP_TYPE_ns2__LayoutOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__LayoutOptionsExtension() { ns2__LayoutOptionsExtension::soap_default(NULL); }
	virtual ~ns2__LayoutOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PaneLayoutOptions
#define SOAP_TYPE_ns2__PaneLayoutOptions (599)
/* ns2:PaneLayoutOptions */
class SOAP_CMAC ns2__PaneLayoutOptions : public xsd__anyType
{
public:
	std::vector<ns2__Rectangle * >Area;	/* required element of type ns2:Rectangle */
	class ns2__PaneOptionExtension *Extension;	/* optional element of type ns2:PaneOptionExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 599; } /* = unique type id SOAP_TYPE_ns2__PaneLayoutOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PaneLayoutOptions() { ns2__PaneLayoutOptions::soap_default(NULL); }
	virtual ~ns2__PaneLayoutOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PaneOptionExtension
#define SOAP_TYPE_ns2__PaneOptionExtension (600)
/* ns2:PaneOptionExtension */
class SOAP_CMAC ns2__PaneOptionExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 600; } /* = unique type id SOAP_TYPE_ns2__PaneOptionExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PaneOptionExtension() { ns2__PaneOptionExtension::soap_default(NULL); }
	virtual ~ns2__PaneOptionExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Receiver
#define SOAP_TYPE_ns2__Receiver (601)
/* ns2:Receiver */
class SOAP_CMAC ns2__Receiver : public xsd__anyType
{
public:
	std::string Token;	/* required element of type ns2:ReferenceToken */
	class ns2__ReceiverConfiguration *Configuration;	/* required element of type ns2:ReceiverConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 601; } /* = unique type id SOAP_TYPE_ns2__Receiver */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Receiver() { ns2__Receiver::soap_default(NULL); }
	virtual ~ns2__Receiver() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReceiverConfiguration
#define SOAP_TYPE_ns2__ReceiverConfiguration (602)
/* ns2:ReceiverConfiguration */
class SOAP_CMAC ns2__ReceiverConfiguration : public xsd__anyType
{
public:
	enum ns2__ReceiverMode Mode;	/* required element of type ns2:ReceiverMode */
	std::string MediaUri;	/* required element of type xsd:anyURI */
	ns2__StreamSetup *StreamSetup;	/* required element of type ns2:StreamSetup */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 602; } /* = unique type id SOAP_TYPE_ns2__ReceiverConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReceiverConfiguration() { ns2__ReceiverConfiguration::soap_default(NULL); }
	virtual ~ns2__ReceiverConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReceiverStateInformation
#define SOAP_TYPE_ns2__ReceiverStateInformation (603)
/* ns2:ReceiverStateInformation */
class SOAP_CMAC ns2__ReceiverStateInformation : public xsd__anyType
{
public:
	enum ns2__ReceiverState State;	/* required element of type ns2:ReceiverState */
	bool AutoCreated;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 603; } /* = unique type id SOAP_TYPE_ns2__ReceiverStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReceiverStateInformation() { ns2__ReceiverStateInformation::soap_default(NULL); }
	virtual ~ns2__ReceiverStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SourceReference
#define SOAP_TYPE_ns2__SourceReference (604)
/* ns2:SourceReference */
class SOAP_CMAC ns2__SourceReference : public xsd__anyType
{
public:
	std::string Token;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	std::string Type;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 604; } /* = unique type id SOAP_TYPE_ns2__SourceReference */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SourceReference() { ns2__SourceReference::soap_default(NULL); }
	virtual ~ns2__SourceReference() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DateTimeRange
#define SOAP_TYPE_ns2__DateTimeRange (605)
/* ns2:DateTimeRange */
class SOAP_CMAC ns2__DateTimeRange : public xsd__anyType
{
public:
	time_t From;	/* required element of type xsd:dateTime */
	time_t Until;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 605; } /* = unique type id SOAP_TYPE_ns2__DateTimeRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DateTimeRange() { ns2__DateTimeRange::soap_default(NULL); }
	virtual ~ns2__DateTimeRange() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingSummary
#define SOAP_TYPE_ns2__RecordingSummary (606)
/* ns2:RecordingSummary */
class SOAP_CMAC ns2__RecordingSummary : public xsd__anyType
{
public:
	time_t DataFrom;	/* required element of type xsd:dateTime */
	time_t DataUntil;	/* required element of type xsd:dateTime */
	int NumberRecordings;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 606; } /* = unique type id SOAP_TYPE_ns2__RecordingSummary */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingSummary() { ns2__RecordingSummary::soap_default(NULL); }
	virtual ~ns2__RecordingSummary() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SearchScope
#define SOAP_TYPE_ns2__SearchScope (607)
/* ns2:SearchScope */
class SOAP_CMAC ns2__SearchScope : public xsd__anyType
{
public:
	std::vector<ns2__SourceReference * >IncludedSources;	/* optional element of type ns2:SourceReference */
	std::vector<std::string >IncludedRecordings;	/* optional element of type ns2:RecordingReference */
	std::string *RecordingInformationFilter;	/* optional element of type ns2:XPathExpression */
	class ns2__SearchScopeExtension *Extension;	/* optional element of type ns2:SearchScopeExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 607; } /* = unique type id SOAP_TYPE_ns2__SearchScope */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SearchScope() { ns2__SearchScope::soap_default(NULL); }
	virtual ~ns2__SearchScope() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SearchScopeExtension
#define SOAP_TYPE_ns2__SearchScopeExtension (608)
/* ns2:SearchScopeExtension */
class SOAP_CMAC ns2__SearchScopeExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 608; } /* = unique type id SOAP_TYPE_ns2__SearchScopeExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SearchScopeExtension() { ns2__SearchScopeExtension::soap_default(NULL); }
	virtual ~ns2__SearchScopeExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZPositionFilter
#define SOAP_TYPE_ns2__PTZPositionFilter (610)
/* ns2:PTZPositionFilter */
class SOAP_CMAC ns2__PTZPositionFilter : public xsd__anyType
{
public:
	ns2__PTZVector *MinPosition;	/* required element of type ns2:PTZVector */
	ns2__PTZVector *MaxPosition;	/* required element of type ns2:PTZVector */
	bool EnterOrExit;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 610; } /* = unique type id SOAP_TYPE_ns2__PTZPositionFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZPositionFilter() { ns2__PTZPositionFilter::soap_default(NULL); }
	virtual ~ns2__PTZPositionFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataFilter
#define SOAP_TYPE_ns2__MetadataFilter (611)
/* ns2:MetadataFilter */
class SOAP_CMAC ns2__MetadataFilter : public xsd__anyType
{
public:
	std::string MetadataStreamFilter;	/* required element of type ns2:XPathExpression */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 611; } /* = unique type id SOAP_TYPE_ns2__MetadataFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataFilter() { ns2__MetadataFilter::soap_default(NULL); }
	virtual ~ns2__MetadataFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FindRecordingResultList
#define SOAP_TYPE_ns2__FindRecordingResultList (612)
/* ns2:FindRecordingResultList */
class SOAP_CMAC ns2__FindRecordingResultList : public xsd__anyType
{
public:
	enum ns2__SearchState SearchState;	/* required element of type ns2:SearchState */
	std::vector<class ns2__RecordingInformation * >RecordingInformation;	/* optional element of type ns2:RecordingInformation */
public:
	virtual int soap_type() const { return 612; } /* = unique type id SOAP_TYPE_ns2__FindRecordingResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FindRecordingResultList() { ns2__FindRecordingResultList::soap_default(NULL); }
	virtual ~ns2__FindRecordingResultList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FindEventResultList
#define SOAP_TYPE_ns2__FindEventResultList (613)
/* ns2:FindEventResultList */
class SOAP_CMAC ns2__FindEventResultList : public xsd__anyType
{
public:
	enum ns2__SearchState SearchState;	/* required element of type ns2:SearchState */
	std::vector<class ns2__FindEventResult * >Result;	/* optional element of type ns2:FindEventResult */
public:
	virtual int soap_type() const { return 613; } /* = unique type id SOAP_TYPE_ns2__FindEventResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FindEventResultList() { ns2__FindEventResultList::soap_default(NULL); }
	virtual ~ns2__FindEventResultList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FindEventResult
#define SOAP_TYPE_ns2__FindEventResult (614)
/* ns2:FindEventResult */
class SOAP_CMAC ns2__FindEventResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	std::string TrackToken;	/* required element of type ns2:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	ns3__NotificationMessageHolderType *Event;	/* required element of type ns3:NotificationMessageHolderType */
	bool StartStateEvent;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 614; } /* = unique type id SOAP_TYPE_ns2__FindEventResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FindEventResult() { ns2__FindEventResult::soap_default(NULL); }
	virtual ~ns2__FindEventResult() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FindPTZPositionResultList
#define SOAP_TYPE_ns2__FindPTZPositionResultList (615)
/* ns2:FindPTZPositionResultList */
class SOAP_CMAC ns2__FindPTZPositionResultList : public xsd__anyType
{
public:
	enum ns2__SearchState SearchState;	/* required element of type ns2:SearchState */
	std::vector<class ns2__FindPTZPositionResult * >Result;	/* optional element of type ns2:FindPTZPositionResult */
public:
	virtual int soap_type() const { return 615; } /* = unique type id SOAP_TYPE_ns2__FindPTZPositionResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FindPTZPositionResultList() { ns2__FindPTZPositionResultList::soap_default(NULL); }
	virtual ~ns2__FindPTZPositionResultList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FindPTZPositionResult
#define SOAP_TYPE_ns2__FindPTZPositionResult (616)
/* ns2:FindPTZPositionResult */
class SOAP_CMAC ns2__FindPTZPositionResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	std::string TrackToken;	/* required element of type ns2:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	ns2__PTZVector *Position;	/* required element of type ns2:PTZVector */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 616; } /* = unique type id SOAP_TYPE_ns2__FindPTZPositionResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FindPTZPositionResult() { ns2__FindPTZPositionResult::soap_default(NULL); }
	virtual ~ns2__FindPTZPositionResult() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FindMetadataResultList
#define SOAP_TYPE_ns2__FindMetadataResultList (617)
/* ns2:FindMetadataResultList */
class SOAP_CMAC ns2__FindMetadataResultList : public xsd__anyType
{
public:
	enum ns2__SearchState SearchState;	/* required element of type ns2:SearchState */
	std::vector<class ns2__FindMetadataResult * >Result;	/* optional element of type ns2:FindMetadataResult */
public:
	virtual int soap_type() const { return 617; } /* = unique type id SOAP_TYPE_ns2__FindMetadataResultList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FindMetadataResultList() { ns2__FindMetadataResultList::soap_default(NULL); }
	virtual ~ns2__FindMetadataResultList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FindMetadataResult
#define SOAP_TYPE_ns2__FindMetadataResult (618)
/* ns2:FindMetadataResult */
class SOAP_CMAC ns2__FindMetadataResult : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	std::string TrackToken;	/* required element of type ns2:TrackReference */
	time_t Time;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 618; } /* = unique type id SOAP_TYPE_ns2__FindMetadataResult */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FindMetadataResult() { ns2__FindMetadataResult::soap_default(NULL); }
	virtual ~ns2__FindMetadataResult() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingInformation
#define SOAP_TYPE_ns2__RecordingInformation (619)
/* ns2:RecordingInformation */
class SOAP_CMAC ns2__RecordingInformation : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	class ns2__RecordingSourceInformation *Source;	/* required element of type ns2:RecordingSourceInformation */
	time_t *EarliestRecording;	/* optional element of type xsd:dateTime */
	time_t *LatestRecording;	/* optional element of type xsd:dateTime */
	std::string Content;	/* required element of type ns2:Description */
	std::vector<class ns2__TrackInformation * >Track;	/* optional element of type ns2:TrackInformation */
	enum ns2__RecordingStatus RecordingStatus;	/* required element of type ns2:RecordingStatus */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 619; } /* = unique type id SOAP_TYPE_ns2__RecordingInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingInformation() { ns2__RecordingInformation::soap_default(NULL); }
	virtual ~ns2__RecordingInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingSourceInformation
#define SOAP_TYPE_ns2__RecordingSourceInformation (620)
/* ns2:RecordingSourceInformation */
class SOAP_CMAC ns2__RecordingSourceInformation : public xsd__anyType
{
public:
	std::string SourceId;	/* required element of type xsd:anyURI */
	std::string Name;	/* required element of type ns2:Name */
	std::string Location;	/* required element of type ns2:Description */
	std::string Description;	/* required element of type ns2:Description */
	std::string Address;	/* required element of type xsd:anyURI */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 620; } /* = unique type id SOAP_TYPE_ns2__RecordingSourceInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingSourceInformation() { ns2__RecordingSourceInformation::soap_default(NULL); }
	virtual ~ns2__RecordingSourceInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TrackInformation
#define SOAP_TYPE_ns2__TrackInformation (621)
/* ns2:TrackInformation */
class SOAP_CMAC ns2__TrackInformation : public xsd__anyType
{
public:
	std::string TrackToken;	/* required element of type ns2:TrackReference */
	enum ns2__TrackType TrackType;	/* required element of type ns2:TrackType */
	std::string Description;	/* required element of type ns2:Description */
	time_t DataFrom;	/* required element of type xsd:dateTime */
	time_t DataTo;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 621; } /* = unique type id SOAP_TYPE_ns2__TrackInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TrackInformation() { ns2__TrackInformation::soap_default(NULL); }
	virtual ~ns2__TrackInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MediaAttributes
#define SOAP_TYPE_ns2__MediaAttributes (622)
/* ns2:MediaAttributes */
class SOAP_CMAC ns2__MediaAttributes : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	std::vector<class ns2__TrackAttributes * >TrackAttributes;	/* optional element of type ns2:TrackAttributes */
	time_t From;	/* required element of type xsd:dateTime */
	time_t Until;	/* required element of type xsd:dateTime */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 622; } /* = unique type id SOAP_TYPE_ns2__MediaAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MediaAttributes() { ns2__MediaAttributes::soap_default(NULL); }
	virtual ~ns2__MediaAttributes() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TrackAttributes
#define SOAP_TYPE_ns2__TrackAttributes (623)
/* ns2:TrackAttributes */
class SOAP_CMAC ns2__TrackAttributes : public xsd__anyType
{
public:
	ns2__TrackInformation *TrackInformation;	/* required element of type ns2:TrackInformation */
	class ns2__VideoAttributes *VideoAttributes;	/* optional element of type ns2:VideoAttributes */
	class ns2__AudioAttributes *AudioAttributes;	/* optional element of type ns2:AudioAttributes */
	class ns2__MetadataAttributes *MetadataAttributes;	/* optional element of type ns2:MetadataAttributes */
	class ns2__TrackAttributesExtension *Extension;	/* optional element of type ns2:TrackAttributesExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 623; } /* = unique type id SOAP_TYPE_ns2__TrackAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TrackAttributes() { ns2__TrackAttributes::soap_default(NULL); }
	virtual ~ns2__TrackAttributes() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TrackAttributesExtension
#define SOAP_TYPE_ns2__TrackAttributesExtension (624)
/* ns2:TrackAttributesExtension */
class SOAP_CMAC ns2__TrackAttributesExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 624; } /* = unique type id SOAP_TYPE_ns2__TrackAttributesExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TrackAttributesExtension() { ns2__TrackAttributesExtension::soap_default(NULL); }
	virtual ~ns2__TrackAttributesExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoAttributes
#define SOAP_TYPE_ns2__VideoAttributes (625)
/* ns2:VideoAttributes */
class SOAP_CMAC ns2__VideoAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of type xsd:int */
	int Width;	/* required element of type xsd:int */
	int Height;	/* required element of type xsd:int */
	enum ns2__VideoEncoding Encoding;	/* required element of type ns2:VideoEncoding */
	float Framerate;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 625; } /* = unique type id SOAP_TYPE_ns2__VideoAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoAttributes() { ns2__VideoAttributes::soap_default(NULL); }
	virtual ~ns2__VideoAttributes() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioAttributes
#define SOAP_TYPE_ns2__AudioAttributes (626)
/* ns2:AudioAttributes */
class SOAP_CMAC ns2__AudioAttributes : public xsd__anyType
{
public:
	int *Bitrate;	/* optional element of type xsd:int */
	enum ns2__AudioEncoding Encoding;	/* required element of type ns2:AudioEncoding */
	int Samplerate;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 626; } /* = unique type id SOAP_TYPE_ns2__AudioAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioAttributes() { ns2__AudioAttributes::soap_default(NULL); }
	virtual ~ns2__AudioAttributes() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataAttributes
#define SOAP_TYPE_ns2__MetadataAttributes (627)
/* ns2:MetadataAttributes */
class SOAP_CMAC ns2__MetadataAttributes : public xsd__anyType
{
public:
	bool CanContainPTZ;	/* required element of type xsd:boolean */
	bool CanContainAnalytics;	/* required element of type xsd:boolean */
	bool CanContainNotifications;	/* required element of type xsd:boolean */
	std::vector<char * >__any;
	std::string *PtzSpaces;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 627; } /* = unique type id SOAP_TYPE_ns2__MetadataAttributes */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataAttributes() { ns2__MetadataAttributes::soap_default(NULL); }
	virtual ~ns2__MetadataAttributes() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingConfiguration
#define SOAP_TYPE_ns2__RecordingConfiguration (628)
/* ns2:RecordingConfiguration */
class SOAP_CMAC ns2__RecordingConfiguration : public xsd__anyType
{
public:
	ns2__RecordingSourceInformation *Source;	/* required element of type ns2:RecordingSourceInformation */
	std::string Content;	/* required element of type ns2:Description */
	std::string MaximumRetentionTime;	/* required element of type xsd:duration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 628; } /* = unique type id SOAP_TYPE_ns2__RecordingConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingConfiguration() { ns2__RecordingConfiguration::soap_default(NULL); }
	virtual ~ns2__RecordingConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__TrackConfiguration
#define SOAP_TYPE_ns2__TrackConfiguration (629)
/* ns2:TrackConfiguration */
class SOAP_CMAC ns2__TrackConfiguration : public xsd__anyType
{
public:
	enum ns2__TrackType TrackType;	/* required element of type ns2:TrackType */
	std::string Description;	/* required element of type ns2:Description */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 629; } /* = unique type id SOAP_TYPE_ns2__TrackConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__TrackConfiguration() { ns2__TrackConfiguration::soap_default(NULL); }
	virtual ~ns2__TrackConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__GetRecordingsResponseItem
#define SOAP_TYPE_ns2__GetRecordingsResponseItem (630)
/* ns2:GetRecordingsResponseItem */
class SOAP_CMAC ns2__GetRecordingsResponseItem : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	ns2__RecordingConfiguration *Configuration;	/* required element of type ns2:RecordingConfiguration */
	class ns2__GetTracksResponseList *Tracks;	/* required element of type ns2:GetTracksResponseList */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 630; } /* = unique type id SOAP_TYPE_ns2__GetRecordingsResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__GetRecordingsResponseItem() { ns2__GetRecordingsResponseItem::soap_default(NULL); }
	virtual ~ns2__GetRecordingsResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_ns2__GetTracksResponseList
#define SOAP_TYPE_ns2__GetTracksResponseList (631)
/* ns2:GetTracksResponseList */
class SOAP_CMAC ns2__GetTracksResponseList : public xsd__anyType
{
public:
	std::vector<class ns2__GetTracksResponseItem * >Track;	/* optional element of type ns2:GetTracksResponseItem */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 631; } /* = unique type id SOAP_TYPE_ns2__GetTracksResponseList */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__GetTracksResponseList() { ns2__GetTracksResponseList::soap_default(NULL); }
	virtual ~ns2__GetTracksResponseList() { }
};
#endif

#ifndef SOAP_TYPE_ns2__GetTracksResponseItem
#define SOAP_TYPE_ns2__GetTracksResponseItem (632)
/* ns2:GetTracksResponseItem */
class SOAP_CMAC ns2__GetTracksResponseItem : public xsd__anyType
{
public:
	std::string TrackToken;	/* required element of type ns2:TrackReference */
	ns2__TrackConfiguration *Configuration;	/* required element of type ns2:TrackConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 632; } /* = unique type id SOAP_TYPE_ns2__GetTracksResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__GetTracksResponseItem() { ns2__GetTracksResponseItem::soap_default(NULL); }
	virtual ~ns2__GetTracksResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobConfiguration
#define SOAP_TYPE_ns2__RecordingJobConfiguration (633)
/* ns2:RecordingJobConfiguration */
class SOAP_CMAC ns2__RecordingJobConfiguration : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	std::string Mode;	/* required element of type ns2:RecordingJobMode */
	int Priority;	/* required element of type xsd:int */
	std::vector<class ns2__RecordingJobSource * >Source;	/* optional element of type ns2:RecordingJobSource */
	class ns2__RecordingJobConfigurationExtension *Extension;	/* optional element of type ns2:RecordingJobConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 633; } /* = unique type id SOAP_TYPE_ns2__RecordingJobConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobConfiguration() { ns2__RecordingJobConfiguration::soap_default(NULL); }
	virtual ~ns2__RecordingJobConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobConfigurationExtension
#define SOAP_TYPE_ns2__RecordingJobConfigurationExtension (634)
/* ns2:RecordingJobConfigurationExtension */
class SOAP_CMAC ns2__RecordingJobConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 634; } /* = unique type id SOAP_TYPE_ns2__RecordingJobConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobConfigurationExtension() { ns2__RecordingJobConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__RecordingJobConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobSource
#define SOAP_TYPE_ns2__RecordingJobSource (635)
/* ns2:RecordingJobSource */
class SOAP_CMAC ns2__RecordingJobSource : public xsd__anyType
{
public:
	ns2__SourceReference *SourceToken;	/* optional element of type ns2:SourceReference */
	bool *AutoCreateReceiver;	/* optional element of type xsd:boolean */
	std::vector<class ns2__RecordingJobTrack * >Tracks;	/* optional element of type ns2:RecordingJobTrack */
	class ns2__RecordingJobSourceExtension *Extension;	/* optional element of type ns2:RecordingJobSourceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 635; } /* = unique type id SOAP_TYPE_ns2__RecordingJobSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobSource() { ns2__RecordingJobSource::soap_default(NULL); }
	virtual ~ns2__RecordingJobSource() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobSourceExtension
#define SOAP_TYPE_ns2__RecordingJobSourceExtension (636)
/* ns2:RecordingJobSourceExtension */
class SOAP_CMAC ns2__RecordingJobSourceExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 636; } /* = unique type id SOAP_TYPE_ns2__RecordingJobSourceExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobSourceExtension() { ns2__RecordingJobSourceExtension::soap_default(NULL); }
	virtual ~ns2__RecordingJobSourceExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobTrack
#define SOAP_TYPE_ns2__RecordingJobTrack (637)
/* ns2:RecordingJobTrack */
class SOAP_CMAC ns2__RecordingJobTrack : public xsd__anyType
{
public:
	std::string SourceTag;	/* required element of type xsd:string */
	std::string Destination;	/* required element of type ns2:TrackReference */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 637; } /* = unique type id SOAP_TYPE_ns2__RecordingJobTrack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobTrack() { ns2__RecordingJobTrack::soap_default(NULL); }
	virtual ~ns2__RecordingJobTrack() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobStateInformation
#define SOAP_TYPE_ns2__RecordingJobStateInformation (638)
/* ns2:RecordingJobStateInformation */
class SOAP_CMAC ns2__RecordingJobStateInformation : public xsd__anyType
{
public:
	std::string RecordingToken;	/* required element of type ns2:RecordingReference */
	std::string State;	/* required element of type ns2:RecordingJobState */
	std::vector<class ns2__RecordingJobStateSource * >Sources;	/* optional element of type ns2:RecordingJobStateSource */
	class ns2__RecordingJobStateInformationExtension *Extension;	/* optional element of type ns2:RecordingJobStateInformationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 638; } /* = unique type id SOAP_TYPE_ns2__RecordingJobStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobStateInformation() { ns2__RecordingJobStateInformation::soap_default(NULL); }
	virtual ~ns2__RecordingJobStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobStateInformationExtension
#define SOAP_TYPE_ns2__RecordingJobStateInformationExtension (639)
/* ns2:RecordingJobStateInformationExtension */
class SOAP_CMAC ns2__RecordingJobStateInformationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 639; } /* = unique type id SOAP_TYPE_ns2__RecordingJobStateInformationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobStateInformationExtension() { ns2__RecordingJobStateInformationExtension::soap_default(NULL); }
	virtual ~ns2__RecordingJobStateInformationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobStateSource
#define SOAP_TYPE_ns2__RecordingJobStateSource (640)
/* ns2:RecordingJobStateSource */
class SOAP_CMAC ns2__RecordingJobStateSource : public xsd__anyType
{
public:
	ns2__SourceReference *SourceToken;	/* required element of type ns2:SourceReference */
	std::string State;	/* required element of type ns2:RecordingJobState */
	class ns2__RecordingJobStateTracks *Tracks;	/* required element of type ns2:RecordingJobStateTracks */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 640; } /* = unique type id SOAP_TYPE_ns2__RecordingJobStateSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobStateSource() { ns2__RecordingJobStateSource::soap_default(NULL); }
	virtual ~ns2__RecordingJobStateSource() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobStateTracks
#define SOAP_TYPE_ns2__RecordingJobStateTracks (641)
/* ns2:RecordingJobStateTracks */
class SOAP_CMAC ns2__RecordingJobStateTracks : public xsd__anyType
{
public:
	std::vector<class ns2__RecordingJobStateTrack * >Track;	/* optional element of type ns2:RecordingJobStateTrack */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 641; } /* = unique type id SOAP_TYPE_ns2__RecordingJobStateTracks */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobStateTracks() { ns2__RecordingJobStateTracks::soap_default(NULL); }
	virtual ~ns2__RecordingJobStateTracks() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobStateTrack
#define SOAP_TYPE_ns2__RecordingJobStateTrack (642)
/* ns2:RecordingJobStateTrack */
class SOAP_CMAC ns2__RecordingJobStateTrack : public xsd__anyType
{
public:
	std::string SourceTag;	/* required element of type xsd:string */
	std::string Destination;	/* required element of type ns2:TrackReference */
	std::string *Error;	/* optional element of type xsd:string */
	std::string State;	/* required element of type ns2:RecordingJobState */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 642; } /* = unique type id SOAP_TYPE_ns2__RecordingJobStateTrack */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RecordingJobStateTrack() { ns2__RecordingJobStateTrack::soap_default(NULL); }
	virtual ~ns2__RecordingJobStateTrack() { }
};
#endif

#ifndef SOAP_TYPE_ns2__GetRecordingJobsResponseItem
#define SOAP_TYPE_ns2__GetRecordingJobsResponseItem (643)
/* ns2:GetRecordingJobsResponseItem */
class SOAP_CMAC ns2__GetRecordingJobsResponseItem : public xsd__anyType
{
public:
	std::string JobToken;	/* required element of type ns2:RecordingJobReference */
	ns2__RecordingJobConfiguration *JobConfiguration;	/* required element of type ns2:RecordingJobConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 643; } /* = unique type id SOAP_TYPE_ns2__GetRecordingJobsResponseItem */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__GetRecordingJobsResponseItem() { ns2__GetRecordingJobsResponseItem::soap_default(NULL); }
	virtual ~ns2__GetRecordingJobsResponseItem() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ReplayConfiguration
#define SOAP_TYPE_ns2__ReplayConfiguration (644)
/* ns2:ReplayConfiguration */
class SOAP_CMAC ns2__ReplayConfiguration : public xsd__anyType
{
public:
	std::string SessionTimeout;	/* required element of type xsd:duration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 644; } /* = unique type id SOAP_TYPE_ns2__ReplayConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ReplayConfiguration() { ns2__ReplayConfiguration::soap_default(NULL); }
	virtual ~ns2__ReplayConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration
#define SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration (646)
/* ns2:AnalyticsDeviceEngineConfiguration */
class SOAP_CMAC ns2__AnalyticsDeviceEngineConfiguration : public xsd__anyType
{
public:
	std::vector<class ns2__EngineConfiguration * >EngineConfiguration;	/* required element of type ns2:EngineConfiguration */
	class ns2__AnalyticsDeviceEngineConfigurationExtension *Extension;	/* optional element of type ns2:AnalyticsDeviceEngineConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 646; } /* = unique type id SOAP_TYPE_ns2__AnalyticsDeviceEngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsDeviceEngineConfiguration() { ns2__AnalyticsDeviceEngineConfiguration::soap_default(NULL); }
	virtual ~ns2__AnalyticsDeviceEngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension
#define SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension (647)
/* ns2:AnalyticsDeviceEngineConfigurationExtension */
class SOAP_CMAC ns2__AnalyticsDeviceEngineConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 647; } /* = unique type id SOAP_TYPE_ns2__AnalyticsDeviceEngineConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsDeviceEngineConfigurationExtension() { ns2__AnalyticsDeviceEngineConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__AnalyticsDeviceEngineConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EngineConfiguration
#define SOAP_TYPE_ns2__EngineConfiguration (648)
/* ns2:EngineConfiguration */
class SOAP_CMAC ns2__EngineConfiguration : public xsd__anyType
{
public:
	ns2__VideoAnalyticsConfiguration *VideoAnalyticsConfiguration;	/* required element of type ns2:VideoAnalyticsConfiguration */
	class ns2__AnalyticsEngineInputInfo *AnalyticsEngineInputInfo;	/* required element of type ns2:AnalyticsEngineInputInfo */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 648; } /* = unique type id SOAP_TYPE_ns2__EngineConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EngineConfiguration() { ns2__EngineConfiguration::soap_default(NULL); }
	virtual ~ns2__EngineConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsEngineInputInfo
#define SOAP_TYPE_ns2__AnalyticsEngineInputInfo (649)
/* ns2:AnalyticsEngineInputInfo */
class SOAP_CMAC ns2__AnalyticsEngineInputInfo : public xsd__anyType
{
public:
	ns2__Config *InputInfo;	/* optional element of type ns2:Config */
	class ns2__AnalyticsEngineInputInfoExtension *Extension;	/* optional element of type ns2:AnalyticsEngineInputInfoExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 649; } /* = unique type id SOAP_TYPE_ns2__AnalyticsEngineInputInfo */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsEngineInputInfo() { ns2__AnalyticsEngineInputInfo::soap_default(NULL); }
	virtual ~ns2__AnalyticsEngineInputInfo() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension
#define SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension (650)
/* ns2:AnalyticsEngineInputInfoExtension */
class SOAP_CMAC ns2__AnalyticsEngineInputInfoExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 650; } /* = unique type id SOAP_TYPE_ns2__AnalyticsEngineInputInfoExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsEngineInputInfoExtension() { ns2__AnalyticsEngineInputInfoExtension::soap_default(NULL); }
	virtual ~ns2__AnalyticsEngineInputInfoExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SourceIdentification
#define SOAP_TYPE_ns2__SourceIdentification (652)
/* ns2:SourceIdentification */
class SOAP_CMAC ns2__SourceIdentification : public xsd__anyType
{
public:
	std::string Name;	/* required element of type xsd:string */
	std::vector<std::string >Token;	/* required element of type ns2:ReferenceToken */
	class ns2__SourceIdentificationExtension *Extension;	/* optional element of type ns2:SourceIdentificationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 652; } /* = unique type id SOAP_TYPE_ns2__SourceIdentification */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SourceIdentification() { ns2__SourceIdentification::soap_default(NULL); }
	virtual ~ns2__SourceIdentification() { }
};
#endif

#ifndef SOAP_TYPE_ns2__SourceIdentificationExtension
#define SOAP_TYPE_ns2__SourceIdentificationExtension (653)
/* ns2:SourceIdentificationExtension */
class SOAP_CMAC ns2__SourceIdentificationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 653; } /* = unique type id SOAP_TYPE_ns2__SourceIdentificationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__SourceIdentificationExtension() { ns2__SourceIdentificationExtension::soap_default(NULL); }
	virtual ~ns2__SourceIdentificationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataInput
#define SOAP_TYPE_ns2__MetadataInput (654)
/* ns2:MetadataInput */
class SOAP_CMAC ns2__MetadataInput : public xsd__anyType
{
public:
	std::vector<ns2__Config * >MetadataConfig;	/* optional element of type ns2:Config */
	class ns2__MetadataInputExtension *Extension;	/* optional element of type ns2:MetadataInputExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 654; } /* = unique type id SOAP_TYPE_ns2__MetadataInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataInput() { ns2__MetadataInput::soap_default(NULL); }
	virtual ~ns2__MetadataInput() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataInputExtension
#define SOAP_TYPE_ns2__MetadataInputExtension (655)
/* ns2:MetadataInputExtension */
class SOAP_CMAC ns2__MetadataInputExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 655; } /* = unique type id SOAP_TYPE_ns2__MetadataInputExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataInputExtension() { ns2__MetadataInputExtension::soap_default(NULL); }
	virtual ~ns2__MetadataInputExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsStateInformation
#define SOAP_TYPE_ns2__AnalyticsStateInformation (657)
/* ns2:AnalyticsStateInformation */
class SOAP_CMAC ns2__AnalyticsStateInformation : public xsd__anyType
{
public:
	std::string AnalyticsEngineControlToken;	/* required element of type ns2:ReferenceToken */
	class ns2__AnalyticsState *State;	/* required element of type ns2:AnalyticsState */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 657; } /* = unique type id SOAP_TYPE_ns2__AnalyticsStateInformation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsStateInformation() { ns2__AnalyticsStateInformation::soap_default(NULL); }
	virtual ~ns2__AnalyticsStateInformation() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsState
#define SOAP_TYPE_ns2__AnalyticsState (658)
/* ns2:AnalyticsState */
class SOAP_CMAC ns2__AnalyticsState : public xsd__anyType
{
public:
	std::string *Error;	/* optional element of type xsd:string */
	std::string State;	/* required element of type xsd:string */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 658; } /* = unique type id SOAP_TYPE_ns2__AnalyticsState */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsState() { ns2__AnalyticsState::soap_default(NULL); }
	virtual ~ns2__AnalyticsState() { }
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (1437)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 1437; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

#ifndef SOAP_TYPE_ns2__ActionEngineEventPayload
#define SOAP_TYPE_ns2__ActionEngineEventPayload (659)
/* ns2:ActionEngineEventPayload */
class SOAP_CMAC ns2__ActionEngineEventPayload : public xsd__anyType
{
public:
	std::string *RequestInfo;	/* optional element of type SOAP-ENV:Envelope */
	std::string *ResponseInfo;	/* optional element of type SOAP-ENV:Envelope */
	struct SOAP_ENV__Fault *Fault;	/* optional element of type SOAP-ENV:Fault */
	class ns2__ActionEngineEventPayloadExtension *Extension;	/* optional element of type ns2:ActionEngineEventPayloadExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 659; } /* = unique type id SOAP_TYPE_ns2__ActionEngineEventPayload */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ActionEngineEventPayload() { ns2__ActionEngineEventPayload::soap_default(NULL); }
	virtual ~ns2__ActionEngineEventPayload() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ActionEngineEventPayloadExtension
#define SOAP_TYPE_ns2__ActionEngineEventPayloadExtension (660)
/* ns2:ActionEngineEventPayloadExtension */
class SOAP_CMAC ns2__ActionEngineEventPayloadExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 660; } /* = unique type id SOAP_TYPE_ns2__ActionEngineEventPayloadExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ActionEngineEventPayloadExtension() { ns2__ActionEngineEventPayloadExtension::soap_default(NULL); }
	virtual ~ns2__ActionEngineEventPayloadExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioClassCandidate
#define SOAP_TYPE_ns2__AudioClassCandidate (661)
/* ns2:AudioClassCandidate */
class SOAP_CMAC ns2__AudioClassCandidate : public xsd__anyType
{
public:
	std::string Type;	/* required element of type ns2:AudioClassType */
	float Likelihood;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 661; } /* = unique type id SOAP_TYPE_ns2__AudioClassCandidate */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioClassCandidate() { ns2__AudioClassCandidate::soap_default(NULL); }
	virtual ~ns2__AudioClassCandidate() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioClassDescriptor
#define SOAP_TYPE_ns2__AudioClassDescriptor (662)
/* ns2:AudioClassDescriptor */
class SOAP_CMAC ns2__AudioClassDescriptor : public xsd__anyType
{
public:
	std::vector<ns2__AudioClassCandidate * >ClassCandidate;	/* optional element of type ns2:AudioClassCandidate */
	class ns2__AudioClassDescriptorExtension *Extension;	/* optional element of type ns2:AudioClassDescriptorExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 662; } /* = unique type id SOAP_TYPE_ns2__AudioClassDescriptor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioClassDescriptor() { ns2__AudioClassDescriptor::soap_default(NULL); }
	virtual ~ns2__AudioClassDescriptor() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioClassDescriptorExtension
#define SOAP_TYPE_ns2__AudioClassDescriptorExtension (663)
/* ns2:AudioClassDescriptorExtension */
class SOAP_CMAC ns2__AudioClassDescriptorExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 663; } /* = unique type id SOAP_TYPE_ns2__AudioClassDescriptorExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioClassDescriptorExtension() { ns2__AudioClassDescriptorExtension::soap_default(NULL); }
	virtual ~ns2__AudioClassDescriptorExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDPosConfiguration
#define SOAP_TYPE_ns2__OSDPosConfiguration (665)
/* ns2:OSDPosConfiguration */
class SOAP_CMAC ns2__OSDPosConfiguration : public xsd__anyType
{
public:
	std::string Type;	/* required element of type xsd:string */
	ns2__Vector *Pos;	/* optional element of type ns2:Vector */
	class ns2__OSDPosConfigurationExtension *Extension;	/* optional element of type ns2:OSDPosConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 665; } /* = unique type id SOAP_TYPE_ns2__OSDPosConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDPosConfiguration() { ns2__OSDPosConfiguration::soap_default(NULL); }
	virtual ~ns2__OSDPosConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDPosConfigurationExtension
#define SOAP_TYPE_ns2__OSDPosConfigurationExtension (666)
/* ns2:OSDPosConfigurationExtension */
class SOAP_CMAC ns2__OSDPosConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 666; } /* = unique type id SOAP_TYPE_ns2__OSDPosConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDPosConfigurationExtension() { ns2__OSDPosConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__OSDPosConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDColor
#define SOAP_TYPE_ns2__OSDColor (667)
/* ns2:OSDColor */
class SOAP_CMAC ns2__OSDColor : public xsd__anyType
{
public:
	ns2__Color *Color;	/* required element of type ns2:Color */
	int *Transparent;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 667; } /* = unique type id SOAP_TYPE_ns2__OSDColor */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDColor() { ns2__OSDColor::soap_default(NULL); }
	virtual ~ns2__OSDColor() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDTextConfiguration
#define SOAP_TYPE_ns2__OSDTextConfiguration (668)
/* ns2:OSDTextConfiguration */
class SOAP_CMAC ns2__OSDTextConfiguration : public xsd__anyType
{
public:
	std::string Type;	/* required element of type xsd:string */
	std::string *DateFormat;	/* optional element of type xsd:string */
	std::string *TimeFormat;	/* optional element of type xsd:string */
	int *FontSize;	/* optional element of type xsd:int */
	ns2__OSDColor *FontColor;	/* optional element of type ns2:OSDColor */
	ns2__OSDColor *BackgroundColor;	/* optional element of type ns2:OSDColor */
	std::string *PlainText;	/* optional element of type xsd:string */
	class ns2__OSDTextConfigurationExtension *Extension;	/* optional element of type ns2:OSDTextConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 668; } /* = unique type id SOAP_TYPE_ns2__OSDTextConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDTextConfiguration() { ns2__OSDTextConfiguration::soap_default(NULL); }
	virtual ~ns2__OSDTextConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDTextConfigurationExtension
#define SOAP_TYPE_ns2__OSDTextConfigurationExtension (669)
/* ns2:OSDTextConfigurationExtension */
class SOAP_CMAC ns2__OSDTextConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 669; } /* = unique type id SOAP_TYPE_ns2__OSDTextConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDTextConfigurationExtension() { ns2__OSDTextConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__OSDTextConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDImgConfiguration
#define SOAP_TYPE_ns2__OSDImgConfiguration (670)
/* ns2:OSDImgConfiguration */
class SOAP_CMAC ns2__OSDImgConfiguration : public xsd__anyType
{
public:
	std::string ImgPath;	/* required element of type xsd:anyURI */
	class ns2__OSDImgConfigurationExtension *Extension;	/* optional element of type ns2:OSDImgConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 670; } /* = unique type id SOAP_TYPE_ns2__OSDImgConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDImgConfiguration() { ns2__OSDImgConfiguration::soap_default(NULL); }
	virtual ~ns2__OSDImgConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDImgConfigurationExtension
#define SOAP_TYPE_ns2__OSDImgConfigurationExtension (671)
/* ns2:OSDImgConfigurationExtension */
class SOAP_CMAC ns2__OSDImgConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 671; } /* = unique type id SOAP_TYPE_ns2__OSDImgConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDImgConfigurationExtension() { ns2__OSDImgConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__OSDImgConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ColorspaceRange
#define SOAP_TYPE_ns2__ColorspaceRange (672)
/* ns2:ColorspaceRange */
class SOAP_CMAC ns2__ColorspaceRange : public xsd__anyType
{
public:
	ns2__FloatRange *X;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Y;	/* required element of type ns2:FloatRange */
	ns2__FloatRange *Z;	/* required element of type ns2:FloatRange */
	std::string Colorspace;	/* required element of type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 672; } /* = unique type id SOAP_TYPE_ns2__ColorspaceRange */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ColorspaceRange() { ns2__ColorspaceRange::soap_default(NULL); }
	virtual ~ns2__ColorspaceRange() { }
};
#endif

#ifndef SOAP_TYPE__ns2__union_ColorOptions
#define SOAP_TYPE__ns2__union_ColorOptions (1452)
/* xsd:choice */
union _ns2__union_ColorOptions
{
#define SOAP_UNION__ns2__union_ColorOptions_ColorList	(1)
	std::vector<ns2__Color * >*ColorList;
#define SOAP_UNION__ns2__union_ColorOptions_ColorspaceRange	(2)
	std::vector<ns2__ColorspaceRange * >*ColorspaceRange;
};
#endif

#ifndef SOAP_TYPE_ns2__ColorOptions
#define SOAP_TYPE_ns2__ColorOptions (673)
/* ns2:ColorOptions */
class SOAP_CMAC ns2__ColorOptions : public xsd__anyType
{
public:
	int __union_ColorOptions;	/* union discriminant (of union defined below) */
	union _ns2__union_ColorOptions union_ColorOptions;	/* required element of type xsd:choice */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 673; } /* = unique type id SOAP_TYPE_ns2__ColorOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ColorOptions() { ns2__ColorOptions::soap_default(NULL); }
	virtual ~ns2__ColorOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDColorOptions
#define SOAP_TYPE_ns2__OSDColorOptions (674)
/* ns2:OSDColorOptions */
class SOAP_CMAC ns2__OSDColorOptions : public xsd__anyType
{
public:
	ns2__ColorOptions *Color;	/* optional element of type ns2:ColorOptions */
	ns2__IntRange *Transparent;	/* optional element of type ns2:IntRange */
	class ns2__OSDColorOptionsExtension *Extension;	/* optional element of type ns2:OSDColorOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 674; } /* = unique type id SOAP_TYPE_ns2__OSDColorOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDColorOptions() { ns2__OSDColorOptions::soap_default(NULL); }
	virtual ~ns2__OSDColorOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDColorOptionsExtension
#define SOAP_TYPE_ns2__OSDColorOptionsExtension (675)
/* ns2:OSDColorOptionsExtension */
class SOAP_CMAC ns2__OSDColorOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 675; } /* = unique type id SOAP_TYPE_ns2__OSDColorOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDColorOptionsExtension() { ns2__OSDColorOptionsExtension::soap_default(NULL); }
	virtual ~ns2__OSDColorOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDTextOptions
#define SOAP_TYPE_ns2__OSDTextOptions (676)
/* ns2:OSDTextOptions */
class SOAP_CMAC ns2__OSDTextOptions : public xsd__anyType
{
public:
	std::vector<std::string >Type;	/* required element of type xsd:string */
	ns2__IntRange *FontSizeRange;	/* optional element of type ns2:IntRange */
	std::vector<std::string >DateFormat;	/* optional element of type xsd:string */
	std::vector<std::string >TimeFormat;	/* optional element of type xsd:string */
	ns2__OSDColorOptions *FontColor;	/* optional element of type ns2:OSDColorOptions */
	ns2__OSDColorOptions *BackgroundColor;	/* optional element of type ns2:OSDColorOptions */
	class ns2__OSDTextOptionsExtension *Extension;	/* optional element of type ns2:OSDTextOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 676; } /* = unique type id SOAP_TYPE_ns2__OSDTextOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDTextOptions() { ns2__OSDTextOptions::soap_default(NULL); }
	virtual ~ns2__OSDTextOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDTextOptionsExtension
#define SOAP_TYPE_ns2__OSDTextOptionsExtension (677)
/* ns2:OSDTextOptionsExtension */
class SOAP_CMAC ns2__OSDTextOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 677; } /* = unique type id SOAP_TYPE_ns2__OSDTextOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDTextOptionsExtension() { ns2__OSDTextOptionsExtension::soap_default(NULL); }
	virtual ~ns2__OSDTextOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDImgOptions
#define SOAP_TYPE_ns2__OSDImgOptions (678)
/* ns2:OSDImgOptions */
class SOAP_CMAC ns2__OSDImgOptions : public xsd__anyType
{
public:
	std::vector<std::string >ImagePath;	/* required element of type xsd:anyURI */
	class ns2__OSDImgOptionsExtension *Extension;	/* optional element of type ns2:OSDImgOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 678; } /* = unique type id SOAP_TYPE_ns2__OSDImgOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDImgOptions() { ns2__OSDImgOptions::soap_default(NULL); }
	virtual ~ns2__OSDImgOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDImgOptionsExtension
#define SOAP_TYPE_ns2__OSDImgOptionsExtension (679)
/* ns2:OSDImgOptionsExtension */
class SOAP_CMAC ns2__OSDImgOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 679; } /* = unique type id SOAP_TYPE_ns2__OSDImgOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDImgOptionsExtension() { ns2__OSDImgOptionsExtension::soap_default(NULL); }
	virtual ~ns2__OSDImgOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDConfigurationExtension
#define SOAP_TYPE_ns2__OSDConfigurationExtension (681)
/* ns2:OSDConfigurationExtension */
class SOAP_CMAC ns2__OSDConfigurationExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 681; } /* = unique type id SOAP_TYPE_ns2__OSDConfigurationExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDConfigurationExtension() { ns2__OSDConfigurationExtension::soap_default(NULL); }
	virtual ~ns2__OSDConfigurationExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MaximumNumberOfOSDs
#define SOAP_TYPE_ns2__MaximumNumberOfOSDs (682)
/* Primitive ns2:MaximumNumberOfOSDs schema type: */
class SOAP_CMAC ns2__MaximumNumberOfOSDs : public xsd__anyType
{
public:
	int Total;	/* required attribute */
	int *Image;	/* optional attribute */
	int *PlainText;	/* optional attribute */
	int *Date;	/* optional attribute */
	int *Time;	/* optional attribute */
	int *DateAndTime;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 682; } /* = unique type id SOAP_TYPE_ns2__MaximumNumberOfOSDs */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MaximumNumberOfOSDs() { ns2__MaximumNumberOfOSDs::soap_default(NULL); }
	virtual ~ns2__MaximumNumberOfOSDs() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDConfigurationOptions
#define SOAP_TYPE_ns2__OSDConfigurationOptions (683)
/* ns2:OSDConfigurationOptions */
class SOAP_CMAC ns2__OSDConfigurationOptions : public xsd__anyType
{
public:
	ns2__MaximumNumberOfOSDs *MaximumNumberOfOSDs;	/* required element of type ns2:MaximumNumberOfOSDs */
	std::vector<enum ns2__OSDType >Type;	/* required element of type ns2:OSDType */
	std::vector<std::string >PositionOption;	/* required element of type xsd:string */
	ns2__OSDTextOptions *TextOption;	/* optional element of type ns2:OSDTextOptions */
	ns2__OSDImgOptions *ImageOption;	/* optional element of type ns2:OSDImgOptions */
	class ns2__OSDConfigurationOptionsExtension *Extension;	/* optional element of type ns2:OSDConfigurationOptionsExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 683; } /* = unique type id SOAP_TYPE_ns2__OSDConfigurationOptions */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDConfigurationOptions() { ns2__OSDConfigurationOptions::soap_default(NULL); }
	virtual ~ns2__OSDConfigurationOptions() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDConfigurationOptionsExtension
#define SOAP_TYPE_ns2__OSDConfigurationOptionsExtension (684)
/* ns2:OSDConfigurationOptionsExtension */
class SOAP_CMAC ns2__OSDConfigurationOptionsExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 684; } /* = unique type id SOAP_TYPE_ns2__OSDConfigurationOptionsExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDConfigurationOptionsExtension() { ns2__OSDConfigurationOptionsExtension::soap_default(NULL); }
	virtual ~ns2__OSDConfigurationOptionsExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__FileProgress
#define SOAP_TYPE_ns2__FileProgress (685)
/* ns2:FileProgress */
class SOAP_CMAC ns2__FileProgress : public xsd__anyType
{
public:
	std::string FileName;	/* required element of type xsd:string */
	float Progress;	/* required element of type xsd:float */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 685; } /* = unique type id SOAP_TYPE_ns2__FileProgress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__FileProgress() { ns2__FileProgress::soap_default(NULL); }
	virtual ~ns2__FileProgress() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfFileProgress
#define SOAP_TYPE_ns2__ArrayOfFileProgress (686)
/* ns2:ArrayOfFileProgress */
class SOAP_CMAC ns2__ArrayOfFileProgress : public xsd__anyType
{
public:
	std::vector<ns2__FileProgress * >FileProgress;	/* optional element of type ns2:FileProgress */
	class ns2__ArrayOfFileProgressExtension *Extension;	/* optional element of type ns2:ArrayOfFileProgressExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 686; } /* = unique type id SOAP_TYPE_ns2__ArrayOfFileProgress */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfFileProgress() { ns2__ArrayOfFileProgress::soap_default(NULL); }
	virtual ~ns2__ArrayOfFileProgress() { }
};
#endif

#ifndef SOAP_TYPE_ns2__ArrayOfFileProgressExtension
#define SOAP_TYPE_ns2__ArrayOfFileProgressExtension (687)
/* ns2:ArrayOfFileProgressExtension */
class SOAP_CMAC ns2__ArrayOfFileProgressExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 687; } /* = unique type id SOAP_TYPE_ns2__ArrayOfFileProgressExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__ArrayOfFileProgressExtension() { ns2__ArrayOfFileProgressExtension::soap_default(NULL); }
	virtual ~ns2__ArrayOfFileProgressExtension() { }
};
#endif

#ifndef SOAP_TYPE_ns2__StorageReferencePath
#define SOAP_TYPE_ns2__StorageReferencePath (688)
/* ns2:StorageReferencePath */
class SOAP_CMAC ns2__StorageReferencePath : public xsd__anyType
{
public:
	std::string StorageToken;	/* required element of type ns2:ReferenceToken */
	std::string *RelativePath;	/* optional element of type xsd:string */
	class ns2__StorageReferencePathExtension *Extension;	/* optional element of type ns2:StorageReferencePathExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 688; } /* = unique type id SOAP_TYPE_ns2__StorageReferencePath */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__StorageReferencePath() { ns2__StorageReferencePath::soap_default(NULL); }
	virtual ~ns2__StorageReferencePath() { }
};
#endif

#ifndef SOAP_TYPE_ns2__StorageReferencePathExtension
#define SOAP_TYPE_ns2__StorageReferencePathExtension (689)
/* ns2:StorageReferencePathExtension */
class SOAP_CMAC ns2__StorageReferencePathExtension : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 689; } /* = unique type id SOAP_TYPE_ns2__StorageReferencePathExtension */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__StorageReferencePathExtension() { ns2__StorageReferencePathExtension::soap_default(NULL); }
	virtual ~ns2__StorageReferencePathExtension() { }
};
#endif

#ifndef SOAP_TYPE__ns2__Message
#define SOAP_TYPE__ns2__Message (690)
/* ns2:Message */
class SOAP_CMAC _ns2__Message
{
public:
	ns2__ItemList *Source;	/* optional element of type ns2:ItemList */
	ns2__ItemList *Key;	/* optional element of type ns2:ItemList */
	ns2__ItemList *Data;	/* optional element of type ns2:ItemList */
	ns2__MessageExtension *Extension;	/* optional element of type ns2:MessageExtension */
	time_t UtcTime;	/* required attribute */
	enum ns2__PropertyOperation *PropertyOperation;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 690; } /* = unique type id SOAP_TYPE__ns2__Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns2__Message() { _ns2__Message::soap_default(NULL); }
	virtual ~_ns2__Message() { }
};
#endif

#ifndef SOAP_TYPE_ns3__QueryExpressionType
#define SOAP_TYPE_ns3__QueryExpressionType (691)
/* ns3:QueryExpressionType */
class SOAP_CMAC ns3__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 691; } /* = unique type id SOAP_TYPE_ns3__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__QueryExpressionType() { ns3__QueryExpressionType::soap_default(NULL); }
	virtual ~ns3__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__TopicExpressionType
#define SOAP_TYPE_ns3__TopicExpressionType (692)
/* ns3:TopicExpressionType */
class SOAP_CMAC ns3__TopicExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 692; } /* = unique type id SOAP_TYPE_ns3__TopicExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__TopicExpressionType() { ns3__TopicExpressionType::soap_default(NULL); }
	virtual ~ns3__TopicExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__FilterType
#define SOAP_TYPE_ns3__FilterType (693)
/* ns3:FilterType */
class SOAP_CMAC ns3__FilterType : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 693; } /* = unique type id SOAP_TYPE_ns3__FilterType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__FilterType() { ns3__FilterType::soap_default(NULL); }
	virtual ~ns3__FilterType() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SubscriptionPolicyType
#define SOAP_TYPE_ns3__SubscriptionPolicyType (694)
/* ns3:SubscriptionPolicyType */
class SOAP_CMAC ns3__SubscriptionPolicyType : public xsd__anyType
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 694; } /* = unique type id SOAP_TYPE_ns3__SubscriptionPolicyType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SubscriptionPolicyType() { ns3__SubscriptionPolicyType::soap_default(NULL); }
	virtual ~ns3__SubscriptionPolicyType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NotificationMessageHolderType_Message
#define SOAP_TYPE__ns3__NotificationMessageHolderType_Message (1471)
/* ns3:NotificationMessageHolderType-Message */
class SOAP_CMAC _ns3__NotificationMessageHolderType_Message
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1471; } /* = unique type id SOAP_TYPE__ns3__NotificationMessageHolderType_Message */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NotificationMessageHolderType_Message() { _ns3__NotificationMessageHolderType_Message::soap_default(NULL); }
	virtual ~_ns3__NotificationMessageHolderType_Message() { }
};
#endif

#ifndef SOAP_TYPE_ns3__NotificationMessageHolderType
#define SOAP_TYPE_ns3__NotificationMessageHolderType (695)
/* ns3:NotificationMessageHolderType */
class SOAP_CMAC ns3__NotificationMessageHolderType : public xsd__anyType
{
public:
	class ns7__EndpointReferenceType *SubscriptionReference;	/* optional element of type ns7:EndpointReferenceType */
	ns3__TopicExpressionType *Topic;	/* optional element of type ns3:TopicExpressionType */
	ns7__EndpointReferenceType *ProducerReference;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__NotificationMessageHolderType_Message Message;	/* required element of type ns3:NotificationMessageHolderType-Message */
public:
	virtual int soap_type() const { return 695; } /* = unique type id SOAP_TYPE_ns3__NotificationMessageHolderType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__NotificationMessageHolderType() { ns3__NotificationMessageHolderType::soap_default(NULL); }
	virtual ~ns3__NotificationMessageHolderType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NotificationProducerRP
#define SOAP_TYPE__ns3__NotificationProducerRP (716)
/* ns3:NotificationProducerRP */
class SOAP_CMAC _ns3__NotificationProducerRP
{
public:
	std::vector<ns3__TopicExpressionType * >TopicExpression;	/* optional element of type ns3:TopicExpressionType */
	bool *FixedTopicSet;	/* optional element of type xsd:boolean */
	std::vector<std::string >TopicExpressionDialect;	/* optional element of type xsd:anyURI */
	class ns6__TopicSetType *ns6__TopicSet;	/* optional element of type ns6:TopicSetType */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 716; } /* = unique type id SOAP_TYPE__ns3__NotificationProducerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NotificationProducerRP() { _ns3__NotificationProducerRP::soap_default(NULL); }
	virtual ~_ns3__NotificationProducerRP() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SubscriptionManagerRP
#define SOAP_TYPE__ns3__SubscriptionManagerRP (717)
/* ns3:SubscriptionManagerRP */
class SOAP_CMAC _ns3__SubscriptionManagerRP
{
public:
	ns7__EndpointReferenceType *ConsumerReference;	/* required element of type ns7:EndpointReferenceType */
	ns3__FilterType *Filter;	/* optional element of type ns3:FilterType */
	ns3__SubscriptionPolicyType *SubscriptionPolicy;	/* optional element of type ns3:SubscriptionPolicyType */
	time_t *CreationTime;	/* optional element of type xsd:dateTime */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 717; } /* = unique type id SOAP_TYPE__ns3__SubscriptionManagerRP */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SubscriptionManagerRP() { _ns3__SubscriptionManagerRP::soap_default(NULL); }
	virtual ~_ns3__SubscriptionManagerRP() { }
};
#endif

#ifndef SOAP_TYPE__ns3__Notify
#define SOAP_TYPE__ns3__Notify (718)
/* ns3:Notify */
class SOAP_CMAC _ns3__Notify
{
public:
	std::vector<ns3__NotificationMessageHolderType * >NotificationMessage;	/* required element of type ns3:NotificationMessageHolderType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 718; } /* = unique type id SOAP_TYPE__ns3__Notify */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__Notify() { _ns3__Notify::soap_default(NULL); }
	virtual ~_ns3__Notify() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UseRaw
#define SOAP_TYPE__ns3__UseRaw (719)
/* ns3:UseRaw */
class SOAP_CMAC _ns3__UseRaw
{
public:
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 719; } /* = unique type id SOAP_TYPE__ns3__UseRaw */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UseRaw() { _ns3__UseRaw::soap_default(NULL); }
	virtual ~_ns3__UseRaw() { }
};
#endif

#ifndef SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy
#define SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy (1477)
/* ns3:Subscribe-SubscriptionPolicy */
class SOAP_CMAC _ns3__Subscribe_SubscriptionPolicy
{
public:
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 1477; } /* = unique type id SOAP_TYPE__ns3__Subscribe_SubscriptionPolicy */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__Subscribe_SubscriptionPolicy() { _ns3__Subscribe_SubscriptionPolicy::soap_default(NULL); }
	virtual ~_ns3__Subscribe_SubscriptionPolicy() { }
};
#endif

#ifndef SOAP_TYPE__ns3__Subscribe
#define SOAP_TYPE__ns3__Subscribe (720)
/* ns3:Subscribe */
class SOAP_CMAC _ns3__Subscribe
{
public:
	ns7__EndpointReferenceType *ConsumerReference;	/* required element of type ns7:EndpointReferenceType */
	ns3__FilterType *Filter;	/* optional element of type ns3:FilterType */
	std::string *InitialTerminationTime;	/* optional element of type ns3:AbsoluteOrRelativeTimeType */
	_ns3__Subscribe_SubscriptionPolicy *SubscriptionPolicy;	/* optional element of type ns3:Subscribe-SubscriptionPolicy */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 720; } /* = unique type id SOAP_TYPE__ns3__Subscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__Subscribe() { _ns3__Subscribe::soap_default(NULL); }
	virtual ~_ns3__Subscribe() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SubscribeResponse
#define SOAP_TYPE__ns3__SubscribeResponse (721)
/* ns3:SubscribeResponse */
class SOAP_CMAC _ns3__SubscribeResponse
{
public:
	ns7__EndpointReferenceType *SubscriptionReference;	/* required element of type ns7:EndpointReferenceType */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	time_t *TerminationTime;	/* optional element of type xsd:dateTime */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 721; } /* = unique type id SOAP_TYPE__ns3__SubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SubscribeResponse() { _ns3__SubscribeResponse::soap_default(NULL); }
	virtual ~_ns3__SubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__GetCurrentMessage
#define SOAP_TYPE__ns3__GetCurrentMessage (722)
/* ns3:GetCurrentMessage */
class SOAP_CMAC _ns3__GetCurrentMessage
{
public:
	ns3__TopicExpressionType *Topic;	/* required element of type ns3:TopicExpressionType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 722; } /* = unique type id SOAP_TYPE__ns3__GetCurrentMessage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__GetCurrentMessage() { _ns3__GetCurrentMessage::soap_default(NULL); }
	virtual ~_ns3__GetCurrentMessage() { }
};
#endif

#ifndef SOAP_TYPE__ns3__GetCurrentMessageResponse
#define SOAP_TYPE__ns3__GetCurrentMessageResponse (723)
/* ns3:GetCurrentMessageResponse */
class SOAP_CMAC _ns3__GetCurrentMessageResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 723; } /* = unique type id SOAP_TYPE__ns3__GetCurrentMessageResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__GetCurrentMessageResponse() { _ns3__GetCurrentMessageResponse::soap_default(NULL); }
	virtual ~_ns3__GetCurrentMessageResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__GetMessages
#define SOAP_TYPE__ns3__GetMessages (724)
/* ns3:GetMessages */
class SOAP_CMAC _ns3__GetMessages
{
public:
	std::string *MaximumNumber;	/* optional element of type xsd:nonNegativeInteger */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 724; } /* = unique type id SOAP_TYPE__ns3__GetMessages */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__GetMessages() { _ns3__GetMessages::soap_default(NULL); }
	virtual ~_ns3__GetMessages() { }
};
#endif

#ifndef SOAP_TYPE__ns3__GetMessagesResponse
#define SOAP_TYPE__ns3__GetMessagesResponse (725)
/* ns3:GetMessagesResponse */
class SOAP_CMAC _ns3__GetMessagesResponse
{
public:
	std::vector<ns3__NotificationMessageHolderType * >NotificationMessage;	/* optional element of type ns3:NotificationMessageHolderType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 725; } /* = unique type id SOAP_TYPE__ns3__GetMessagesResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__GetMessagesResponse() { _ns3__GetMessagesResponse::soap_default(NULL); }
	virtual ~_ns3__GetMessagesResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DestroyPullPoint
#define SOAP_TYPE__ns3__DestroyPullPoint (726)
/* ns3:DestroyPullPoint */
class SOAP_CMAC _ns3__DestroyPullPoint
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 726; } /* = unique type id SOAP_TYPE__ns3__DestroyPullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DestroyPullPoint() { _ns3__DestroyPullPoint::soap_default(NULL); }
	virtual ~_ns3__DestroyPullPoint() { }
};
#endif

#ifndef SOAP_TYPE__ns3__DestroyPullPointResponse
#define SOAP_TYPE__ns3__DestroyPullPointResponse (727)
/* ns3:DestroyPullPointResponse */
class SOAP_CMAC _ns3__DestroyPullPointResponse
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 727; } /* = unique type id SOAP_TYPE__ns3__DestroyPullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__DestroyPullPointResponse() { _ns3__DestroyPullPointResponse::soap_default(NULL); }
	virtual ~_ns3__DestroyPullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__CreatePullPoint
#define SOAP_TYPE__ns3__CreatePullPoint (728)
/* ns3:CreatePullPoint */
class SOAP_CMAC _ns3__CreatePullPoint
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 728; } /* = unique type id SOAP_TYPE__ns3__CreatePullPoint */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__CreatePullPoint() { _ns3__CreatePullPoint::soap_default(NULL); }
	virtual ~_ns3__CreatePullPoint() { }
};
#endif

#ifndef SOAP_TYPE__ns3__CreatePullPointResponse
#define SOAP_TYPE__ns3__CreatePullPointResponse (729)
/* ns3:CreatePullPointResponse */
class SOAP_CMAC _ns3__CreatePullPointResponse
{
public:
	ns7__EndpointReferenceType *PullPoint;	/* required element of type ns7:EndpointReferenceType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 729; } /* = unique type id SOAP_TYPE__ns3__CreatePullPointResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__CreatePullPointResponse() { _ns3__CreatePullPointResponse::soap_default(NULL); }
	virtual ~_ns3__CreatePullPointResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__Renew
#define SOAP_TYPE__ns3__Renew (730)
/* ns3:Renew */
class SOAP_CMAC _ns3__Renew
{
public:
	std::string *TerminationTime;	/* required element of type ns3:AbsoluteOrRelativeTimeType */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 730; } /* = unique type id SOAP_TYPE__ns3__Renew */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__Renew() { _ns3__Renew::soap_default(NULL); }
	virtual ~_ns3__Renew() { }
};
#endif

#ifndef SOAP_TYPE__ns3__RenewResponse
#define SOAP_TYPE__ns3__RenewResponse (731)
/* ns3:RenewResponse */
class SOAP_CMAC _ns3__RenewResponse
{
public:
	time_t TerminationTime;	/* required element of type xsd:dateTime */
	time_t *CurrentTime;	/* optional element of type xsd:dateTime */
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 731; } /* = unique type id SOAP_TYPE__ns3__RenewResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__RenewResponse() { _ns3__RenewResponse::soap_default(NULL); }
	virtual ~_ns3__RenewResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__Unsubscribe
#define SOAP_TYPE__ns3__Unsubscribe (732)
/* ns3:Unsubscribe */
class SOAP_CMAC _ns3__Unsubscribe
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 732; } /* = unique type id SOAP_TYPE__ns3__Unsubscribe */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__Unsubscribe() { _ns3__Unsubscribe::soap_default(NULL); }
	virtual ~_ns3__Unsubscribe() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnsubscribeResponse
#define SOAP_TYPE__ns3__UnsubscribeResponse (733)
/* ns3:UnsubscribeResponse */
class SOAP_CMAC _ns3__UnsubscribeResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 733; } /* = unique type id SOAP_TYPE__ns3__UnsubscribeResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnsubscribeResponse() { _ns3__UnsubscribeResponse::soap_default(NULL); }
	virtual ~_ns3__UnsubscribeResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__PauseSubscription
#define SOAP_TYPE__ns3__PauseSubscription (734)
/* ns3:PauseSubscription */
class SOAP_CMAC _ns3__PauseSubscription
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 734; } /* = unique type id SOAP_TYPE__ns3__PauseSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__PauseSubscription() { _ns3__PauseSubscription::soap_default(NULL); }
	virtual ~_ns3__PauseSubscription() { }
};
#endif

#ifndef SOAP_TYPE__ns3__PauseSubscriptionResponse
#define SOAP_TYPE__ns3__PauseSubscriptionResponse (735)
/* ns3:PauseSubscriptionResponse */
class SOAP_CMAC _ns3__PauseSubscriptionResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 735; } /* = unique type id SOAP_TYPE__ns3__PauseSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__PauseSubscriptionResponse() { _ns3__PauseSubscriptionResponse::soap_default(NULL); }
	virtual ~_ns3__PauseSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ResumeSubscription
#define SOAP_TYPE__ns3__ResumeSubscription (736)
/* ns3:ResumeSubscription */
class SOAP_CMAC _ns3__ResumeSubscription
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 736; } /* = unique type id SOAP_TYPE__ns3__ResumeSubscription */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ResumeSubscription() { _ns3__ResumeSubscription::soap_default(NULL); }
	virtual ~_ns3__ResumeSubscription() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ResumeSubscriptionResponse
#define SOAP_TYPE__ns3__ResumeSubscriptionResponse (737)
/* ns3:ResumeSubscriptionResponse */
class SOAP_CMAC _ns3__ResumeSubscriptionResponse
{
public:
	std::vector<char * >__any;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 737; } /* = unique type id SOAP_TYPE__ns3__ResumeSubscriptionResponse */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ResumeSubscriptionResponse() { _ns3__ResumeSubscriptionResponse::soap_default(NULL); }
	virtual ~_ns3__ResumeSubscriptionResponse() { }
};
#endif

#ifndef SOAP_TYPE_ns4__Include
#define SOAP_TYPE_ns4__Include (738)
/* ns4:Include */
class SOAP_CMAC ns4__Include : public xsd__anyType
{
public:
	std::vector<char * >__any;
	std::string href;	/* required attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 738; } /* = unique type id SOAP_TYPE_ns4__Include */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns4__Include() { ns4__Include::soap_default(NULL); }
	virtual ~ns4__Include() { }
};
#endif

#ifndef SOAP_TYPE__ns5__BaseFaultType_ErrorCode
#define SOAP_TYPE__ns5__BaseFaultType_ErrorCode (1480)
/* ns5:BaseFaultType-ErrorCode */
class SOAP_CMAC _ns5__BaseFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1480; } /* = unique type id SOAP_TYPE__ns5__BaseFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__BaseFaultType_ErrorCode() { _ns5__BaseFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns5__BaseFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns5__BaseFaultType_Description
#define SOAP_TYPE__ns5__BaseFaultType_Description (1482)
/* Primitive ns5:BaseFaultType-Description schema type: */
class SOAP_CMAC _ns5__BaseFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1482; } /* = unique type id SOAP_TYPE__ns5__BaseFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__BaseFaultType_Description() { _ns5__BaseFaultType_Description::soap_default(NULL); }
	virtual ~_ns5__BaseFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns5__BaseFaultType_FaultCause
#define SOAP_TYPE__ns5__BaseFaultType_FaultCause (1486)
/* ns5:BaseFaultType-FaultCause */
class SOAP_CMAC _ns5__BaseFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1486; } /* = unique type id SOAP_TYPE__ns5__BaseFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns5__BaseFaultType_FaultCause() { _ns5__BaseFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns5__BaseFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns5__BaseFaultType
#define SOAP_TYPE_ns5__BaseFaultType (739)
/* ns5:BaseFaultType */
class SOAP_CMAC ns5__BaseFaultType : public xsd__anyType
{
public:
	std::vector<char * >__any;
	time_t Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns5__BaseFaultType_ErrorCode *ErrorCode;	/* optional element of type ns5:BaseFaultType-ErrorCode */
	std::vector<_ns5__BaseFaultType_Description >*Description;	/* optional element of type ns5:BaseFaultType-Description */
	_ns5__BaseFaultType_FaultCause *FaultCause;	/* optional element of type ns5:BaseFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 739; } /* = unique type id SOAP_TYPE_ns5__BaseFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns5__BaseFaultType() { ns5__BaseFaultType::soap_default(NULL); }
	virtual ~ns5__BaseFaultType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__Documentation
#define SOAP_TYPE_ns6__Documentation (740)
/* ns6:Documentation */
class SOAP_CMAC ns6__Documentation : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__mixed;
public:
	virtual int soap_type() const { return 740; } /* = unique type id SOAP_TYPE_ns6__Documentation */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__Documentation() { ns6__Documentation::soap_default(NULL); }
	virtual ~ns6__Documentation() { }
};
#endif

#ifndef SOAP_TYPE_ns6__ExtensibleDocumented
#define SOAP_TYPE_ns6__ExtensibleDocumented (741)
/* ns6:ExtensibleDocumented */
class SOAP_CMAC ns6__ExtensibleDocumented : public xsd__anyType
{
public:
	ns6__Documentation *documentation;	/* optional element of type ns6:Documentation */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 741; } /* = unique type id SOAP_TYPE_ns6__ExtensibleDocumented */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__ExtensibleDocumented() { ns6__ExtensibleDocumented::soap_default(NULL); }
	virtual ~ns6__ExtensibleDocumented() { }
};
#endif

#ifndef SOAP_TYPE_ns6__QueryExpressionType
#define SOAP_TYPE_ns6__QueryExpressionType (742)
/* ns6:QueryExpressionType */
class SOAP_CMAC ns6__QueryExpressionType : public xsd__anyType
{
public:
	char *__any;
	std::string Dialect;	/* required attribute */
	char *__mixed;
public:
	virtual int soap_type() const { return 742; } /* = unique type id SOAP_TYPE_ns6__QueryExpressionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__QueryExpressionType() { ns6__QueryExpressionType::soap_default(NULL); }
	virtual ~ns6__QueryExpressionType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__EndpointReferenceType
#define SOAP_TYPE_ns7__EndpointReferenceType (746)
/* ns7:EndpointReferenceType */
class SOAP_CMAC ns7__EndpointReferenceType : public xsd__anyType
{
public:
	class ns7__AttributedURIType *Address;	/* required element of type ns7:AttributedURIType */
	class ns7__ReferenceParametersType *ReferenceParameters;	/* optional element of type ns7:ReferenceParametersType */
	class ns7__MetadataType *Metadata;	/* optional element of type ns7:MetadataType */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 746; } /* = unique type id SOAP_TYPE_ns7__EndpointReferenceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__EndpointReferenceType() { ns7__EndpointReferenceType::soap_default(NULL); }
	virtual ~ns7__EndpointReferenceType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__ReferenceParametersType
#define SOAP_TYPE_ns7__ReferenceParametersType (747)
/* ns7:ReferenceParametersType */
class SOAP_CMAC ns7__ReferenceParametersType : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 747; } /* = unique type id SOAP_TYPE_ns7__ReferenceParametersType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__ReferenceParametersType() { ns7__ReferenceParametersType::soap_default(NULL); }
	virtual ~ns7__ReferenceParametersType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__MetadataType
#define SOAP_TYPE_ns7__MetadataType (748)
/* ns7:MetadataType */
class SOAP_CMAC ns7__MetadataType : public xsd__anyType
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 748; } /* = unique type id SOAP_TYPE_ns7__MetadataType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__MetadataType() { ns7__MetadataType::soap_default(NULL); }
	virtual ~ns7__MetadataType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__ProblemActionType
#define SOAP_TYPE_ns7__ProblemActionType (753)
/* ns7:ProblemActionType */
class SOAP_CMAC ns7__ProblemActionType : public xsd__anyType
{
public:
	ns7__AttributedURIType *Action;	/* optional element of type ns7:AttributedURIType */
	std::string *SoapAction;	/* optional element of type xsd:anyURI */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 753; } /* = unique type id SOAP_TYPE_ns7__ProblemActionType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__ProblemActionType() { ns7__ProblemActionType::soap_default(NULL); }
	virtual ~ns7__ProblemActionType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSource
#define SOAP_TYPE_ns2__VideoSource (219)
/* ns2:VideoSource */
class SOAP_CMAC ns2__VideoSource
{
public:
	std::string token;	/* required attribute */
	float Framerate;	/* required element of type xsd:float */
	ns2__VideoResolution *Resolution;	/* required element of type ns2:VideoResolution */
	ns2__ImagingSettings *Imaging;	/* optional element of type ns2:ImagingSettings */
	ns2__VideoSourceExtension *Extension;	/* optional element of type ns2:VideoSourceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 219; } /* = unique type id SOAP_TYPE_ns2__VideoSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSource() { ns2__VideoSource::soap_default(NULL); }
	virtual ~ns2__VideoSource() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioSource
#define SOAP_TYPE_ns2__AudioSource (222)
/* ns2:AudioSource */
class SOAP_CMAC ns2__AudioSource
{
public:
	std::string token;	/* required attribute */
	int Channels;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 222; } /* = unique type id SOAP_TYPE_ns2__AudioSource */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioSource() { ns2__AudioSource::soap_default(NULL); }
	virtual ~ns2__AudioSource() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoSourceConfiguration
#define SOAP_TYPE_ns2__VideoSourceConfiguration (227)
/* ns2:VideoSourceConfiguration */
class SOAP_CMAC ns2__VideoSourceConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	std::string SourceToken;	/* required element of type ns2:ReferenceToken */
	ns2__IntRectangle *Bounds;	/* required element of type ns2:IntRectangle */
	std::vector<char * >__any;
	ns2__VideoSourceConfigurationExtension *Extension;	/* optional element of type ns2:VideoSourceConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 227; } /* = unique type id SOAP_TYPE_ns2__VideoSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoSourceConfiguration() { ns2__VideoSourceConfiguration::soap_default(NULL); }
	virtual ~ns2__VideoSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoEncoderConfiguration
#define SOAP_TYPE_ns2__VideoEncoderConfiguration (237)
/* ns2:VideoEncoderConfiguration */
class SOAP_CMAC ns2__VideoEncoderConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	enum ns2__VideoEncoding Encoding;	/* required element of type ns2:VideoEncoding */
	ns2__VideoResolution *Resolution;	/* required element of type ns2:VideoResolution */
	float Quality;	/* required element of type xsd:float */
	ns2__VideoRateControl *RateControl;	/* optional element of type ns2:VideoRateControl */
	ns2__Mpeg4Configuration *MPEG4;	/* optional element of type ns2:Mpeg4Configuration */
	ns2__H264Configuration *H264;	/* optional element of type ns2:H264Configuration */
	ns2__MulticastConfiguration *Multicast;	/* required element of type ns2:MulticastConfiguration */
	std::string SessionTimeout;	/* required element of type xsd:duration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 237; } /* = unique type id SOAP_TYPE_ns2__VideoEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoEncoderConfiguration() { ns2__VideoEncoderConfiguration::soap_default(NULL); }
	virtual ~ns2__VideoEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__JpegOptions2
#define SOAP_TYPE_ns2__JpegOptions2 (246)
/* ns2:JpegOptions2 */
class SOAP_CMAC ns2__JpegOptions2
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	ns2__IntRange *FrameRateRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *EncodingIntervalRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *BitrateRange;	/* required element of type ns2:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 246; } /* = unique type id SOAP_TYPE_ns2__JpegOptions2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__JpegOptions2() { ns2__JpegOptions2::soap_default(NULL); }
	virtual ~ns2__JpegOptions2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Mpeg4Options2
#define SOAP_TYPE_ns2__Mpeg4Options2 (248)
/* ns2:Mpeg4Options2 */
class SOAP_CMAC ns2__Mpeg4Options2
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	ns2__IntRange *GovLengthRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *FrameRateRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *EncodingIntervalRange;	/* required element of type ns2:IntRange */
	std::vector<enum ns2__Mpeg4Profile >Mpeg4ProfilesSupported;	/* required element of type ns2:Mpeg4Profile */
	ns2__IntRange *BitrateRange;	/* required element of type ns2:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 248; } /* = unique type id SOAP_TYPE_ns2__Mpeg4Options2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Mpeg4Options2() { ns2__Mpeg4Options2::soap_default(NULL); }
	virtual ~ns2__Mpeg4Options2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__H264Options2
#define SOAP_TYPE_ns2__H264Options2 (250)
/* ns2:H264Options2 */
class SOAP_CMAC ns2__H264Options2
{
public:
	std::vector<ns2__VideoResolution * >ResolutionsAvailable;	/* required element of type ns2:VideoResolution */
	ns2__IntRange *GovLengthRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *FrameRateRange;	/* required element of type ns2:IntRange */
	ns2__IntRange *EncodingIntervalRange;	/* required element of type ns2:IntRange */
	std::vector<enum ns2__H264Profile >H264ProfilesSupported;	/* required element of type ns2:H264Profile */
	ns2__IntRange *BitrateRange;	/* required element of type ns2:IntRange */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 250; } /* = unique type id SOAP_TYPE_ns2__H264Options2 */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__H264Options2() { ns2__H264Options2::soap_default(NULL); }
	virtual ~ns2__H264Options2() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioSourceConfiguration
#define SOAP_TYPE_ns2__AudioSourceConfiguration (251)
/* ns2:AudioSourceConfiguration */
class SOAP_CMAC ns2__AudioSourceConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	std::string SourceToken;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 251; } /* = unique type id SOAP_TYPE_ns2__AudioSourceConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioSourceConfiguration() { ns2__AudioSourceConfiguration::soap_default(NULL); }
	virtual ~ns2__AudioSourceConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioEncoderConfiguration
#define SOAP_TYPE_ns2__AudioEncoderConfiguration (254)
/* ns2:AudioEncoderConfiguration */
class SOAP_CMAC ns2__AudioEncoderConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	enum ns2__AudioEncoding Encoding;	/* required element of type ns2:AudioEncoding */
	int Bitrate;	/* required element of type xsd:int */
	int SampleRate;	/* required element of type xsd:int */
	ns2__MulticastConfiguration *Multicast;	/* required element of type ns2:MulticastConfiguration */
	std::string SessionTimeout;	/* required element of type xsd:duration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 254; } /* = unique type id SOAP_TYPE_ns2__AudioEncoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioEncoderConfiguration() { ns2__AudioEncoderConfiguration::soap_default(NULL); }
	virtual ~ns2__AudioEncoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoAnalyticsConfiguration
#define SOAP_TYPE_ns2__VideoAnalyticsConfiguration (257)
/* ns2:VideoAnalyticsConfiguration */
class SOAP_CMAC ns2__VideoAnalyticsConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	ns2__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of type ns2:AnalyticsEngineConfiguration */
	ns2__RuleEngineConfiguration *RuleEngineConfiguration;	/* required element of type ns2:RuleEngineConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 257; } /* = unique type id SOAP_TYPE_ns2__VideoAnalyticsConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoAnalyticsConfiguration() { ns2__VideoAnalyticsConfiguration::soap_default(NULL); }
	virtual ~ns2__VideoAnalyticsConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__MetadataConfiguration
#define SOAP_TYPE_ns2__MetadataConfiguration (258)
/* ns2:MetadataConfiguration */
class SOAP_CMAC ns2__MetadataConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	ns2__PTZFilter *PTZStatus;	/* optional element of type ns2:PTZFilter */
	ns2__EventSubscription *Events;	/* optional element of type ns2:EventSubscription */
	bool *Analytics;	/* optional element of type xsd:boolean */
	ns2__MulticastConfiguration *Multicast;	/* required element of type ns2:MulticastConfiguration */
	std::string SessionTimeout;	/* required element of type xsd:duration */
	std::vector<char * >__any;
	ns2__AnalyticsEngineConfiguration *AnalyticsEngineConfiguration;	/* optional element of type ns2:AnalyticsEngineConfiguration */
	ns2__MetadataConfigurationExtension *Extension;	/* optional element of type ns2:MetadataConfigurationExtension */
	std::string *CompressionType;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 258; } /* = unique type id SOAP_TYPE_ns2__MetadataConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__MetadataConfiguration() { ns2__MetadataConfiguration::soap_default(NULL); }
	virtual ~ns2__MetadataConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoOutput
#define SOAP_TYPE_ns2__VideoOutput (267)
/* ns2:VideoOutput */
class SOAP_CMAC ns2__VideoOutput
{
public:
	std::string token;	/* required attribute */
	ns2__Layout *Layout;	/* required element of type ns2:Layout */
	ns2__VideoResolution *Resolution;	/* optional element of type ns2:VideoResolution */
	float *RefreshRate;	/* optional element of type xsd:float */
	float *AspectRatio;	/* optional element of type xsd:float */
	ns2__VideoOutputExtension *Extension;	/* optional element of type ns2:VideoOutputExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 267; } /* = unique type id SOAP_TYPE_ns2__VideoOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoOutput() { ns2__VideoOutput::soap_default(NULL); }
	virtual ~ns2__VideoOutput() { }
};
#endif

#ifndef SOAP_TYPE_ns2__VideoOutputConfiguration
#define SOAP_TYPE_ns2__VideoOutputConfiguration (269)
/* ns2:VideoOutputConfiguration */
class SOAP_CMAC ns2__VideoOutputConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	std::string OutputToken;	/* required element of type ns2:ReferenceToken */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 269; } /* = unique type id SOAP_TYPE_ns2__VideoOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__VideoOutputConfiguration() { ns2__VideoOutputConfiguration::soap_default(NULL); }
	virtual ~ns2__VideoOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioOutput
#define SOAP_TYPE_ns2__AudioOutput (276)
/* ns2:AudioOutput */
class SOAP_CMAC ns2__AudioOutput
{
public:
	std::string token;	/* required attribute */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 276; } /* = unique type id SOAP_TYPE_ns2__AudioOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioOutput() { ns2__AudioOutput::soap_default(NULL); }
	virtual ~ns2__AudioOutput() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioOutputConfiguration
#define SOAP_TYPE_ns2__AudioOutputConfiguration (277)
/* ns2:AudioOutputConfiguration */
class SOAP_CMAC ns2__AudioOutputConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	std::string OutputToken;	/* required element of type ns2:ReferenceToken */
	std::string *SendPrimacy;	/* optional element of type xsd:anyURI */
	int OutputLevel;	/* required element of type xsd:int */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 277; } /* = unique type id SOAP_TYPE_ns2__AudioOutputConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioOutputConfiguration() { ns2__AudioOutputConfiguration::soap_default(NULL); }
	virtual ~ns2__AudioOutputConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AudioDecoderConfiguration
#define SOAP_TYPE_ns2__AudioDecoderConfiguration (279)
/* ns2:AudioDecoderConfiguration */
class SOAP_CMAC ns2__AudioDecoderConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 279; } /* = unique type id SOAP_TYPE_ns2__AudioDecoderConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AudioDecoderConfiguration() { ns2__AudioDecoderConfiguration::soap_default(NULL); }
	virtual ~ns2__AudioDecoderConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterface
#define SOAP_TYPE_ns2__NetworkInterface (290)
/* ns2:NetworkInterface */
class SOAP_CMAC ns2__NetworkInterface
{
public:
	std::string token;	/* required attribute */
	bool Enabled;	/* required element of type xsd:boolean */
	ns2__NetworkInterfaceInfo *Info;	/* optional element of type ns2:NetworkInterfaceInfo */
	ns2__NetworkInterfaceLink *Link;	/* optional element of type ns2:NetworkInterfaceLink */
	ns2__IPv4NetworkInterface *IPv4;	/* optional element of type ns2:IPv4NetworkInterface */
	ns2__IPv6NetworkInterface *IPv6;	/* optional element of type ns2:IPv6NetworkInterface */
	ns2__NetworkInterfaceExtension *Extension;	/* optional element of type ns2:NetworkInterfaceExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 290; } /* = unique type id SOAP_TYPE_ns2__NetworkInterface */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__NetworkInterface() { ns2__NetworkInterface::soap_default(NULL); }
	virtual ~ns2__NetworkInterface() { }
};
#endif

#ifndef SOAP_TYPE_ns2__CertificateUsage
#define SOAP_TYPE_ns2__CertificateUsage (394)
/* Primitive ns2:CertificateUsage schema type: */
class SOAP_CMAC ns2__CertificateUsage : public xsd__anyType
{
public:
	std::string __item;
	bool Critical;	/* required attribute */
public:
	virtual int soap_type() const { return 394; } /* = unique type id SOAP_TYPE_ns2__CertificateUsage */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__CertificateUsage() { ns2__CertificateUsage::soap_default(NULL); }
	virtual ~ns2__CertificateUsage() { }
};
#endif

#ifndef SOAP_TYPE_ns2__RelayOutput
#define SOAP_TYPE_ns2__RelayOutput (403)
/* ns2:RelayOutput */
class SOAP_CMAC ns2__RelayOutput
{
public:
	std::string token;	/* required attribute */
	ns2__RelayOutputSettings *Properties;	/* required element of type ns2:RelayOutputSettings */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 403; } /* = unique type id SOAP_TYPE_ns2__RelayOutput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__RelayOutput() { ns2__RelayOutput::soap_default(NULL); }
	virtual ~ns2__RelayOutput() { }
};
#endif

#ifndef SOAP_TYPE_ns2__DigitalInput
#define SOAP_TYPE_ns2__DigitalInput (404)
/* ns2:DigitalInput */
class SOAP_CMAC ns2__DigitalInput
{
public:
	std::string token;	/* required attribute */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 404; } /* = unique type id SOAP_TYPE_ns2__DigitalInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__DigitalInput() { ns2__DigitalInput::soap_default(NULL); }
	virtual ~ns2__DigitalInput() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZNode
#define SOAP_TYPE_ns2__PTZNode (405)
/* ns2:PTZNode */
class SOAP_CMAC ns2__PTZNode
{
public:
	std::string token;	/* required attribute */
	std::string *Name;	/* optional element of type ns2:Name */
	ns2__PTZSpaces *SupportedPTZSpaces;	/* required element of type ns2:PTZSpaces */
	int MaximumNumberOfPresets;	/* required element of type xsd:int */
	bool HomeSupported;	/* required element of type xsd:boolean */
	std::vector<std::string >AuxiliaryCommands;	/* optional element of type ns2:AuxiliaryData */
	ns2__PTZNodeExtension *Extension;	/* optional element of type ns2:PTZNodeExtension */
	bool *FixedHomePosition;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 405; } /* = unique type id SOAP_TYPE_ns2__PTZNode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZNode() { ns2__PTZNode::soap_default(NULL); }
	virtual ~ns2__PTZNode() { }
};
#endif

#ifndef SOAP_TYPE_ns2__PTZConfiguration
#define SOAP_TYPE_ns2__PTZConfiguration (410)
/* ns2:PTZConfiguration */
class SOAP_CMAC ns2__PTZConfiguration
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	std::string NodeToken;	/* required element of type ns2:ReferenceToken */
	std::string *DefaultAbsolutePantTiltPositionSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultAbsoluteZoomPositionSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultRelativePanTiltTranslationSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultRelativeZoomTranslationSpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultContinuousPanTiltVelocitySpace;	/* optional element of type xsd:anyURI */
	std::string *DefaultContinuousZoomVelocitySpace;	/* optional element of type xsd:anyURI */
	ns2__PTZSpeed *DefaultPTZSpeed;	/* optional element of type ns2:PTZSpeed */
	std::string *DefaultPTZTimeout;	/* optional element of type xsd:duration */
	ns2__PanTiltLimits *PanTiltLimits;	/* optional element of type ns2:PanTiltLimits */
	ns2__ZoomLimits *ZoomLimits;	/* optional element of type ns2:ZoomLimits */
	ns2__PTZConfigurationExtension *Extension;	/* optional element of type ns2:PTZConfigurationExtension */
	int *MoveRamp;	/* optional attribute */
	int *PresetRamp;	/* optional attribute */
	int *PresetTourRamp;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 410; } /* = unique type id SOAP_TYPE_ns2__PTZConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__PTZConfiguration() { ns2__PTZConfiguration::soap_default(NULL); }
	virtual ~ns2__PTZConfiguration() { }
};
#endif

#ifndef SOAP_TYPE_ns2__Object
#define SOAP_TYPE_ns2__Object (546)
/* ns2:Object */
class SOAP_CMAC ns2__Object
{
public:
	std::string *ObjectId;	/* optional attribute */
	ns2__Appearance *Appearance;	/* optional element of type ns2:Appearance */
	ns2__Behaviour *Behaviour;	/* optional element of type ns2:Behaviour */
	ns2__ObjectExtension *Extension;	/* optional element of type ns2:ObjectExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 546; } /* = unique type id SOAP_TYPE_ns2__Object */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__Object() { ns2__Object::soap_default(NULL); }
	virtual ~ns2__Object() { }
};
#endif

#ifndef SOAP_TYPE_ns2__EventFilter
#define SOAP_TYPE_ns2__EventFilter (609)
/* ns2:EventFilter */
class SOAP_CMAC ns2__EventFilter
{
public:
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 609; } /* = unique type id SOAP_TYPE_ns2__EventFilter */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__EventFilter() { ns2__EventFilter::soap_default(NULL); }
	virtual ~ns2__EventFilter() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsEngine
#define SOAP_TYPE_ns2__AnalyticsEngine (645)
/* ns2:AnalyticsEngine */
class SOAP_CMAC ns2__AnalyticsEngine
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	ns2__AnalyticsDeviceEngineConfiguration *AnalyticsEngineConfiguration;	/* required element of type ns2:AnalyticsDeviceEngineConfiguration */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 645; } /* = unique type id SOAP_TYPE_ns2__AnalyticsEngine */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsEngine() { ns2__AnalyticsEngine::soap_default(NULL); }
	virtual ~ns2__AnalyticsEngine() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsEngineInput
#define SOAP_TYPE_ns2__AnalyticsEngineInput (651)
/* ns2:AnalyticsEngineInput */
class SOAP_CMAC ns2__AnalyticsEngineInput
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	ns2__SourceIdentification *SourceIdentification;	/* required element of type ns2:SourceIdentification */
	ns2__VideoEncoderConfiguration *VideoInput;	/* required element of type ns2:VideoEncoderConfiguration */
	ns2__MetadataInput *MetadataInput;	/* required element of type ns2:MetadataInput */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 651; } /* = unique type id SOAP_TYPE_ns2__AnalyticsEngineInput */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsEngineInput() { ns2__AnalyticsEngineInput::soap_default(NULL); }
	virtual ~ns2__AnalyticsEngineInput() { }
};
#endif

#ifndef SOAP_TYPE_ns2__AnalyticsEngineControl
#define SOAP_TYPE_ns2__AnalyticsEngineControl (656)
/* ns2:AnalyticsEngineControl */
class SOAP_CMAC ns2__AnalyticsEngineControl
{
public:
	std::string Name;	/* required element of type ns2:Name */
	int UseCount;	/* required element of type xsd:int */
	std::string token;	/* required attribute */
	std::string EngineToken;	/* required element of type ns2:ReferenceToken */
	std::string EngineConfigToken;	/* required element of type ns2:ReferenceToken */
	std::vector<std::string >InputToken;	/* required element of type ns2:ReferenceToken */
	std::vector<std::string >ReceiverToken;	/* required element of type ns2:ReferenceToken */
	ns2__MulticastConfiguration *Multicast;	/* optional element of type ns2:MulticastConfiguration */
	ns2__Config *Subscription;	/* required element of type ns2:Config */
	enum ns2__ModeOfOperation Mode;	/* required element of type ns2:ModeOfOperation */
	std::vector<char * >__any;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 656; } /* = unique type id SOAP_TYPE_ns2__AnalyticsEngineControl */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__AnalyticsEngineControl() { ns2__AnalyticsEngineControl::soap_default(NULL); }
	virtual ~ns2__AnalyticsEngineControl() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDConfiguration
#define SOAP_TYPE_ns2__OSDConfiguration (680)
/* ns2:OSDConfiguration */
class SOAP_CMAC ns2__OSDConfiguration
{
public:
	std::string token;	/* required attribute */
	class ns2__OSDReference *VideoSourceConfigurationToken;	/* required element of type ns2:OSDReference */
	enum ns2__OSDType Type;	/* required element of type ns2:OSDType */
	ns2__OSDPosConfiguration *Position;	/* required element of type ns2:OSDPosConfiguration */
	ns2__OSDTextConfiguration *TextString;	/* optional element of type ns2:OSDTextConfiguration */
	ns2__OSDImgConfiguration *Image;	/* optional element of type ns2:OSDImgConfiguration */
	ns2__OSDConfigurationExtension *Extension;	/* optional element of type ns2:OSDConfigurationExtension */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 680; } /* = unique type id SOAP_TYPE_ns2__OSDConfiguration */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDConfiguration() { ns2__OSDConfiguration::soap_default(NULL); }
	virtual ~ns2__OSDConfiguration() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_ErrorCode
#define SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_ErrorCode (1528)
/* ns3:SubscribeCreationFailedFaultType-ErrorCode */
class SOAP_CMAC _ns3__SubscribeCreationFailedFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1528; } /* = unique type id SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SubscribeCreationFailedFaultType_ErrorCode() { _ns3__SubscribeCreationFailedFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__SubscribeCreationFailedFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_Description
#define SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_Description (1530)
/* Primitive ns3:SubscribeCreationFailedFaultType-Description schema type: */
class SOAP_CMAC _ns3__SubscribeCreationFailedFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1530; } /* = unique type id SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SubscribeCreationFailedFaultType_Description() { _ns3__SubscribeCreationFailedFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__SubscribeCreationFailedFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_FaultCause
#define SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_FaultCause (1533)
/* ns3:SubscribeCreationFailedFaultType-FaultCause */
class SOAP_CMAC _ns3__SubscribeCreationFailedFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1533; } /* = unique type id SOAP_TYPE__ns3__SubscribeCreationFailedFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__SubscribeCreationFailedFaultType_FaultCause() { _ns3__SubscribeCreationFailedFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__SubscribeCreationFailedFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__SubscribeCreationFailedFaultType
#define SOAP_TYPE_ns3__SubscribeCreationFailedFaultType (696)
/* ns3:SubscribeCreationFailedFaultType */
class SOAP_CMAC ns3__SubscribeCreationFailedFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__SubscribeCreationFailedFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:SubscribeCreationFailedFaultType-ErrorCode */
	std::vector<_ns3__SubscribeCreationFailedFaultType_Description >*ns5__Description;	/* optional element of type ns3:SubscribeCreationFailedFaultType-Description */
	_ns3__SubscribeCreationFailedFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:SubscribeCreationFailedFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 696; } /* = unique type id SOAP_TYPE_ns3__SubscribeCreationFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__SubscribeCreationFailedFaultType() { ns3__SubscribeCreationFailedFaultType::soap_default(NULL); }
	virtual ~ns3__SubscribeCreationFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidFilterFaultType_ErrorCode
#define SOAP_TYPE__ns3__InvalidFilterFaultType_ErrorCode (1535)
/* ns3:InvalidFilterFaultType-ErrorCode */
class SOAP_CMAC _ns3__InvalidFilterFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1535; } /* = unique type id SOAP_TYPE__ns3__InvalidFilterFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidFilterFaultType_ErrorCode() { _ns3__InvalidFilterFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__InvalidFilterFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidFilterFaultType_Description
#define SOAP_TYPE__ns3__InvalidFilterFaultType_Description (1537)
/* Primitive ns3:InvalidFilterFaultType-Description schema type: */
class SOAP_CMAC _ns3__InvalidFilterFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1537; } /* = unique type id SOAP_TYPE__ns3__InvalidFilterFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidFilterFaultType_Description() { _ns3__InvalidFilterFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__InvalidFilterFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidFilterFaultType_FaultCause
#define SOAP_TYPE__ns3__InvalidFilterFaultType_FaultCause (1540)
/* ns3:InvalidFilterFaultType-FaultCause */
class SOAP_CMAC _ns3__InvalidFilterFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1540; } /* = unique type id SOAP_TYPE__ns3__InvalidFilterFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidFilterFaultType_FaultCause() { _ns3__InvalidFilterFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__InvalidFilterFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__InvalidFilterFaultType
#define SOAP_TYPE_ns3__InvalidFilterFaultType (697)
/* ns3:InvalidFilterFaultType */
class SOAP_CMAC ns3__InvalidFilterFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__InvalidFilterFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:InvalidFilterFaultType-ErrorCode */
	std::vector<_ns3__InvalidFilterFaultType_Description >*ns5__Description;	/* optional element of type ns3:InvalidFilterFaultType-Description */
	_ns3__InvalidFilterFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:InvalidFilterFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
	std::vector<std::string >UnknownFilter;	/* required element of type xsd:QName */
public:
	virtual int soap_type() const { return 697; } /* = unique type id SOAP_TYPE_ns3__InvalidFilterFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__InvalidFilterFaultType() { ns3__InvalidFilterFaultType::soap_default(NULL); }
	virtual ~ns3__InvalidFilterFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_ErrorCode
#define SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_ErrorCode (1543)
/* ns3:TopicExpressionDialectUnknownFaultType-ErrorCode */
class SOAP_CMAC _ns3__TopicExpressionDialectUnknownFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1543; } /* = unique type id SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__TopicExpressionDialectUnknownFaultType_ErrorCode() { _ns3__TopicExpressionDialectUnknownFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__TopicExpressionDialectUnknownFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_Description
#define SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_Description (1545)
/* Primitive ns3:TopicExpressionDialectUnknownFaultType-Description schema type: */
class SOAP_CMAC _ns3__TopicExpressionDialectUnknownFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1545; } /* = unique type id SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__TopicExpressionDialectUnknownFaultType_Description() { _ns3__TopicExpressionDialectUnknownFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__TopicExpressionDialectUnknownFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_FaultCause
#define SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_FaultCause (1548)
/* ns3:TopicExpressionDialectUnknownFaultType-FaultCause */
class SOAP_CMAC _ns3__TopicExpressionDialectUnknownFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1548; } /* = unique type id SOAP_TYPE__ns3__TopicExpressionDialectUnknownFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__TopicExpressionDialectUnknownFaultType_FaultCause() { _ns3__TopicExpressionDialectUnknownFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__TopicExpressionDialectUnknownFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType
#define SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType (698)
/* ns3:TopicExpressionDialectUnknownFaultType */
class SOAP_CMAC ns3__TopicExpressionDialectUnknownFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__TopicExpressionDialectUnknownFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:TopicExpressionDialectUnknownFaultType-ErrorCode */
	std::vector<_ns3__TopicExpressionDialectUnknownFaultType_Description >*ns5__Description;	/* optional element of type ns3:TopicExpressionDialectUnknownFaultType-Description */
	_ns3__TopicExpressionDialectUnknownFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:TopicExpressionDialectUnknownFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 698; } /* = unique type id SOAP_TYPE_ns3__TopicExpressionDialectUnknownFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__TopicExpressionDialectUnknownFaultType() { ns3__TopicExpressionDialectUnknownFaultType::soap_default(NULL); }
	virtual ~ns3__TopicExpressionDialectUnknownFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_ErrorCode
#define SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_ErrorCode (1550)
/* ns3:InvalidTopicExpressionFaultType-ErrorCode */
class SOAP_CMAC _ns3__InvalidTopicExpressionFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1550; } /* = unique type id SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidTopicExpressionFaultType_ErrorCode() { _ns3__InvalidTopicExpressionFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__InvalidTopicExpressionFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_Description
#define SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_Description (1552)
/* Primitive ns3:InvalidTopicExpressionFaultType-Description schema type: */
class SOAP_CMAC _ns3__InvalidTopicExpressionFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1552; } /* = unique type id SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidTopicExpressionFaultType_Description() { _ns3__InvalidTopicExpressionFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__InvalidTopicExpressionFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_FaultCause
#define SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_FaultCause (1555)
/* ns3:InvalidTopicExpressionFaultType-FaultCause */
class SOAP_CMAC _ns3__InvalidTopicExpressionFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1555; } /* = unique type id SOAP_TYPE__ns3__InvalidTopicExpressionFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidTopicExpressionFaultType_FaultCause() { _ns3__InvalidTopicExpressionFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__InvalidTopicExpressionFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__InvalidTopicExpressionFaultType
#define SOAP_TYPE_ns3__InvalidTopicExpressionFaultType (699)
/* ns3:InvalidTopicExpressionFaultType */
class SOAP_CMAC ns3__InvalidTopicExpressionFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__InvalidTopicExpressionFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:InvalidTopicExpressionFaultType-ErrorCode */
	std::vector<_ns3__InvalidTopicExpressionFaultType_Description >*ns5__Description;	/* optional element of type ns3:InvalidTopicExpressionFaultType-Description */
	_ns3__InvalidTopicExpressionFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:InvalidTopicExpressionFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 699; } /* = unique type id SOAP_TYPE_ns3__InvalidTopicExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__InvalidTopicExpressionFaultType() { ns3__InvalidTopicExpressionFaultType::soap_default(NULL); }
	virtual ~ns3__InvalidTopicExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__TopicNotSupportedFaultType_ErrorCode
#define SOAP_TYPE__ns3__TopicNotSupportedFaultType_ErrorCode (1557)
/* ns3:TopicNotSupportedFaultType-ErrorCode */
class SOAP_CMAC _ns3__TopicNotSupportedFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1557; } /* = unique type id SOAP_TYPE__ns3__TopicNotSupportedFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__TopicNotSupportedFaultType_ErrorCode() { _ns3__TopicNotSupportedFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__TopicNotSupportedFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__TopicNotSupportedFaultType_Description
#define SOAP_TYPE__ns3__TopicNotSupportedFaultType_Description (1559)
/* Primitive ns3:TopicNotSupportedFaultType-Description schema type: */
class SOAP_CMAC _ns3__TopicNotSupportedFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1559; } /* = unique type id SOAP_TYPE__ns3__TopicNotSupportedFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__TopicNotSupportedFaultType_Description() { _ns3__TopicNotSupportedFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__TopicNotSupportedFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__TopicNotSupportedFaultType_FaultCause
#define SOAP_TYPE__ns3__TopicNotSupportedFaultType_FaultCause (1562)
/* ns3:TopicNotSupportedFaultType-FaultCause */
class SOAP_CMAC _ns3__TopicNotSupportedFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1562; } /* = unique type id SOAP_TYPE__ns3__TopicNotSupportedFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__TopicNotSupportedFaultType_FaultCause() { _ns3__TopicNotSupportedFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__TopicNotSupportedFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__TopicNotSupportedFaultType
#define SOAP_TYPE_ns3__TopicNotSupportedFaultType (700)
/* ns3:TopicNotSupportedFaultType */
class SOAP_CMAC ns3__TopicNotSupportedFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__TopicNotSupportedFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:TopicNotSupportedFaultType-ErrorCode */
	std::vector<_ns3__TopicNotSupportedFaultType_Description >*ns5__Description;	/* optional element of type ns3:TopicNotSupportedFaultType-Description */
	_ns3__TopicNotSupportedFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:TopicNotSupportedFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 700; } /* = unique type id SOAP_TYPE_ns3__TopicNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__TopicNotSupportedFaultType() { ns3__TopicNotSupportedFaultType::soap_default(NULL); }
	virtual ~ns3__TopicNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_ErrorCode
#define SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_ErrorCode (1564)
/* ns3:MultipleTopicsSpecifiedFaultType-ErrorCode */
class SOAP_CMAC _ns3__MultipleTopicsSpecifiedFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1564; } /* = unique type id SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__MultipleTopicsSpecifiedFaultType_ErrorCode() { _ns3__MultipleTopicsSpecifiedFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__MultipleTopicsSpecifiedFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_Description
#define SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_Description (1566)
/* Primitive ns3:MultipleTopicsSpecifiedFaultType-Description schema type: */
class SOAP_CMAC _ns3__MultipleTopicsSpecifiedFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1566; } /* = unique type id SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__MultipleTopicsSpecifiedFaultType_Description() { _ns3__MultipleTopicsSpecifiedFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__MultipleTopicsSpecifiedFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_FaultCause
#define SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_FaultCause (1569)
/* ns3:MultipleTopicsSpecifiedFaultType-FaultCause */
class SOAP_CMAC _ns3__MultipleTopicsSpecifiedFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1569; } /* = unique type id SOAP_TYPE__ns3__MultipleTopicsSpecifiedFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__MultipleTopicsSpecifiedFaultType_FaultCause() { _ns3__MultipleTopicsSpecifiedFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__MultipleTopicsSpecifiedFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType
#define SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType (701)
/* ns3:MultipleTopicsSpecifiedFaultType */
class SOAP_CMAC ns3__MultipleTopicsSpecifiedFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__MultipleTopicsSpecifiedFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:MultipleTopicsSpecifiedFaultType-ErrorCode */
	std::vector<_ns3__MultipleTopicsSpecifiedFaultType_Description >*ns5__Description;	/* optional element of type ns3:MultipleTopicsSpecifiedFaultType-Description */
	_ns3__MultipleTopicsSpecifiedFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:MultipleTopicsSpecifiedFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 701; } /* = unique type id SOAP_TYPE_ns3__MultipleTopicsSpecifiedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__MultipleTopicsSpecifiedFaultType() { ns3__MultipleTopicsSpecifiedFaultType::soap_default(NULL); }
	virtual ~ns3__MultipleTopicsSpecifiedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode
#define SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode (1571)
/* ns3:InvalidProducerPropertiesExpressionFaultType-ErrorCode */
class SOAP_CMAC _ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1571; } /* = unique type id SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode() { _ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_Description
#define SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_Description (1573)
/* Primitive ns3:InvalidProducerPropertiesExpressionFaultType-Description schema type: */
class SOAP_CMAC _ns3__InvalidProducerPropertiesExpressionFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1573; } /* = unique type id SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidProducerPropertiesExpressionFaultType_Description() { _ns3__InvalidProducerPropertiesExpressionFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__InvalidProducerPropertiesExpressionFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause
#define SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause (1576)
/* ns3:InvalidProducerPropertiesExpressionFaultType-FaultCause */
class SOAP_CMAC _ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1576; } /* = unique type id SOAP_TYPE__ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause() { _ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType
#define SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType (702)
/* ns3:InvalidProducerPropertiesExpressionFaultType */
class SOAP_CMAC ns3__InvalidProducerPropertiesExpressionFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__InvalidProducerPropertiesExpressionFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:InvalidProducerPropertiesExpressionFaultType-ErrorCode */
	std::vector<_ns3__InvalidProducerPropertiesExpressionFaultType_Description >*ns5__Description;	/* optional element of type ns3:InvalidProducerPropertiesExpressionFaultType-Description */
	_ns3__InvalidProducerPropertiesExpressionFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:InvalidProducerPropertiesExpressionFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 702; } /* = unique type id SOAP_TYPE_ns3__InvalidProducerPropertiesExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__InvalidProducerPropertiesExpressionFaultType() { ns3__InvalidProducerPropertiesExpressionFaultType::soap_default(NULL); }
	virtual ~ns3__InvalidProducerPropertiesExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_ErrorCode
#define SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_ErrorCode (1578)
/* ns3:InvalidMessageContentExpressionFaultType-ErrorCode */
class SOAP_CMAC _ns3__InvalidMessageContentExpressionFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1578; } /* = unique type id SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidMessageContentExpressionFaultType_ErrorCode() { _ns3__InvalidMessageContentExpressionFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__InvalidMessageContentExpressionFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_Description
#define SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_Description (1580)
/* Primitive ns3:InvalidMessageContentExpressionFaultType-Description schema type: */
class SOAP_CMAC _ns3__InvalidMessageContentExpressionFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1580; } /* = unique type id SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidMessageContentExpressionFaultType_Description() { _ns3__InvalidMessageContentExpressionFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__InvalidMessageContentExpressionFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_FaultCause
#define SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_FaultCause (1583)
/* ns3:InvalidMessageContentExpressionFaultType-FaultCause */
class SOAP_CMAC _ns3__InvalidMessageContentExpressionFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1583; } /* = unique type id SOAP_TYPE__ns3__InvalidMessageContentExpressionFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__InvalidMessageContentExpressionFaultType_FaultCause() { _ns3__InvalidMessageContentExpressionFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__InvalidMessageContentExpressionFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType
#define SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType (703)
/* ns3:InvalidMessageContentExpressionFaultType */
class SOAP_CMAC ns3__InvalidMessageContentExpressionFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__InvalidMessageContentExpressionFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:InvalidMessageContentExpressionFaultType-ErrorCode */
	std::vector<_ns3__InvalidMessageContentExpressionFaultType_Description >*ns5__Description;	/* optional element of type ns3:InvalidMessageContentExpressionFaultType-Description */
	_ns3__InvalidMessageContentExpressionFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:InvalidMessageContentExpressionFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 703; } /* = unique type id SOAP_TYPE_ns3__InvalidMessageContentExpressionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__InvalidMessageContentExpressionFaultType() { ns3__InvalidMessageContentExpressionFaultType::soap_default(NULL); }
	virtual ~ns3__InvalidMessageContentExpressionFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_ErrorCode (1585)
/* ns3:UnrecognizedPolicyRequestFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnrecognizedPolicyRequestFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1585; } /* = unique type id SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnrecognizedPolicyRequestFaultType_ErrorCode() { _ns3__UnrecognizedPolicyRequestFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnrecognizedPolicyRequestFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_Description
#define SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_Description (1587)
/* Primitive ns3:UnrecognizedPolicyRequestFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnrecognizedPolicyRequestFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1587; } /* = unique type id SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnrecognizedPolicyRequestFaultType_Description() { _ns3__UnrecognizedPolicyRequestFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnrecognizedPolicyRequestFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_FaultCause
#define SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_FaultCause (1590)
/* ns3:UnrecognizedPolicyRequestFaultType-FaultCause */
class SOAP_CMAC _ns3__UnrecognizedPolicyRequestFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1590; } /* = unique type id SOAP_TYPE__ns3__UnrecognizedPolicyRequestFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnrecognizedPolicyRequestFaultType_FaultCause() { _ns3__UnrecognizedPolicyRequestFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnrecognizedPolicyRequestFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType (704)
/* ns3:UnrecognizedPolicyRequestFaultType */
class SOAP_CMAC ns3__UnrecognizedPolicyRequestFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnrecognizedPolicyRequestFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnrecognizedPolicyRequestFaultType-ErrorCode */
	std::vector<_ns3__UnrecognizedPolicyRequestFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnrecognizedPolicyRequestFaultType-Description */
	_ns3__UnrecognizedPolicyRequestFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnrecognizedPolicyRequestFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
	std::vector<std::string >UnrecognizedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 704; } /* = unique type id SOAP_TYPE_ns3__UnrecognizedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnrecognizedPolicyRequestFaultType() { ns3__UnrecognizedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~ns3__UnrecognizedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_ErrorCode (1592)
/* ns3:UnsupportedPolicyRequestFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnsupportedPolicyRequestFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1592; } /* = unique type id SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnsupportedPolicyRequestFaultType_ErrorCode() { _ns3__UnsupportedPolicyRequestFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnsupportedPolicyRequestFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_Description
#define SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_Description (1594)
/* Primitive ns3:UnsupportedPolicyRequestFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnsupportedPolicyRequestFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1594; } /* = unique type id SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnsupportedPolicyRequestFaultType_Description() { _ns3__UnsupportedPolicyRequestFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnsupportedPolicyRequestFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_FaultCause
#define SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_FaultCause (1597)
/* ns3:UnsupportedPolicyRequestFaultType-FaultCause */
class SOAP_CMAC _ns3__UnsupportedPolicyRequestFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1597; } /* = unique type id SOAP_TYPE__ns3__UnsupportedPolicyRequestFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnsupportedPolicyRequestFaultType_FaultCause() { _ns3__UnsupportedPolicyRequestFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnsupportedPolicyRequestFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType
#define SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType (705)
/* ns3:UnsupportedPolicyRequestFaultType */
class SOAP_CMAC ns3__UnsupportedPolicyRequestFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnsupportedPolicyRequestFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnsupportedPolicyRequestFaultType-ErrorCode */
	std::vector<_ns3__UnsupportedPolicyRequestFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnsupportedPolicyRequestFaultType-Description */
	_ns3__UnsupportedPolicyRequestFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnsupportedPolicyRequestFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
	std::vector<std::string >UnsupportedPolicy;	/* optional element of type xsd:QName */
public:
	virtual int soap_type() const { return 705; } /* = unique type id SOAP_TYPE_ns3__UnsupportedPolicyRequestFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnsupportedPolicyRequestFaultType() { ns3__UnsupportedPolicyRequestFaultType::soap_default(NULL); }
	virtual ~ns3__UnsupportedPolicyRequestFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_ErrorCode
#define SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_ErrorCode (1599)
/* ns3:NotifyMessageNotSupportedFaultType-ErrorCode */
class SOAP_CMAC _ns3__NotifyMessageNotSupportedFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1599; } /* = unique type id SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NotifyMessageNotSupportedFaultType_ErrorCode() { _ns3__NotifyMessageNotSupportedFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__NotifyMessageNotSupportedFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_Description
#define SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_Description (1601)
/* Primitive ns3:NotifyMessageNotSupportedFaultType-Description schema type: */
class SOAP_CMAC _ns3__NotifyMessageNotSupportedFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1601; } /* = unique type id SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NotifyMessageNotSupportedFaultType_Description() { _ns3__NotifyMessageNotSupportedFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__NotifyMessageNotSupportedFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_FaultCause
#define SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_FaultCause (1604)
/* ns3:NotifyMessageNotSupportedFaultType-FaultCause */
class SOAP_CMAC _ns3__NotifyMessageNotSupportedFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1604; } /* = unique type id SOAP_TYPE__ns3__NotifyMessageNotSupportedFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NotifyMessageNotSupportedFaultType_FaultCause() { _ns3__NotifyMessageNotSupportedFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__NotifyMessageNotSupportedFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType
#define SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType (706)
/* ns3:NotifyMessageNotSupportedFaultType */
class SOAP_CMAC ns3__NotifyMessageNotSupportedFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__NotifyMessageNotSupportedFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:NotifyMessageNotSupportedFaultType-ErrorCode */
	std::vector<_ns3__NotifyMessageNotSupportedFaultType_Description >*ns5__Description;	/* optional element of type ns3:NotifyMessageNotSupportedFaultType-Description */
	_ns3__NotifyMessageNotSupportedFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:NotifyMessageNotSupportedFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 706; } /* = unique type id SOAP_TYPE_ns3__NotifyMessageNotSupportedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__NotifyMessageNotSupportedFaultType() { ns3__NotifyMessageNotSupportedFaultType::soap_default(NULL); }
	virtual ~ns3__NotifyMessageNotSupportedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode (1606)
/* ns3:UnacceptableInitialTerminationTimeFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1606; } /* = unique type id SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode() { _ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_Description
#define SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_Description (1608)
/* Primitive ns3:UnacceptableInitialTerminationTimeFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnacceptableInitialTerminationTimeFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1608; } /* = unique type id SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnacceptableInitialTerminationTimeFaultType_Description() { _ns3__UnacceptableInitialTerminationTimeFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnacceptableInitialTerminationTimeFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause
#define SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause (1611)
/* ns3:UnacceptableInitialTerminationTimeFaultType-FaultCause */
class SOAP_CMAC _ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1611; } /* = unique type id SOAP_TYPE__ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause() { _ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType (707)
/* ns3:UnacceptableInitialTerminationTimeFaultType */
class SOAP_CMAC ns3__UnacceptableInitialTerminationTimeFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnacceptableInitialTerminationTimeFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnacceptableInitialTerminationTimeFaultType-ErrorCode */
	std::vector<_ns3__UnacceptableInitialTerminationTimeFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnacceptableInitialTerminationTimeFaultType-Description */
	_ns3__UnacceptableInitialTerminationTimeFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnacceptableInitialTerminationTimeFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 707; } /* = unique type id SOAP_TYPE_ns3__UnacceptableInitialTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnacceptableInitialTerminationTimeFaultType() { ns3__UnacceptableInitialTerminationTimeFaultType::soap_default(NULL); }
	virtual ~ns3__UnacceptableInitialTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_ErrorCode
#define SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_ErrorCode (1613)
/* ns3:NoCurrentMessageOnTopicFaultType-ErrorCode */
class SOAP_CMAC _ns3__NoCurrentMessageOnTopicFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1613; } /* = unique type id SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NoCurrentMessageOnTopicFaultType_ErrorCode() { _ns3__NoCurrentMessageOnTopicFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__NoCurrentMessageOnTopicFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_Description
#define SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_Description (1615)
/* Primitive ns3:NoCurrentMessageOnTopicFaultType-Description schema type: */
class SOAP_CMAC _ns3__NoCurrentMessageOnTopicFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1615; } /* = unique type id SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NoCurrentMessageOnTopicFaultType_Description() { _ns3__NoCurrentMessageOnTopicFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__NoCurrentMessageOnTopicFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_FaultCause
#define SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_FaultCause (1618)
/* ns3:NoCurrentMessageOnTopicFaultType-FaultCause */
class SOAP_CMAC _ns3__NoCurrentMessageOnTopicFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1618; } /* = unique type id SOAP_TYPE__ns3__NoCurrentMessageOnTopicFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__NoCurrentMessageOnTopicFaultType_FaultCause() { _ns3__NoCurrentMessageOnTopicFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__NoCurrentMessageOnTopicFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType
#define SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType (708)
/* ns3:NoCurrentMessageOnTopicFaultType */
class SOAP_CMAC ns3__NoCurrentMessageOnTopicFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__NoCurrentMessageOnTopicFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:NoCurrentMessageOnTopicFaultType-ErrorCode */
	std::vector<_ns3__NoCurrentMessageOnTopicFaultType_Description >*ns5__Description;	/* optional element of type ns3:NoCurrentMessageOnTopicFaultType-Description */
	_ns3__NoCurrentMessageOnTopicFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:NoCurrentMessageOnTopicFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 708; } /* = unique type id SOAP_TYPE_ns3__NoCurrentMessageOnTopicFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__NoCurrentMessageOnTopicFaultType() { ns3__NoCurrentMessageOnTopicFaultType::soap_default(NULL); }
	virtual ~ns3__NoCurrentMessageOnTopicFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToGetMessagesFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnableToGetMessagesFaultType_ErrorCode (1620)
/* ns3:UnableToGetMessagesFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnableToGetMessagesFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1620; } /* = unique type id SOAP_TYPE__ns3__UnableToGetMessagesFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToGetMessagesFaultType_ErrorCode() { _ns3__UnableToGetMessagesFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnableToGetMessagesFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToGetMessagesFaultType_Description
#define SOAP_TYPE__ns3__UnableToGetMessagesFaultType_Description (1622)
/* Primitive ns3:UnableToGetMessagesFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnableToGetMessagesFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1622; } /* = unique type id SOAP_TYPE__ns3__UnableToGetMessagesFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToGetMessagesFaultType_Description() { _ns3__UnableToGetMessagesFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnableToGetMessagesFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToGetMessagesFaultType_FaultCause
#define SOAP_TYPE__ns3__UnableToGetMessagesFaultType_FaultCause (1625)
/* ns3:UnableToGetMessagesFaultType-FaultCause */
class SOAP_CMAC _ns3__UnableToGetMessagesFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1625; } /* = unique type id SOAP_TYPE__ns3__UnableToGetMessagesFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToGetMessagesFaultType_FaultCause() { _ns3__UnableToGetMessagesFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnableToGetMessagesFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnableToGetMessagesFaultType
#define SOAP_TYPE_ns3__UnableToGetMessagesFaultType (709)
/* ns3:UnableToGetMessagesFaultType */
class SOAP_CMAC ns3__UnableToGetMessagesFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnableToGetMessagesFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnableToGetMessagesFaultType-ErrorCode */
	std::vector<_ns3__UnableToGetMessagesFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnableToGetMessagesFaultType-Description */
	_ns3__UnableToGetMessagesFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnableToGetMessagesFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 709; } /* = unique type id SOAP_TYPE_ns3__UnableToGetMessagesFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnableToGetMessagesFaultType() { ns3__UnableToGetMessagesFaultType::soap_default(NULL); }
	virtual ~ns3__UnableToGetMessagesFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_ErrorCode (1627)
/* ns3:UnableToDestroyPullPointFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnableToDestroyPullPointFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1627; } /* = unique type id SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToDestroyPullPointFaultType_ErrorCode() { _ns3__UnableToDestroyPullPointFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnableToDestroyPullPointFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_Description
#define SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_Description (1629)
/* Primitive ns3:UnableToDestroyPullPointFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnableToDestroyPullPointFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1629; } /* = unique type id SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToDestroyPullPointFaultType_Description() { _ns3__UnableToDestroyPullPointFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnableToDestroyPullPointFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_FaultCause
#define SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_FaultCause (1632)
/* ns3:UnableToDestroyPullPointFaultType-FaultCause */
class SOAP_CMAC _ns3__UnableToDestroyPullPointFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1632; } /* = unique type id SOAP_TYPE__ns3__UnableToDestroyPullPointFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToDestroyPullPointFaultType_FaultCause() { _ns3__UnableToDestroyPullPointFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnableToDestroyPullPointFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType
#define SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType (710)
/* ns3:UnableToDestroyPullPointFaultType */
class SOAP_CMAC ns3__UnableToDestroyPullPointFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnableToDestroyPullPointFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnableToDestroyPullPointFaultType-ErrorCode */
	std::vector<_ns3__UnableToDestroyPullPointFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnableToDestroyPullPointFaultType-Description */
	_ns3__UnableToDestroyPullPointFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnableToDestroyPullPointFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 710; } /* = unique type id SOAP_TYPE_ns3__UnableToDestroyPullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnableToDestroyPullPointFaultType() { ns3__UnableToDestroyPullPointFaultType::soap_default(NULL); }
	virtual ~ns3__UnableToDestroyPullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_ErrorCode (1634)
/* ns3:UnableToCreatePullPointFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnableToCreatePullPointFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1634; } /* = unique type id SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToCreatePullPointFaultType_ErrorCode() { _ns3__UnableToCreatePullPointFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnableToCreatePullPointFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_Description
#define SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_Description (1636)
/* Primitive ns3:UnableToCreatePullPointFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnableToCreatePullPointFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1636; } /* = unique type id SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToCreatePullPointFaultType_Description() { _ns3__UnableToCreatePullPointFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnableToCreatePullPointFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_FaultCause
#define SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_FaultCause (1639)
/* ns3:UnableToCreatePullPointFaultType-FaultCause */
class SOAP_CMAC _ns3__UnableToCreatePullPointFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1639; } /* = unique type id SOAP_TYPE__ns3__UnableToCreatePullPointFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToCreatePullPointFaultType_FaultCause() { _ns3__UnableToCreatePullPointFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnableToCreatePullPointFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnableToCreatePullPointFaultType
#define SOAP_TYPE_ns3__UnableToCreatePullPointFaultType (711)
/* ns3:UnableToCreatePullPointFaultType */
class SOAP_CMAC ns3__UnableToCreatePullPointFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnableToCreatePullPointFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnableToCreatePullPointFaultType-ErrorCode */
	std::vector<_ns3__UnableToCreatePullPointFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnableToCreatePullPointFaultType-Description */
	_ns3__UnableToCreatePullPointFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnableToCreatePullPointFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 711; } /* = unique type id SOAP_TYPE_ns3__UnableToCreatePullPointFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnableToCreatePullPointFaultType() { ns3__UnableToCreatePullPointFaultType::soap_default(NULL); }
	virtual ~ns3__UnableToCreatePullPointFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_ErrorCode (1641)
/* ns3:UnacceptableTerminationTimeFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnacceptableTerminationTimeFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1641; } /* = unique type id SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnacceptableTerminationTimeFaultType_ErrorCode() { _ns3__UnacceptableTerminationTimeFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnacceptableTerminationTimeFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_Description
#define SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_Description (1643)
/* Primitive ns3:UnacceptableTerminationTimeFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnacceptableTerminationTimeFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1643; } /* = unique type id SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnacceptableTerminationTimeFaultType_Description() { _ns3__UnacceptableTerminationTimeFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnacceptableTerminationTimeFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_FaultCause
#define SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_FaultCause (1646)
/* ns3:UnacceptableTerminationTimeFaultType-FaultCause */
class SOAP_CMAC _ns3__UnacceptableTerminationTimeFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1646; } /* = unique type id SOAP_TYPE__ns3__UnacceptableTerminationTimeFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnacceptableTerminationTimeFaultType_FaultCause() { _ns3__UnacceptableTerminationTimeFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnacceptableTerminationTimeFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType
#define SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType (712)
/* ns3:UnacceptableTerminationTimeFaultType */
class SOAP_CMAC ns3__UnacceptableTerminationTimeFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnacceptableTerminationTimeFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnacceptableTerminationTimeFaultType-ErrorCode */
	std::vector<_ns3__UnacceptableTerminationTimeFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnacceptableTerminationTimeFaultType-Description */
	_ns3__UnacceptableTerminationTimeFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnacceptableTerminationTimeFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
	time_t MinimumTime;	/* required element of type xsd:dateTime */
	time_t *MaximumTime;	/* optional element of type xsd:dateTime */
public:
	virtual int soap_type() const { return 712; } /* = unique type id SOAP_TYPE_ns3__UnacceptableTerminationTimeFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnacceptableTerminationTimeFaultType() { ns3__UnacceptableTerminationTimeFaultType::soap_default(NULL); }
	virtual ~ns3__UnacceptableTerminationTimeFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_ErrorCode
#define SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_ErrorCode (1648)
/* ns3:UnableToDestroySubscriptionFaultType-ErrorCode */
class SOAP_CMAC _ns3__UnableToDestroySubscriptionFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1648; } /* = unique type id SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToDestroySubscriptionFaultType_ErrorCode() { _ns3__UnableToDestroySubscriptionFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__UnableToDestroySubscriptionFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_Description
#define SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_Description (1650)
/* Primitive ns3:UnableToDestroySubscriptionFaultType-Description schema type: */
class SOAP_CMAC _ns3__UnableToDestroySubscriptionFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1650; } /* = unique type id SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToDestroySubscriptionFaultType_Description() { _ns3__UnableToDestroySubscriptionFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__UnableToDestroySubscriptionFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_FaultCause
#define SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_FaultCause (1653)
/* ns3:UnableToDestroySubscriptionFaultType-FaultCause */
class SOAP_CMAC _ns3__UnableToDestroySubscriptionFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1653; } /* = unique type id SOAP_TYPE__ns3__UnableToDestroySubscriptionFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__UnableToDestroySubscriptionFaultType_FaultCause() { _ns3__UnableToDestroySubscriptionFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__UnableToDestroySubscriptionFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType
#define SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType (713)
/* ns3:UnableToDestroySubscriptionFaultType */
class SOAP_CMAC ns3__UnableToDestroySubscriptionFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__UnableToDestroySubscriptionFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:UnableToDestroySubscriptionFaultType-ErrorCode */
	std::vector<_ns3__UnableToDestroySubscriptionFaultType_Description >*ns5__Description;	/* optional element of type ns3:UnableToDestroySubscriptionFaultType-Description */
	_ns3__UnableToDestroySubscriptionFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:UnableToDestroySubscriptionFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 713; } /* = unique type id SOAP_TYPE_ns3__UnableToDestroySubscriptionFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__UnableToDestroySubscriptionFaultType() { ns3__UnableToDestroySubscriptionFaultType::soap_default(NULL); }
	virtual ~ns3__UnableToDestroySubscriptionFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__PauseFailedFaultType_ErrorCode
#define SOAP_TYPE__ns3__PauseFailedFaultType_ErrorCode (1655)
/* ns3:PauseFailedFaultType-ErrorCode */
class SOAP_CMAC _ns3__PauseFailedFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1655; } /* = unique type id SOAP_TYPE__ns3__PauseFailedFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__PauseFailedFaultType_ErrorCode() { _ns3__PauseFailedFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__PauseFailedFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__PauseFailedFaultType_Description
#define SOAP_TYPE__ns3__PauseFailedFaultType_Description (1657)
/* Primitive ns3:PauseFailedFaultType-Description schema type: */
class SOAP_CMAC _ns3__PauseFailedFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1657; } /* = unique type id SOAP_TYPE__ns3__PauseFailedFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__PauseFailedFaultType_Description() { _ns3__PauseFailedFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__PauseFailedFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__PauseFailedFaultType_FaultCause
#define SOAP_TYPE__ns3__PauseFailedFaultType_FaultCause (1660)
/* ns3:PauseFailedFaultType-FaultCause */
class SOAP_CMAC _ns3__PauseFailedFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1660; } /* = unique type id SOAP_TYPE__ns3__PauseFailedFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__PauseFailedFaultType_FaultCause() { _ns3__PauseFailedFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__PauseFailedFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__PauseFailedFaultType
#define SOAP_TYPE_ns3__PauseFailedFaultType (714)
/* ns3:PauseFailedFaultType */
class SOAP_CMAC ns3__PauseFailedFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__PauseFailedFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:PauseFailedFaultType-ErrorCode */
	std::vector<_ns3__PauseFailedFaultType_Description >*ns5__Description;	/* optional element of type ns3:PauseFailedFaultType-Description */
	_ns3__PauseFailedFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:PauseFailedFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 714; } /* = unique type id SOAP_TYPE_ns3__PauseFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__PauseFailedFaultType() { ns3__PauseFailedFaultType::soap_default(NULL); }
	virtual ~ns3__PauseFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ResumeFailedFaultType_ErrorCode
#define SOAP_TYPE__ns3__ResumeFailedFaultType_ErrorCode (1662)
/* ns3:ResumeFailedFaultType-ErrorCode */
class SOAP_CMAC _ns3__ResumeFailedFaultType_ErrorCode
{
public:
	std::string dialect;	/* required attribute */
public:
	virtual int soap_type() const { return 1662; } /* = unique type id SOAP_TYPE__ns3__ResumeFailedFaultType_ErrorCode */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ResumeFailedFaultType_ErrorCode() { _ns3__ResumeFailedFaultType_ErrorCode::soap_default(NULL); }
	virtual ~_ns3__ResumeFailedFaultType_ErrorCode() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ResumeFailedFaultType_Description
#define SOAP_TYPE__ns3__ResumeFailedFaultType_Description (1664)
/* Primitive ns3:ResumeFailedFaultType-Description schema type: */
class SOAP_CMAC _ns3__ResumeFailedFaultType_Description
{
public:
	std::string __item;
	std::string *xml__lang;	/* optional attribute */
public:
	virtual int soap_type() const { return 1664; } /* = unique type id SOAP_TYPE__ns3__ResumeFailedFaultType_Description */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ResumeFailedFaultType_Description() { _ns3__ResumeFailedFaultType_Description::soap_default(NULL); }
	virtual ~_ns3__ResumeFailedFaultType_Description() { }
};
#endif

#ifndef SOAP_TYPE__ns3__ResumeFailedFaultType_FaultCause
#define SOAP_TYPE__ns3__ResumeFailedFaultType_FaultCause (1667)
/* ns3:ResumeFailedFaultType-FaultCause */
class SOAP_CMAC _ns3__ResumeFailedFaultType_FaultCause
{
public:
	char *__any;
public:
	virtual int soap_type() const { return 1667; } /* = unique type id SOAP_TYPE__ns3__ResumeFailedFaultType_FaultCause */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns3__ResumeFailedFaultType_FaultCause() { _ns3__ResumeFailedFaultType_FaultCause::soap_default(NULL); }
	virtual ~_ns3__ResumeFailedFaultType_FaultCause() { }
};
#endif

#ifndef SOAP_TYPE_ns3__ResumeFailedFaultType
#define SOAP_TYPE_ns3__ResumeFailedFaultType (715)
/* ns3:ResumeFailedFaultType */
class SOAP_CMAC ns3__ResumeFailedFaultType
{
public:
	std::vector<char * >__any;
	time_t ns5__Timestamp;	/* required element of type xsd:dateTime */
	ns7__EndpointReferenceType *ns5__Originator;	/* optional element of type ns7:EndpointReferenceType */
	_ns3__ResumeFailedFaultType_ErrorCode *ns5__ErrorCode;	/* optional element of type ns3:ResumeFailedFaultType-ErrorCode */
	std::vector<_ns3__ResumeFailedFaultType_Description >*ns5__Description;	/* optional element of type ns3:ResumeFailedFaultType-Description */
	_ns3__ResumeFailedFaultType_FaultCause *ns5__FaultCause;	/* optional element of type ns3:ResumeFailedFaultType-FaultCause */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 715; } /* = unique type id SOAP_TYPE_ns3__ResumeFailedFaultType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns3__ResumeFailedFaultType() { ns3__ResumeFailedFaultType::soap_default(NULL); }
	virtual ~ns3__ResumeFailedFaultType() { }
};
#endif

#ifndef SOAP_TYPE__ns6__TopicNamespaceType_Topic
#define SOAP_TYPE__ns6__TopicNamespaceType_Topic (1669)
/* ns6:TopicNamespaceType-Topic */
class SOAP_CMAC _ns6__TopicNamespaceType_Topic
{
public:
	ns6__Documentation *documentation;	/* optional element of type ns6:Documentation */
	char *__anyAttribute;	/* optional attribute */
	ns6__QueryExpressionType *MessagePattern;	/* optional element of type ns6:QueryExpressionType */
	std::vector<class ns6__TopicType * >Topic;	/* optional element of type ns6:TopicType */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	std::string *messageTypes;	/* optional attribute */
	bool final_;	/* optional attribute */
	std::string *parent;	/* optional attribute */
public:
	virtual int soap_type() const { return 1669; } /* = unique type id SOAP_TYPE__ns6__TopicNamespaceType_Topic */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         _ns6__TopicNamespaceType_Topic() { _ns6__TopicNamespaceType_Topic::soap_default(NULL); }
	virtual ~_ns6__TopicNamespaceType_Topic() { }
};
#endif

#ifndef SOAP_TYPE_ns6__TopicNamespaceType
#define SOAP_TYPE_ns6__TopicNamespaceType (743)
/* ns6:TopicNamespaceType */
class SOAP_CMAC ns6__TopicNamespaceType
{
public:
	ns6__Documentation *documentation;	/* optional element of type ns6:Documentation */
	char *__anyAttribute;	/* optional attribute */
	std::vector<_ns6__TopicNamespaceType_Topic >*Topic;	/* optional element of type ns6:TopicNamespaceType-Topic */
	std::vector<char * >__any;
	std::string *name;	/* optional attribute */
	std::string targetNamespace;	/* required attribute */
	bool final_;	/* optional attribute */
public:
	virtual int soap_type() const { return 743; } /* = unique type id SOAP_TYPE_ns6__TopicNamespaceType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__TopicNamespaceType() { ns6__TopicNamespaceType::soap_default(NULL); }
	virtual ~ns6__TopicNamespaceType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__TopicType
#define SOAP_TYPE_ns6__TopicType (744)
/* ns6:TopicType */
class SOAP_CMAC ns6__TopicType
{
public:
	ns6__Documentation *documentation;	/* optional element of type ns6:Documentation */
	char *__anyAttribute;	/* optional attribute */
	ns6__QueryExpressionType *MessagePattern;	/* optional element of type ns6:QueryExpressionType */
	std::vector<ns6__TopicType * >Topic;	/* optional element of type ns6:TopicType */
	std::vector<char * >__any;
	std::string name;	/* required attribute */
	std::string *messageTypes;	/* optional attribute */
	bool final_;	/* optional attribute */
public:
	virtual int soap_type() const { return 744; } /* = unique type id SOAP_TYPE_ns6__TopicType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__TopicType() { ns6__TopicType::soap_default(NULL); }
	virtual ~ns6__TopicType() { }
};
#endif

#ifndef SOAP_TYPE_ns6__TopicSetType
#define SOAP_TYPE_ns6__TopicSetType (745)
/* ns6:TopicSetType */
class SOAP_CMAC ns6__TopicSetType
{
public:
	ns6__Documentation *documentation;	/* optional element of type ns6:Documentation */
	char *__anyAttribute;	/* optional attribute */
	std::vector<char * >__any;
public:
	virtual int soap_type() const { return 745; } /* = unique type id SOAP_TYPE_ns6__TopicSetType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns6__TopicSetType() { ns6__TopicSetType::soap_default(NULL); }
	virtual ~ns6__TopicSetType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__RelatesToType
#define SOAP_TYPE_ns7__RelatesToType (749)
/* Primitive ns7:RelatesToType schema type: */
class SOAP_CMAC ns7__RelatesToType : public xsd__anyType
{
public:
	std::string __item;
	std::string RelationshipType;	/* optional attribute */
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 749; } /* = unique type id SOAP_TYPE_ns7__RelatesToType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__RelatesToType() { ns7__RelatesToType::soap_default(NULL); }
	virtual ~ns7__RelatesToType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__AttributedURIType
#define SOAP_TYPE_ns7__AttributedURIType (750)
/* Primitive ns7:AttributedURIType schema type: */
class SOAP_CMAC ns7__AttributedURIType : public xsd__anyType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 750; } /* = unique type id SOAP_TYPE_ns7__AttributedURIType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__AttributedURIType() { ns7__AttributedURIType::soap_default(NULL); }
	virtual ~ns7__AttributedURIType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__AttributedUnsignedLongType
#define SOAP_TYPE_ns7__AttributedUnsignedLongType (751)
/* Primitive ns7:AttributedUnsignedLongType schema type: */
class SOAP_CMAC ns7__AttributedUnsignedLongType : public xsd__anyType
{
public:
	ULONG64 __item;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 751; } /* = unique type id SOAP_TYPE_ns7__AttributedUnsignedLongType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__AttributedUnsignedLongType() { ns7__AttributedUnsignedLongType::soap_default(NULL); }
	virtual ~ns7__AttributedUnsignedLongType() { }
};
#endif

#ifndef SOAP_TYPE_ns7__AttributedQNameType
#define SOAP_TYPE_ns7__AttributedQNameType (752)
/* Primitive ns7:AttributedQNameType schema type: */
class SOAP_CMAC ns7__AttributedQNameType : public xsd__anyType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 752; } /* = unique type id SOAP_TYPE_ns7__AttributedQNameType */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns7__AttributedQNameType() { ns7__AttributedQNameType::soap_default(NULL); }
	virtual ~ns7__AttributedQNameType() { }
};
#endif

#ifndef SOAP_TYPE_ns2__OSDReference
#define SOAP_TYPE_ns2__OSDReference (664)
/* Primitive ns2:OSDReference schema type: */
class SOAP_CMAC ns2__OSDReference : public xsd__anyType
{
public:
	std::string __item;
	char *__anyAttribute;	/* optional attribute */
public:
	virtual int soap_type() const { return 664; } /* = unique type id SOAP_TYPE_ns2__OSDReference */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns2__OSDReference() { ns2__OSDReference::soap_default(NULL); }
	virtual ~ns2__OSDReference() { }
};
#endif

#ifndef SOAP_TYPE___ns1__GetServiceCapabilities
#define SOAP_TYPE___ns1__GetServiceCapabilities (1681)
/* Operation wrapper: */
struct __ns1__GetServiceCapabilities
{
public:
	_ns1__GetServiceCapabilities *ns1__GetServiceCapabilities;	/* optional element of type ns1:GetServiceCapabilities */
public:
	int soap_type() const { return 1681; } /* = unique type id SOAP_TYPE___ns1__GetServiceCapabilities */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSources
#define SOAP_TYPE___ns1__GetVideoSources (1685)
/* Operation wrapper: */
struct __ns1__GetVideoSources
{
public:
	_ns1__GetVideoSources *ns1__GetVideoSources;	/* optional element of type ns1:GetVideoSources */
public:
	int soap_type() const { return 1685; } /* = unique type id SOAP_TYPE___ns1__GetVideoSources */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioSources
#define SOAP_TYPE___ns1__GetAudioSources (1689)
/* Operation wrapper: */
struct __ns1__GetAudioSources
{
public:
	_ns1__GetAudioSources *ns1__GetAudioSources;	/* optional element of type ns1:GetAudioSources */
public:
	int soap_type() const { return 1689; } /* = unique type id SOAP_TYPE___ns1__GetAudioSources */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioOutputs
#define SOAP_TYPE___ns1__GetAudioOutputs (1693)
/* Operation wrapper: */
struct __ns1__GetAudioOutputs
{
public:
	_ns1__GetAudioOutputs *ns1__GetAudioOutputs;	/* optional element of type ns1:GetAudioOutputs */
public:
	int soap_type() const { return 1693; } /* = unique type id SOAP_TYPE___ns1__GetAudioOutputs */
};
#endif

#ifndef SOAP_TYPE___ns1__CreateProfile
#define SOAP_TYPE___ns1__CreateProfile (1697)
/* Operation wrapper: */
struct __ns1__CreateProfile
{
public:
	_ns1__CreateProfile *ns1__CreateProfile;	/* optional element of type ns1:CreateProfile */
public:
	int soap_type() const { return 1697; } /* = unique type id SOAP_TYPE___ns1__CreateProfile */
};
#endif

#ifndef SOAP_TYPE___ns1__GetProfile
#define SOAP_TYPE___ns1__GetProfile (1701)
/* Operation wrapper: */
struct __ns1__GetProfile
{
public:
	_ns1__GetProfile *ns1__GetProfile;	/* optional element of type ns1:GetProfile */
public:
	int soap_type() const { return 1701; } /* = unique type id SOAP_TYPE___ns1__GetProfile */
};
#endif

#ifndef SOAP_TYPE___ns1__GetProfiles
#define SOAP_TYPE___ns1__GetProfiles (1705)
/* Operation wrapper: */
struct __ns1__GetProfiles
{
public:
	_ns1__GetProfiles *ns1__GetProfiles;	/* optional element of type ns1:GetProfiles */
public:
	int soap_type() const { return 1705; } /* = unique type id SOAP_TYPE___ns1__GetProfiles */
};
#endif

#ifndef SOAP_TYPE___ns1__AddVideoEncoderConfiguration
#define SOAP_TYPE___ns1__AddVideoEncoderConfiguration (1709)
/* Operation wrapper: */
struct __ns1__AddVideoEncoderConfiguration
{
public:
	_ns1__AddVideoEncoderConfiguration *ns1__AddVideoEncoderConfiguration;	/* optional element of type ns1:AddVideoEncoderConfiguration */
public:
	int soap_type() const { return 1709; } /* = unique type id SOAP_TYPE___ns1__AddVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddVideoSourceConfiguration
#define SOAP_TYPE___ns1__AddVideoSourceConfiguration (1713)
/* Operation wrapper: */
struct __ns1__AddVideoSourceConfiguration
{
public:
	_ns1__AddVideoSourceConfiguration *ns1__AddVideoSourceConfiguration;	/* optional element of type ns1:AddVideoSourceConfiguration */
public:
	int soap_type() const { return 1713; } /* = unique type id SOAP_TYPE___ns1__AddVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddAudioEncoderConfiguration
#define SOAP_TYPE___ns1__AddAudioEncoderConfiguration (1717)
/* Operation wrapper: */
struct __ns1__AddAudioEncoderConfiguration
{
public:
	_ns1__AddAudioEncoderConfiguration *ns1__AddAudioEncoderConfiguration;	/* optional element of type ns1:AddAudioEncoderConfiguration */
public:
	int soap_type() const { return 1717; } /* = unique type id SOAP_TYPE___ns1__AddAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddAudioSourceConfiguration
#define SOAP_TYPE___ns1__AddAudioSourceConfiguration (1721)
/* Operation wrapper: */
struct __ns1__AddAudioSourceConfiguration
{
public:
	_ns1__AddAudioSourceConfiguration *ns1__AddAudioSourceConfiguration;	/* optional element of type ns1:AddAudioSourceConfiguration */
public:
	int soap_type() const { return 1721; } /* = unique type id SOAP_TYPE___ns1__AddAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddPTZConfiguration
#define SOAP_TYPE___ns1__AddPTZConfiguration (1725)
/* Operation wrapper: */
struct __ns1__AddPTZConfiguration
{
public:
	_ns1__AddPTZConfiguration *ns1__AddPTZConfiguration;	/* optional element of type ns1:AddPTZConfiguration */
public:
	int soap_type() const { return 1725; } /* = unique type id SOAP_TYPE___ns1__AddPTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddVideoAnalyticsConfiguration
#define SOAP_TYPE___ns1__AddVideoAnalyticsConfiguration (1729)
/* Operation wrapper: */
struct __ns1__AddVideoAnalyticsConfiguration
{
public:
	_ns1__AddVideoAnalyticsConfiguration *ns1__AddVideoAnalyticsConfiguration;	/* optional element of type ns1:AddVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 1729; } /* = unique type id SOAP_TYPE___ns1__AddVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddMetadataConfiguration
#define SOAP_TYPE___ns1__AddMetadataConfiguration (1733)
/* Operation wrapper: */
struct __ns1__AddMetadataConfiguration
{
public:
	_ns1__AddMetadataConfiguration *ns1__AddMetadataConfiguration;	/* optional element of type ns1:AddMetadataConfiguration */
public:
	int soap_type() const { return 1733; } /* = unique type id SOAP_TYPE___ns1__AddMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddAudioOutputConfiguration
#define SOAP_TYPE___ns1__AddAudioOutputConfiguration (1737)
/* Operation wrapper: */
struct __ns1__AddAudioOutputConfiguration
{
public:
	_ns1__AddAudioOutputConfiguration *ns1__AddAudioOutputConfiguration;	/* optional element of type ns1:AddAudioOutputConfiguration */
public:
	int soap_type() const { return 1737; } /* = unique type id SOAP_TYPE___ns1__AddAudioOutputConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__AddAudioDecoderConfiguration
#define SOAP_TYPE___ns1__AddAudioDecoderConfiguration (1741)
/* Operation wrapper: */
struct __ns1__AddAudioDecoderConfiguration
{
public:
	_ns1__AddAudioDecoderConfiguration *ns1__AddAudioDecoderConfiguration;	/* optional element of type ns1:AddAudioDecoderConfiguration */
public:
	int soap_type() const { return 1741; } /* = unique type id SOAP_TYPE___ns1__AddAudioDecoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveVideoEncoderConfiguration
#define SOAP_TYPE___ns1__RemoveVideoEncoderConfiguration (1745)
/* Operation wrapper: */
struct __ns1__RemoveVideoEncoderConfiguration
{
public:
	_ns1__RemoveVideoEncoderConfiguration *ns1__RemoveVideoEncoderConfiguration;	/* optional element of type ns1:RemoveVideoEncoderConfiguration */
public:
	int soap_type() const { return 1745; } /* = unique type id SOAP_TYPE___ns1__RemoveVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveVideoSourceConfiguration
#define SOAP_TYPE___ns1__RemoveVideoSourceConfiguration (1749)
/* Operation wrapper: */
struct __ns1__RemoveVideoSourceConfiguration
{
public:
	_ns1__RemoveVideoSourceConfiguration *ns1__RemoveVideoSourceConfiguration;	/* optional element of type ns1:RemoveVideoSourceConfiguration */
public:
	int soap_type() const { return 1749; } /* = unique type id SOAP_TYPE___ns1__RemoveVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveAudioEncoderConfiguration
#define SOAP_TYPE___ns1__RemoveAudioEncoderConfiguration (1753)
/* Operation wrapper: */
struct __ns1__RemoveAudioEncoderConfiguration
{
public:
	_ns1__RemoveAudioEncoderConfiguration *ns1__RemoveAudioEncoderConfiguration;	/* optional element of type ns1:RemoveAudioEncoderConfiguration */
public:
	int soap_type() const { return 1753; } /* = unique type id SOAP_TYPE___ns1__RemoveAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveAudioSourceConfiguration
#define SOAP_TYPE___ns1__RemoveAudioSourceConfiguration (1757)
/* Operation wrapper: */
struct __ns1__RemoveAudioSourceConfiguration
{
public:
	_ns1__RemoveAudioSourceConfiguration *ns1__RemoveAudioSourceConfiguration;	/* optional element of type ns1:RemoveAudioSourceConfiguration */
public:
	int soap_type() const { return 1757; } /* = unique type id SOAP_TYPE___ns1__RemoveAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemovePTZConfiguration
#define SOAP_TYPE___ns1__RemovePTZConfiguration (1761)
/* Operation wrapper: */
struct __ns1__RemovePTZConfiguration
{
public:
	_ns1__RemovePTZConfiguration *ns1__RemovePTZConfiguration;	/* optional element of type ns1:RemovePTZConfiguration */
public:
	int soap_type() const { return 1761; } /* = unique type id SOAP_TYPE___ns1__RemovePTZConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveVideoAnalyticsConfiguration
#define SOAP_TYPE___ns1__RemoveVideoAnalyticsConfiguration (1765)
/* Operation wrapper: */
struct __ns1__RemoveVideoAnalyticsConfiguration
{
public:
	_ns1__RemoveVideoAnalyticsConfiguration *ns1__RemoveVideoAnalyticsConfiguration;	/* optional element of type ns1:RemoveVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 1765; } /* = unique type id SOAP_TYPE___ns1__RemoveVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveMetadataConfiguration
#define SOAP_TYPE___ns1__RemoveMetadataConfiguration (1769)
/* Operation wrapper: */
struct __ns1__RemoveMetadataConfiguration
{
public:
	_ns1__RemoveMetadataConfiguration *ns1__RemoveMetadataConfiguration;	/* optional element of type ns1:RemoveMetadataConfiguration */
public:
	int soap_type() const { return 1769; } /* = unique type id SOAP_TYPE___ns1__RemoveMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveAudioOutputConfiguration
#define SOAP_TYPE___ns1__RemoveAudioOutputConfiguration (1773)
/* Operation wrapper: */
struct __ns1__RemoveAudioOutputConfiguration
{
public:
	_ns1__RemoveAudioOutputConfiguration *ns1__RemoveAudioOutputConfiguration;	/* optional element of type ns1:RemoveAudioOutputConfiguration */
public:
	int soap_type() const { return 1773; } /* = unique type id SOAP_TYPE___ns1__RemoveAudioOutputConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__RemoveAudioDecoderConfiguration
#define SOAP_TYPE___ns1__RemoveAudioDecoderConfiguration (1777)
/* Operation wrapper: */
struct __ns1__RemoveAudioDecoderConfiguration
{
public:
	_ns1__RemoveAudioDecoderConfiguration *ns1__RemoveAudioDecoderConfiguration;	/* optional element of type ns1:RemoveAudioDecoderConfiguration */
public:
	int soap_type() const { return 1777; } /* = unique type id SOAP_TYPE___ns1__RemoveAudioDecoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteProfile
#define SOAP_TYPE___ns1__DeleteProfile (1781)
/* Operation wrapper: */
struct __ns1__DeleteProfile
{
public:
	_ns1__DeleteProfile *ns1__DeleteProfile;	/* optional element of type ns1:DeleteProfile */
public:
	int soap_type() const { return 1781; } /* = unique type id SOAP_TYPE___ns1__DeleteProfile */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSourceConfigurations
#define SOAP_TYPE___ns1__GetVideoSourceConfigurations (1785)
/* Operation wrapper: */
struct __ns1__GetVideoSourceConfigurations
{
public:
	_ns1__GetVideoSourceConfigurations *ns1__GetVideoSourceConfigurations;	/* optional element of type ns1:GetVideoSourceConfigurations */
public:
	int soap_type() const { return 1785; } /* = unique type id SOAP_TYPE___ns1__GetVideoSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoEncoderConfigurations
#define SOAP_TYPE___ns1__GetVideoEncoderConfigurations (1789)
/* Operation wrapper: */
struct __ns1__GetVideoEncoderConfigurations
{
public:
	_ns1__GetVideoEncoderConfigurations *ns1__GetVideoEncoderConfigurations;	/* optional element of type ns1:GetVideoEncoderConfigurations */
public:
	int soap_type() const { return 1789; } /* = unique type id SOAP_TYPE___ns1__GetVideoEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioSourceConfigurations
#define SOAP_TYPE___ns1__GetAudioSourceConfigurations (1793)
/* Operation wrapper: */
struct __ns1__GetAudioSourceConfigurations
{
public:
	_ns1__GetAudioSourceConfigurations *ns1__GetAudioSourceConfigurations;	/* optional element of type ns1:GetAudioSourceConfigurations */
public:
	int soap_type() const { return 1793; } /* = unique type id SOAP_TYPE___ns1__GetAudioSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioEncoderConfigurations
#define SOAP_TYPE___ns1__GetAudioEncoderConfigurations (1797)
/* Operation wrapper: */
struct __ns1__GetAudioEncoderConfigurations
{
public:
	_ns1__GetAudioEncoderConfigurations *ns1__GetAudioEncoderConfigurations;	/* optional element of type ns1:GetAudioEncoderConfigurations */
public:
	int soap_type() const { return 1797; } /* = unique type id SOAP_TYPE___ns1__GetAudioEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoAnalyticsConfigurations
#define SOAP_TYPE___ns1__GetVideoAnalyticsConfigurations (1801)
/* Operation wrapper: */
struct __ns1__GetVideoAnalyticsConfigurations
{
public:
	_ns1__GetVideoAnalyticsConfigurations *ns1__GetVideoAnalyticsConfigurations;	/* optional element of type ns1:GetVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 1801; } /* = unique type id SOAP_TYPE___ns1__GetVideoAnalyticsConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetMetadataConfigurations
#define SOAP_TYPE___ns1__GetMetadataConfigurations (1805)
/* Operation wrapper: */
struct __ns1__GetMetadataConfigurations
{
public:
	_ns1__GetMetadataConfigurations *ns1__GetMetadataConfigurations;	/* optional element of type ns1:GetMetadataConfigurations */
public:
	int soap_type() const { return 1805; } /* = unique type id SOAP_TYPE___ns1__GetMetadataConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioOutputConfigurations
#define SOAP_TYPE___ns1__GetAudioOutputConfigurations (1809)
/* Operation wrapper: */
struct __ns1__GetAudioOutputConfigurations
{
public:
	_ns1__GetAudioOutputConfigurations *ns1__GetAudioOutputConfigurations;	/* optional element of type ns1:GetAudioOutputConfigurations */
public:
	int soap_type() const { return 1809; } /* = unique type id SOAP_TYPE___ns1__GetAudioOutputConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioDecoderConfigurations
#define SOAP_TYPE___ns1__GetAudioDecoderConfigurations (1813)
/* Operation wrapper: */
struct __ns1__GetAudioDecoderConfigurations
{
public:
	_ns1__GetAudioDecoderConfigurations *ns1__GetAudioDecoderConfigurations;	/* optional element of type ns1:GetAudioDecoderConfigurations */
public:
	int soap_type() const { return 1813; } /* = unique type id SOAP_TYPE___ns1__GetAudioDecoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSourceConfiguration
#define SOAP_TYPE___ns1__GetVideoSourceConfiguration (1817)
/* Operation wrapper: */
struct __ns1__GetVideoSourceConfiguration
{
public:
	_ns1__GetVideoSourceConfiguration *ns1__GetVideoSourceConfiguration;	/* optional element of type ns1:GetVideoSourceConfiguration */
public:
	int soap_type() const { return 1817; } /* = unique type id SOAP_TYPE___ns1__GetVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoEncoderConfiguration
#define SOAP_TYPE___ns1__GetVideoEncoderConfiguration (1821)
/* Operation wrapper: */
struct __ns1__GetVideoEncoderConfiguration
{
public:
	_ns1__GetVideoEncoderConfiguration *ns1__GetVideoEncoderConfiguration;	/* optional element of type ns1:GetVideoEncoderConfiguration */
public:
	int soap_type() const { return 1821; } /* = unique type id SOAP_TYPE___ns1__GetVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioSourceConfiguration
#define SOAP_TYPE___ns1__GetAudioSourceConfiguration (1825)
/* Operation wrapper: */
struct __ns1__GetAudioSourceConfiguration
{
public:
	_ns1__GetAudioSourceConfiguration *ns1__GetAudioSourceConfiguration;	/* optional element of type ns1:GetAudioSourceConfiguration */
public:
	int soap_type() const { return 1825; } /* = unique type id SOAP_TYPE___ns1__GetAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioEncoderConfiguration
#define SOAP_TYPE___ns1__GetAudioEncoderConfiguration (1829)
/* Operation wrapper: */
struct __ns1__GetAudioEncoderConfiguration
{
public:
	_ns1__GetAudioEncoderConfiguration *ns1__GetAudioEncoderConfiguration;	/* optional element of type ns1:GetAudioEncoderConfiguration */
public:
	int soap_type() const { return 1829; } /* = unique type id SOAP_TYPE___ns1__GetAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoAnalyticsConfiguration
#define SOAP_TYPE___ns1__GetVideoAnalyticsConfiguration (1833)
/* Operation wrapper: */
struct __ns1__GetVideoAnalyticsConfiguration
{
public:
	_ns1__GetVideoAnalyticsConfiguration *ns1__GetVideoAnalyticsConfiguration;	/* optional element of type ns1:GetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 1833; } /* = unique type id SOAP_TYPE___ns1__GetVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetMetadataConfiguration
#define SOAP_TYPE___ns1__GetMetadataConfiguration (1837)
/* Operation wrapper: */
struct __ns1__GetMetadataConfiguration
{
public:
	_ns1__GetMetadataConfiguration *ns1__GetMetadataConfiguration;	/* optional element of type ns1:GetMetadataConfiguration */
public:
	int soap_type() const { return 1837; } /* = unique type id SOAP_TYPE___ns1__GetMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioOutputConfiguration
#define SOAP_TYPE___ns1__GetAudioOutputConfiguration (1841)
/* Operation wrapper: */
struct __ns1__GetAudioOutputConfiguration
{
public:
	_ns1__GetAudioOutputConfiguration *ns1__GetAudioOutputConfiguration;	/* optional element of type ns1:GetAudioOutputConfiguration */
public:
	int soap_type() const { return 1841; } /* = unique type id SOAP_TYPE___ns1__GetAudioOutputConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioDecoderConfiguration
#define SOAP_TYPE___ns1__GetAudioDecoderConfiguration (1845)
/* Operation wrapper: */
struct __ns1__GetAudioDecoderConfiguration
{
public:
	_ns1__GetAudioDecoderConfiguration *ns1__GetAudioDecoderConfiguration;	/* optional element of type ns1:GetAudioDecoderConfiguration */
public:
	int soap_type() const { return 1845; } /* = unique type id SOAP_TYPE___ns1__GetAudioDecoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleVideoEncoderConfigurations
#define SOAP_TYPE___ns1__GetCompatibleVideoEncoderConfigurations (1849)
/* Operation wrapper: */
struct __ns1__GetCompatibleVideoEncoderConfigurations
{
public:
	_ns1__GetCompatibleVideoEncoderConfigurations *ns1__GetCompatibleVideoEncoderConfigurations;	/* optional element of type ns1:GetCompatibleVideoEncoderConfigurations */
public:
	int soap_type() const { return 1849; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleVideoEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleVideoSourceConfigurations
#define SOAP_TYPE___ns1__GetCompatibleVideoSourceConfigurations (1853)
/* Operation wrapper: */
struct __ns1__GetCompatibleVideoSourceConfigurations
{
public:
	_ns1__GetCompatibleVideoSourceConfigurations *ns1__GetCompatibleVideoSourceConfigurations;	/* optional element of type ns1:GetCompatibleVideoSourceConfigurations */
public:
	int soap_type() const { return 1853; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleVideoSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleAudioEncoderConfigurations
#define SOAP_TYPE___ns1__GetCompatibleAudioEncoderConfigurations (1857)
/* Operation wrapper: */
struct __ns1__GetCompatibleAudioEncoderConfigurations
{
public:
	_ns1__GetCompatibleAudioEncoderConfigurations *ns1__GetCompatibleAudioEncoderConfigurations;	/* optional element of type ns1:GetCompatibleAudioEncoderConfigurations */
public:
	int soap_type() const { return 1857; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleAudioEncoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleAudioSourceConfigurations
#define SOAP_TYPE___ns1__GetCompatibleAudioSourceConfigurations (1861)
/* Operation wrapper: */
struct __ns1__GetCompatibleAudioSourceConfigurations
{
public:
	_ns1__GetCompatibleAudioSourceConfigurations *ns1__GetCompatibleAudioSourceConfigurations;	/* optional element of type ns1:GetCompatibleAudioSourceConfigurations */
public:
	int soap_type() const { return 1861; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleAudioSourceConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleVideoAnalyticsConfigurations
#define SOAP_TYPE___ns1__GetCompatibleVideoAnalyticsConfigurations (1865)
/* Operation wrapper: */
struct __ns1__GetCompatibleVideoAnalyticsConfigurations
{
public:
	_ns1__GetCompatibleVideoAnalyticsConfigurations *ns1__GetCompatibleVideoAnalyticsConfigurations;	/* optional element of type ns1:GetCompatibleVideoAnalyticsConfigurations */
public:
	int soap_type() const { return 1865; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleVideoAnalyticsConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleMetadataConfigurations
#define SOAP_TYPE___ns1__GetCompatibleMetadataConfigurations (1869)
/* Operation wrapper: */
struct __ns1__GetCompatibleMetadataConfigurations
{
public:
	_ns1__GetCompatibleMetadataConfigurations *ns1__GetCompatibleMetadataConfigurations;	/* optional element of type ns1:GetCompatibleMetadataConfigurations */
public:
	int soap_type() const { return 1869; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleMetadataConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleAudioOutputConfigurations
#define SOAP_TYPE___ns1__GetCompatibleAudioOutputConfigurations (1873)
/* Operation wrapper: */
struct __ns1__GetCompatibleAudioOutputConfigurations
{
public:
	_ns1__GetCompatibleAudioOutputConfigurations *ns1__GetCompatibleAudioOutputConfigurations;	/* optional element of type ns1:GetCompatibleAudioOutputConfigurations */
public:
	int soap_type() const { return 1873; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleAudioOutputConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__GetCompatibleAudioDecoderConfigurations
#define SOAP_TYPE___ns1__GetCompatibleAudioDecoderConfigurations (1877)
/* Operation wrapper: */
struct __ns1__GetCompatibleAudioDecoderConfigurations
{
public:
	_ns1__GetCompatibleAudioDecoderConfigurations *ns1__GetCompatibleAudioDecoderConfigurations;	/* optional element of type ns1:GetCompatibleAudioDecoderConfigurations */
public:
	int soap_type() const { return 1877; } /* = unique type id SOAP_TYPE___ns1__GetCompatibleAudioDecoderConfigurations */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoSourceConfiguration
#define SOAP_TYPE___ns1__SetVideoSourceConfiguration (1881)
/* Operation wrapper: */
struct __ns1__SetVideoSourceConfiguration
{
public:
	_ns1__SetVideoSourceConfiguration *ns1__SetVideoSourceConfiguration;	/* optional element of type ns1:SetVideoSourceConfiguration */
public:
	int soap_type() const { return 1881; } /* = unique type id SOAP_TYPE___ns1__SetVideoSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoEncoderConfiguration
#define SOAP_TYPE___ns1__SetVideoEncoderConfiguration (1885)
/* Operation wrapper: */
struct __ns1__SetVideoEncoderConfiguration
{
public:
	_ns1__SetVideoEncoderConfiguration *ns1__SetVideoEncoderConfiguration;	/* optional element of type ns1:SetVideoEncoderConfiguration */
public:
	int soap_type() const { return 1885; } /* = unique type id SOAP_TYPE___ns1__SetVideoEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioSourceConfiguration
#define SOAP_TYPE___ns1__SetAudioSourceConfiguration (1889)
/* Operation wrapper: */
struct __ns1__SetAudioSourceConfiguration
{
public:
	_ns1__SetAudioSourceConfiguration *ns1__SetAudioSourceConfiguration;	/* optional element of type ns1:SetAudioSourceConfiguration */
public:
	int soap_type() const { return 1889; } /* = unique type id SOAP_TYPE___ns1__SetAudioSourceConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioEncoderConfiguration
#define SOAP_TYPE___ns1__SetAudioEncoderConfiguration (1893)
/* Operation wrapper: */
struct __ns1__SetAudioEncoderConfiguration
{
public:
	_ns1__SetAudioEncoderConfiguration *ns1__SetAudioEncoderConfiguration;	/* optional element of type ns1:SetAudioEncoderConfiguration */
public:
	int soap_type() const { return 1893; } /* = unique type id SOAP_TYPE___ns1__SetAudioEncoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoAnalyticsConfiguration
#define SOAP_TYPE___ns1__SetVideoAnalyticsConfiguration (1897)
/* Operation wrapper: */
struct __ns1__SetVideoAnalyticsConfiguration
{
public:
	_ns1__SetVideoAnalyticsConfiguration *ns1__SetVideoAnalyticsConfiguration;	/* optional element of type ns1:SetVideoAnalyticsConfiguration */
public:
	int soap_type() const { return 1897; } /* = unique type id SOAP_TYPE___ns1__SetVideoAnalyticsConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetMetadataConfiguration
#define SOAP_TYPE___ns1__SetMetadataConfiguration (1901)
/* Operation wrapper: */
struct __ns1__SetMetadataConfiguration
{
public:
	_ns1__SetMetadataConfiguration *ns1__SetMetadataConfiguration;	/* optional element of type ns1:SetMetadataConfiguration */
public:
	int soap_type() const { return 1901; } /* = unique type id SOAP_TYPE___ns1__SetMetadataConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioOutputConfiguration
#define SOAP_TYPE___ns1__SetAudioOutputConfiguration (1905)
/* Operation wrapper: */
struct __ns1__SetAudioOutputConfiguration
{
public:
	_ns1__SetAudioOutputConfiguration *ns1__SetAudioOutputConfiguration;	/* optional element of type ns1:SetAudioOutputConfiguration */
public:
	int soap_type() const { return 1905; } /* = unique type id SOAP_TYPE___ns1__SetAudioOutputConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__SetAudioDecoderConfiguration
#define SOAP_TYPE___ns1__SetAudioDecoderConfiguration (1909)
/* Operation wrapper: */
struct __ns1__SetAudioDecoderConfiguration
{
public:
	_ns1__SetAudioDecoderConfiguration *ns1__SetAudioDecoderConfiguration;	/* optional element of type ns1:SetAudioDecoderConfiguration */
public:
	int soap_type() const { return 1909; } /* = unique type id SOAP_TYPE___ns1__SetAudioDecoderConfiguration */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSourceConfigurationOptions
#define SOAP_TYPE___ns1__GetVideoSourceConfigurationOptions (1913)
/* Operation wrapper: */
struct __ns1__GetVideoSourceConfigurationOptions
{
public:
	_ns1__GetVideoSourceConfigurationOptions *ns1__GetVideoSourceConfigurationOptions;	/* optional element of type ns1:GetVideoSourceConfigurationOptions */
public:
	int soap_type() const { return 1913; } /* = unique type id SOAP_TYPE___ns1__GetVideoSourceConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions
#define SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions (1917)
/* Operation wrapper: */
struct __ns1__GetVideoEncoderConfigurationOptions
{
public:
	_ns1__GetVideoEncoderConfigurationOptions *ns1__GetVideoEncoderConfigurationOptions;	/* optional element of type ns1:GetVideoEncoderConfigurationOptions */
public:
	int soap_type() const { return 1917; } /* = unique type id SOAP_TYPE___ns1__GetVideoEncoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioSourceConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioSourceConfigurationOptions (1921)
/* Operation wrapper: */
struct __ns1__GetAudioSourceConfigurationOptions
{
public:
	_ns1__GetAudioSourceConfigurationOptions *ns1__GetAudioSourceConfigurationOptions;	/* optional element of type ns1:GetAudioSourceConfigurationOptions */
public:
	int soap_type() const { return 1921; } /* = unique type id SOAP_TYPE___ns1__GetAudioSourceConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioEncoderConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioEncoderConfigurationOptions (1925)
/* Operation wrapper: */
struct __ns1__GetAudioEncoderConfigurationOptions
{
public:
	_ns1__GetAudioEncoderConfigurationOptions *ns1__GetAudioEncoderConfigurationOptions;	/* optional element of type ns1:GetAudioEncoderConfigurationOptions */
public:
	int soap_type() const { return 1925; } /* = unique type id SOAP_TYPE___ns1__GetAudioEncoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetMetadataConfigurationOptions
#define SOAP_TYPE___ns1__GetMetadataConfigurationOptions (1929)
/* Operation wrapper: */
struct __ns1__GetMetadataConfigurationOptions
{
public:
	_ns1__GetMetadataConfigurationOptions *ns1__GetMetadataConfigurationOptions;	/* optional element of type ns1:GetMetadataConfigurationOptions */
public:
	int soap_type() const { return 1929; } /* = unique type id SOAP_TYPE___ns1__GetMetadataConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioOutputConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioOutputConfigurationOptions (1933)
/* Operation wrapper: */
struct __ns1__GetAudioOutputConfigurationOptions
{
public:
	_ns1__GetAudioOutputConfigurationOptions *ns1__GetAudioOutputConfigurationOptions;	/* optional element of type ns1:GetAudioOutputConfigurationOptions */
public:
	int soap_type() const { return 1933; } /* = unique type id SOAP_TYPE___ns1__GetAudioOutputConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetAudioDecoderConfigurationOptions
#define SOAP_TYPE___ns1__GetAudioDecoderConfigurationOptions (1937)
/* Operation wrapper: */
struct __ns1__GetAudioDecoderConfigurationOptions
{
public:
	_ns1__GetAudioDecoderConfigurationOptions *ns1__GetAudioDecoderConfigurationOptions;	/* optional element of type ns1:GetAudioDecoderConfigurationOptions */
public:
	int soap_type() const { return 1937; } /* = unique type id SOAP_TYPE___ns1__GetAudioDecoderConfigurationOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__GetGuaranteedNumberOfVideoEncoderInstances
#define SOAP_TYPE___ns1__GetGuaranteedNumberOfVideoEncoderInstances (1941)
/* Operation wrapper: */
struct __ns1__GetGuaranteedNumberOfVideoEncoderInstances
{
public:
	_ns1__GetGuaranteedNumberOfVideoEncoderInstances *ns1__GetGuaranteedNumberOfVideoEncoderInstances;	/* optional element of type ns1:GetGuaranteedNumberOfVideoEncoderInstances */
public:
	int soap_type() const { return 1941; } /* = unique type id SOAP_TYPE___ns1__GetGuaranteedNumberOfVideoEncoderInstances */
};
#endif

#ifndef SOAP_TYPE___ns1__GetStreamUri
#define SOAP_TYPE___ns1__GetStreamUri (1945)
/* Operation wrapper: */
struct __ns1__GetStreamUri
{
public:
	_ns1__GetStreamUri *ns1__GetStreamUri;	/* optional element of type ns1:GetStreamUri */
public:
	int soap_type() const { return 1945; } /* = unique type id SOAP_TYPE___ns1__GetStreamUri */
};
#endif

#ifndef SOAP_TYPE___ns1__StartMulticastStreaming
#define SOAP_TYPE___ns1__StartMulticastStreaming (1949)
/* Operation wrapper: */
struct __ns1__StartMulticastStreaming
{
public:
	_ns1__StartMulticastStreaming *ns1__StartMulticastStreaming;	/* optional element of type ns1:StartMulticastStreaming */
public:
	int soap_type() const { return 1949; } /* = unique type id SOAP_TYPE___ns1__StartMulticastStreaming */
};
#endif

#ifndef SOAP_TYPE___ns1__StopMulticastStreaming
#define SOAP_TYPE___ns1__StopMulticastStreaming (1953)
/* Operation wrapper: */
struct __ns1__StopMulticastStreaming
{
public:
	_ns1__StopMulticastStreaming *ns1__StopMulticastStreaming;	/* optional element of type ns1:StopMulticastStreaming */
public:
	int soap_type() const { return 1953; } /* = unique type id SOAP_TYPE___ns1__StopMulticastStreaming */
};
#endif

#ifndef SOAP_TYPE___ns1__SetSynchronizationPoint
#define SOAP_TYPE___ns1__SetSynchronizationPoint (1957)
/* Operation wrapper: */
struct __ns1__SetSynchronizationPoint
{
public:
	_ns1__SetSynchronizationPoint *ns1__SetSynchronizationPoint;	/* optional element of type ns1:SetSynchronizationPoint */
public:
	int soap_type() const { return 1957; } /* = unique type id SOAP_TYPE___ns1__SetSynchronizationPoint */
};
#endif

#ifndef SOAP_TYPE___ns1__GetSnapshotUri
#define SOAP_TYPE___ns1__GetSnapshotUri (1961)
/* Operation wrapper: */
struct __ns1__GetSnapshotUri
{
public:
	_ns1__GetSnapshotUri *ns1__GetSnapshotUri;	/* optional element of type ns1:GetSnapshotUri */
public:
	int soap_type() const { return 1961; } /* = unique type id SOAP_TYPE___ns1__GetSnapshotUri */
};
#endif

#ifndef SOAP_TYPE___ns1__GetVideoSourceModes
#define SOAP_TYPE___ns1__GetVideoSourceModes (1965)
/* Operation wrapper: */
struct __ns1__GetVideoSourceModes
{
public:
	_ns1__GetVideoSourceModes *ns1__GetVideoSourceModes;	/* optional element of type ns1:GetVideoSourceModes */
public:
	int soap_type() const { return 1965; } /* = unique type id SOAP_TYPE___ns1__GetVideoSourceModes */
};
#endif

#ifndef SOAP_TYPE___ns1__SetVideoSourceMode
#define SOAP_TYPE___ns1__SetVideoSourceMode (1969)
/* Operation wrapper: */
struct __ns1__SetVideoSourceMode
{
public:
	_ns1__SetVideoSourceMode *ns1__SetVideoSourceMode;	/* optional element of type ns1:SetVideoSourceMode */
public:
	int soap_type() const { return 1969; } /* = unique type id SOAP_TYPE___ns1__SetVideoSourceMode */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOSDs
#define SOAP_TYPE___ns1__GetOSDs (1973)
/* Operation wrapper: */
struct __ns1__GetOSDs
{
public:
	_ns1__GetOSDs *ns1__GetOSDs;	/* optional element of type ns1:GetOSDs */
public:
	int soap_type() const { return 1973; } /* = unique type id SOAP_TYPE___ns1__GetOSDs */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOSD
#define SOAP_TYPE___ns1__GetOSD (1977)
/* Operation wrapper: */
struct __ns1__GetOSD
{
public:
	_ns1__GetOSD *ns1__GetOSD;	/* optional element of type ns1:GetOSD */
public:
	int soap_type() const { return 1977; } /* = unique type id SOAP_TYPE___ns1__GetOSD */
};
#endif

#ifndef SOAP_TYPE___ns1__GetOSDOptions
#define SOAP_TYPE___ns1__GetOSDOptions (1981)
/* Operation wrapper: */
struct __ns1__GetOSDOptions
{
public:
	_ns1__GetOSDOptions *ns1__GetOSDOptions;	/* optional element of type ns1:GetOSDOptions */
public:
	int soap_type() const { return 1981; } /* = unique type id SOAP_TYPE___ns1__GetOSDOptions */
};
#endif

#ifndef SOAP_TYPE___ns1__SetOSD
#define SOAP_TYPE___ns1__SetOSD (1985)
/* Operation wrapper: */
struct __ns1__SetOSD
{
public:
	_ns1__SetOSD *ns1__SetOSD;	/* optional element of type ns1:SetOSD */
public:
	int soap_type() const { return 1985; } /* = unique type id SOAP_TYPE___ns1__SetOSD */
};
#endif

#ifndef SOAP_TYPE___ns1__CreateOSD
#define SOAP_TYPE___ns1__CreateOSD (1989)
/* Operation wrapper: */
struct __ns1__CreateOSD
{
public:
	_ns1__CreateOSD *ns1__CreateOSD;	/* optional element of type ns1:CreateOSD */
public:
	int soap_type() const { return 1989; } /* = unique type id SOAP_TYPE___ns1__CreateOSD */
};
#endif

#ifndef SOAP_TYPE___ns1__DeleteOSD
#define SOAP_TYPE___ns1__DeleteOSD (1993)
/* Operation wrapper: */
struct __ns1__DeleteOSD
{
public:
	_ns1__DeleteOSD *ns1__DeleteOSD;	/* optional element of type ns1:DeleteOSD */
public:
	int soap_type() const { return 1993; } /* = unique type id SOAP_TYPE___ns1__DeleteOSD */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (1994)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 1994; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (1995)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 1995; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (1997)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 1997; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (2000)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 2000; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Envelope
#define SOAP_TYPE_SOAP_ENV__Envelope (17)
typedef std::string SOAP_ENV__Envelope;
#endif

#ifndef SOAP_TYPE_xsd__NCName
#define SOAP_TYPE_xsd__NCName (18)
typedef std::string xsd__NCName;
#endif

#ifndef SOAP_TYPE_xsd__anySimpleType
#define SOAP_TYPE_xsd__anySimpleType (21)
typedef std::string xsd__anySimpleType;
#endif

#ifndef SOAP_TYPE_xsd__anyURI
#define SOAP_TYPE_xsd__anyURI (23)
typedef std::string xsd__anyURI;
#endif

#ifndef SOAP_TYPE_xsd__duration
#define SOAP_TYPE_xsd__duration (30)
typedef std::string xsd__duration;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (36)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE_xsd__nonNegativeInteger
#define SOAP_TYPE_xsd__nonNegativeInteger (38)
typedef std::string xsd__nonNegativeInteger;
#endif

#ifndef SOAP_TYPE_xsd__token
#define SOAP_TYPE_xsd__token (41)
typedef std::string xsd__token;
#endif

#ifndef SOAP_TYPE__xmime__contentType
#define SOAP_TYPE__xmime__contentType (45)
typedef std::string _xmime__contentType;
#endif

#ifndef SOAP_TYPE__xml__lang
#define SOAP_TYPE__xml__lang (46)
typedef std::string _xml__lang;
#endif

#ifndef SOAP_TYPE_ns1__EncodingTypes
#define SOAP_TYPE_ns1__EncodingTypes (754)
typedef std::string ns1__EncodingTypes;
#endif

#ifndef SOAP_TYPE_ns2__IntAttrList
#define SOAP_TYPE_ns2__IntAttrList (755)
typedef std::string ns2__IntAttrList;
#endif

#ifndef SOAP_TYPE_ns2__FloatAttrList
#define SOAP_TYPE_ns2__FloatAttrList (756)
typedef std::string ns2__FloatAttrList;
#endif

#ifndef SOAP_TYPE_ns2__StringAttrList
#define SOAP_TYPE_ns2__StringAttrList (757)
typedef std::string ns2__StringAttrList;
#endif

#ifndef SOAP_TYPE_ns2__ReferenceTokenList
#define SOAP_TYPE_ns2__ReferenceTokenList (758)
typedef std::string ns2__ReferenceTokenList;
#endif

#ifndef SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType
#define SOAP_TYPE_ns3__AbsoluteOrRelativeTimeType (759)
typedef std::string ns3__AbsoluteOrRelativeTimeType;
#endif

#ifndef SOAP_TYPE_ns7__RelationshipTypeOpenEnum
#define SOAP_TYPE_ns7__RelationshipTypeOpenEnum (760)
typedef std::string ns7__RelationshipTypeOpenEnum;
#endif

#ifndef SOAP_TYPE_ns7__FaultCodesOpenEnumType
#define SOAP_TYPE_ns7__FaultCodesOpenEnumType (761)
typedef std::string ns7__FaultCodesOpenEnumType;
#endif

#ifndef SOAP_TYPE_ns2__ReferenceToken
#define SOAP_TYPE_ns2__ReferenceToken (762)
typedef std::string ns2__ReferenceToken;
#endif

#ifndef SOAP_TYPE_ns2__Name
#define SOAP_TYPE_ns2__Name (764)
typedef std::string ns2__Name;
#endif

#ifndef SOAP_TYPE_ns2__NetworkInterfaceConfigPriority
#define SOAP_TYPE_ns2__NetworkInterfaceConfigPriority (786)
typedef std::string ns2__NetworkInterfaceConfigPriority;
#endif

#ifndef SOAP_TYPE_ns2__IANA_IfTypes
#define SOAP_TYPE_ns2__IANA_IfTypes (790)
typedef int ns2__IANA_IfTypes;
#endif

#ifndef SOAP_TYPE_ns2__IPv4Address
#define SOAP_TYPE_ns2__IPv4Address (798)
typedef std::string ns2__IPv4Address;
#endif

#ifndef SOAP_TYPE_ns2__IPv6Address
#define SOAP_TYPE_ns2__IPv6Address (800)
typedef std::string ns2__IPv6Address;
#endif

#ifndef SOAP_TYPE_ns2__HwAddress
#define SOAP_TYPE_ns2__HwAddress (802)
typedef std::string ns2__HwAddress;
#endif

#ifndef SOAP_TYPE_ns2__DNSName
#define SOAP_TYPE_ns2__DNSName (806)
typedef std::string ns2__DNSName;
#endif

#ifndef SOAP_TYPE_ns2__Domain
#define SOAP_TYPE_ns2__Domain (808)
typedef std::string ns2__Domain;
#endif

#ifndef SOAP_TYPE_ns2__Dot11SSIDType
#define SOAP_TYPE_ns2__Dot11SSIDType (814)
typedef xsd__hexBinary ns2__Dot11SSIDType;
#endif

#ifndef SOAP_TYPE_ns2__Dot11PSK
#define SOAP_TYPE_ns2__Dot11PSK (822)
typedef xsd__hexBinary ns2__Dot11PSK;
#endif

#ifndef SOAP_TYPE_ns2__Dot11PSKPassphrase
#define SOAP_TYPE_ns2__Dot11PSKPassphrase (824)
typedef std::string ns2__Dot11PSKPassphrase;
#endif

#ifndef SOAP_TYPE_ns2__AuxiliaryData
#define SOAP_TYPE_ns2__AuxiliaryData (850)
typedef std::string ns2__AuxiliaryData;
#endif

#ifndef SOAP_TYPE_ns2__TopicNamespaceLocation
#define SOAP_TYPE_ns2__TopicNamespaceLocation (884)
typedef std::string ns2__TopicNamespaceLocation;
#endif

#ifndef SOAP_TYPE_ns2__Description
#define SOAP_TYPE_ns2__Description (896)
typedef std::string ns2__Description;
#endif

#ifndef SOAP_TYPE_ns2__XPathExpression
#define SOAP_TYPE_ns2__XPathExpression (898)
typedef std::string ns2__XPathExpression;
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobMode
#define SOAP_TYPE_ns2__RecordingJobMode (906)
typedef std::string ns2__RecordingJobMode;
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobState
#define SOAP_TYPE_ns2__RecordingJobState (908)
typedef std::string ns2__RecordingJobState;
#endif

#ifndef SOAP_TYPE_ns2__AudioClassType
#define SOAP_TYPE_ns2__AudioClassType (912)
typedef std::string ns2__AudioClassType;
#endif

#ifndef SOAP_TYPE_ns6__FullTopicExpression
#define SOAP_TYPE_ns6__FullTopicExpression (916)
typedef std::string ns6__FullTopicExpression;
#endif

#ifndef SOAP_TYPE_ns6__ConcreteTopicExpression
#define SOAP_TYPE_ns6__ConcreteTopicExpression (918)
typedef std::string ns6__ConcreteTopicExpression;
#endif

#ifndef SOAP_TYPE_ns6__SimpleTopicExpression
#define SOAP_TYPE_ns6__SimpleTopicExpression (920)
typedef std::string ns6__SimpleTopicExpression;
#endif

#ifndef SOAP_TYPE_ns2__ReceiverReference
#define SOAP_TYPE_ns2__ReceiverReference (926)
typedef std::string ns2__ReceiverReference;
#endif

#ifndef SOAP_TYPE_ns2__RecordingReference
#define SOAP_TYPE_ns2__RecordingReference (928)
typedef std::string ns2__RecordingReference;
#endif

#ifndef SOAP_TYPE_ns2__TrackReference
#define SOAP_TYPE_ns2__TrackReference (930)
typedef std::string ns2__TrackReference;
#endif

#ifndef SOAP_TYPE_ns2__JobToken
#define SOAP_TYPE_ns2__JobToken (932)
typedef std::string ns2__JobToken;
#endif

#ifndef SOAP_TYPE_ns2__RecordingJobReference
#define SOAP_TYPE_ns2__RecordingJobReference (934)
typedef std::string ns2__RecordingJobReference;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
